{"title":"(Un)Biased estimates","markdown":{"yaml":{"title":"(Un)Biased estimates","format":{"html":{"page-layout":"full"}},"toc":false,"execute":{"echo":false}},"headingText":"sd(population) # should be 1","containsRefs":false,"markdown":"\n\n\n:::: {#controls}\n::: {#controls-container}\n:::\n\n::: {#select-estimate}\nShow: \n[$M$]{.select-mean .selector .unselected}\n[$SD_{n}$]{.select-population .selector}\n[$SD_{n - 1}$]{.select-sample .selector}\n:::\n::::\n\n::: {.g-row}\n\n::: {#population-container}\n:::\n\n::: {#timeline-container}\n:::\n\n:::\n\n\n\n```{ojs}\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n```\n\n```{r}\ndata <- tibble::tibble(value = seq(-4, 4, length.out = 201),\n                       density = dnorm(value)) |> \n  purrr::transpose()\n\nojs_define(data)\n\nset.seed(4)\npopulation <- rnorm(550)\npopulation <- scale(population)\nojs_define(population)\n```\n\n\n```{ojs}\nw = 800\nh = 400\n\nmaxWidth = 900;\nmaxHeight = 550;\n\ntimeseriesVertical = false;\n\npanelSpacing = 5;\n\npopulationPanelWidth = maxWidth * 0.6;\npopulationPanelHeight = maxHeight;\n\npopulationSubPanelProportion = 0.4;\nsampleSubPanelProportion = 0.05;\n\nestimatesSubPanelProportion = 0.55;\n\nestimatesPanelWidth = maxWidth - populationPanelWidth;\nestimatesPanelHeight = populationPanelHeight;\n\ntimeSeriesPanelWidth = maxWidth - populationPanelWidth;\n\n\n\nradius = 4; //1.4\nsampleSize = 5;\n\n    \nxScalePopulation = d3.scaleLinear()\n    .domain([-4, 4])\n    .range([0 + radius, (populationPanelWidth) - radius])\nyScalePopulation = d3.scaleLinear()\n    .domain([0, 300])\n    .range([populationPanelHeight * populationSubPanelProportion, 0])\n\nxScaleEstimates = d3.scaleLinear()\n    .domain([-1.25, 1.25])\n    .range([0, estimatesPanelWidth])\n    \nyScaleEstimates = d3.scaleLinear()\n    .domain([20, 0])\n    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])\n\nxAxisEstimatesValues = [-2, -1, 0, 1, 2];\nxAxisEstimates = d3.axisBottom(xScalePopulation)\n  .tickValues(xAxisEstimatesValues)\n  .tickFormat(d => d)\n  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)\n  \n```\n\n\n\n\n```{ojs}\nupdate_svg = {\n\n  var sample = [];\n  var sampleData = [];\n  var sample_estimates = [];\n  var running_averages = [{param: \"population\", value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n  \n  var nSamplesDrawn = 0;\n  \n  var legendSelected = [\"sample\", \"population\"]\n  \n  var timeX, timeY, biasLine, timeXAxis, timeYAxis;\n  var timeSvg, \n  timeScaleBias, \n  timeScaleId, \n  timeBiasAxis, \n  timeIdAxis, \n  timeseriesDataLayer,\n  timeseriesBiasAxisLayer,\n  timeseriesIdAxisLayer;\n\n  let isLargeScreen;\n\n  function newSample() {\n    \n    nSamplesDrawn++\n    \n    // pick random observations from the population by their index\n    for (var i = 0; i < sampleSize; i++) {\n      let randomIndex = Math.floor(Math.random() * popData.length);\n      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);\n      sampleData[i] = popData[randomIndex];\n    }\n    \n    var estimates = getSampleEstimates(sample)\n    estimates.map(d => d.id = nSamplesDrawn);\n    sample_estimates.push(estimates)\n    \n    updateRunningAverages(estimates);\n    updateBiasChart();\n    updateSampleCircles();\n    animateEstimates(sampleData, estimates);\n    updatePath();\n    updateVisibility();\n  }\n  \n  function updateBiasChart() {\n      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])\n      \n      biasDots.selectAll(\"path\").remove()\n      biasDots.selectAll(\"path\")\n          .data(sample_estimates.flat())\n          .enter()\n          .append(\"path\")\n            .attr(\"id\", d => d.param + \"-estimate\")\n            .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n            .attr(\"transform\", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)\n            .attr(\"opacity\", d => (d.id === nSamplesDrawn ? 0 : 1))\n            .transition()\n            .attr(\"transform\", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)\n            \n  }\n  \n\n  \n  function updateSampleCircles() {\n  \n  let durationMultiplier = 5;\n  if (playing) durationMultiplier = 1;\n  \n    sampleCircles.selectAll('circle').remove()\n    sampleCircles.selectAll('circle')\n      .data(sampleData)\n      .enter().append(\"circle\")\n      .attr(\"class\", \"sample\")\n      .attr(\"r\", radius)\n      .attr(\"cx\", d => d.cx)\n      .attr(\"cy\", d => yScalePopulation(d.cy))\n      .attr(\"fill\", d => d.fill)\n      .transition()\n      .duration(d => d.cy * durationMultiplier)\n      .ease(d3.easeBounceOut)\n      .attr(\"cy\", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)\n  }\n  \n  \n  \n  function animateEstimates(sampleData, estimates) {\n  \n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    \n    var wait = Math.max(...sampleData.map(z => z.cy));\n    \n    for (let i = 0; i < estimates.length; i++) {\n\n    var p = estimates[i].param;\n    var endPosition = estimates[i].value;\n    var dur = (playing ? 0 : 1000);\n    var convergeWait = (playing ? 0 : wait * 5);\n    var moveDownWait = (playing ? 250 : 0);\n    \n    sampleData.forEach((s) => {\n    \n    // first, place estimate symbols where each sample dot lands\n      sampleEstimatesTemp\n      .append(\"path\")\n      .attr(\"id\", p + \"-estimate\")\n      .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n        .attr(\"transform\", d => `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        .attr(\"opacity\", 0)\n        \n    // then move them all to the estimate\n        .transition().duration(dur * 0.67).delay(convergeWait)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", d => `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        \n    // then move them down to the estimates tracker\n    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)\n      .ease(d3.easeCubicOut)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)\n    })\n\n    }\n  }\n  \n  const sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }\n  var playing = false;\n  function playButtonClicked() {\n    \n    playing = !playing; \n  \n  play_button.text(function(){\n    if(playing) {\n      return \"◼\"\n  } else {\n    return \"▶\"\n  }\n  })\n  \n  if (playing) {\n    continuouslyDrawSamples();\n  }\n  }\n  \n  function continuouslyDrawSamples() {\n    if (playing) {\n      newSample();\n      sleep(200).then(continuouslyDrawSamples);\n    }\n  }\n  \n    \n  var popData = [];\n  const color = d3.scaleOrdinal(d3.schemeCategory10);\n  for (let i = 0; i < population.length; ++i) {\n    const cx = xScalePopulation(population[i]);\n    const cy = 10 + (dodge(cx) - radius - 1);\n    <!-- const cy = yScalePopulation(dodge(cx)); -->\n    const fill = color(i % 10);\n    popData.push({cx, cy, fill})\n  }\n  \n  \n  \n  const populationLabels = [{label: \"Population\", top: 0},\n                            {label: \"Sample\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion) * 100},\n                            {label: \"Under/over-</br>estimation of</br>parameter\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion + sampleSubPanelProportion) * 100}]\n  \n  const populationContainer = d3.select(\"#population-container\")\n    .style(\"position\", \"relative\")\n    <!-- .style(\"height\", maxHeight) -->\n    \n    // panel labels\n  populationContainer.selectAll(\"text\").data(populationLabels).enter()\n    .append(\"text\")\n    .style(\"position\", \"absolute\")\n    .html(d => d.label)\n    .style(\"top\", d => d.top + \"%\")\n    .style(\"line-height\", \"1em\")\n\n  const populationAndSampleSvg = d3.select(\"#population-container\")\n    .append(\"svg\").attr(\"id\", \"populationAndSample-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + (populationPanelWidth) + \" \" + populationPanelHeight)\n    \n    // panel backgrounds\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight * populationSubPanelProportion)\n    .attr(\"fill\", \"var(--population-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * populationSubPanelProportion)\n    .attr(\"height\", populationPanelHeight * sampleSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--sample-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * (1 - estimatesSubPanelProportion))\n    .attr(\"height\", populationPanelHeight * estimatesSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n    \n\n    \n  const pop = populationAndSampleSvg.append(\"g\")\n  const parameters = populationAndSampleSvg.append(\"g\")\n  const sampleEstimates = populationAndSampleSvg.append(\"g\")\n  const sampleEstimatesTemp = populationAndSampleSvg.append(\"g\")\n  const sampleCircles = populationAndSampleSvg.append(\"g\")\n\n  const biasDots  = sampleEstimates.append(\"g\")\n  \n  pop.selectAll(\"circle\")\n      .data(popData)\n      .enter()\n      .append(\"circle\")\n        .attr(\"class\", \"pop\")\n        .attr(\"cx\", d => d.cx)\n        .attr(\"cy\", d => yScalePopulation(d.cy))\n        .attr(\"r\", radius)\n        .attr(\"fill\", d => d.fill)\n        \n    // estimates axis\n    \n  const estimatesAxis = sampleEstimates.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScaleEstimates(21)})`)\n  \n  estimatesAxis.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight - yScaleEstimates(21))\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n  estimatesAxis.call(xAxisEstimates)\n  estimatesAxis.select(\".domain\").remove()\n  \n\n\n  \n  formatAxes(estimatesAxis.selectAll(\"line\"));\n  \n    \n  var legendStatus = [{param: \"mean\",       hide: true},\n                      {param: \"population\", hide: false},\n                      {param: \"sample\",     hide: false}]\n                      \n  \n  function updateLegendStatus(param) {\n    var index;\n    if (param===\"mean\") {index = 0;}\n    if (param===\"population\") {index = 1;}\n    if (param===\"sample\") {index = 2;}\n    legendStatus[index].hide = !legendStatus[index].hide\n\n    var classes = \"#\" + param + \"-estimate\"\n    \n    populationAndSampleSvg.selectAll(classes).classed(\"hide\", legendStatus[index].hide)\n    timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[index].hide)\n    legend.classed(\"unselected\", d => d.hide)\n  }\n  \n    const legend = d3.selectAll(\".selector\")\n    legend\n      .data(legendStatus)\n      .classed(\"unselected\", d => d.hide)\n      .on(\"click\", function(event, d){updateLegendStatus(d.param);})\n  \n\n\n  \n  // buttons\n  const controls = d3.select(\"#controls-container\")\n  \n  const reset_button = controls.append(\"button\")\n    // .attr(\"class\", \"button invertable\")\n    // .attr(\"type\", \"button\")\n    .text(\"Reset\")\n    .on(\"click\", clearData)\n  \n  const button = controls.append(\"button\")\n    .text(\"Take one sample\")\n    .on(\"click\", newSample)\n    \n  const play_button = controls.append(\"button\")\n    .attr(\"id\", \"play-button\")\n    // .attr(\"class\", \"button invertable\")\n    .attr(\"x\", 50)\n    .attr(\"y\", h - 50)\n    .html(\"►\")\n    .on(\"click\", playButtonClicked)\n    \n\n\n// make timeseries chart\nconst timeChart = {\n    width: timeSeriesPanelWidth,\n    height: maxHeight,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\nconst timeChartHorizontal = {\n    width: populationPanelWidth,\n    height: 300,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\n  const timeseriesContainer = d3.select(\"#timeline-container\");\n  timeseriesContainer.style(\"position\", \"relative\")\n\n  updateTimeseriesDimensions(window.innerWidth);\n\n  // Re-render the chart whenever the window size changes\n  window.addEventListener(\"resize\", () => updateTimeseriesDimensions(window.innerWidth)); \n\n\n\n  function updateTimeseriesDimensions(winWidth) {\n\n    const largeScreen = winWidth > 600;\n    if (largeScreen === isLargeScreen) return;\n    // Update the screen state\n    isLargeScreen = largeScreen;\n    \n  var params;\n  var orientation = (winWidth > 600) ? \"vertical\" : \"horizontal;\"\n\n  console.log(orientation);\n\n  // first, set up chart dimensions and axes\n  if (winWidth > 600) {\n\n    params = timeChart;\n\n    timeScaleBias = d3.scaleLinear()\n      .domain([-0.5, 0.5])\n      .range([params.margin.left, params.width - params.margin.right])\n    timeScaleId = d3.scaleLinear()\n      .domain([0, 200])\n      .range([params.margin.top, params.height - params.margin.bottom])\n    biasLine = function(x, y){\n        return d3.line()\n        .x(function(d,i) { return timeScaleBias(x[i]); })\n        .y(function(d,i) { return timeScaleId(y[i]); })\n        (Array(x.length));\n    }\n    timeBiasAxis = d3.axisTop(timeScaleBias)\n      .ticks(5)\n      .tickSize(-(params.height - params.margin.top - params.margin.bottom)) // 440\n    timeIdAxis = d3.axisRight(timeScaleId).tickSize(0)\n  } else {\n\n      params = timeChartHorizontal;\n\n      timeScaleBias = d3.scaleLinear()\n        .domain([-0.5, 0.5])\n        .range([params.height - params.margin.bottom, params.margin.top])\n        \n      timeScaleId = d3.scaleLinear()\n        .domain([0, 200])\n        .range([params.margin.left, params.width - params.margin.right])\n      biasLine = function(x, y){\n          return d3.line()\n          .x(function(d,i) { return timeScaleId(y[i]); })\n          .y(function(d,i) { return timeScaleBias(x[i]); })\n          (Array(x.length));\n      }\n    timeIdAxis = d3.axisBottom(timeScaleId)\n      .tickSize(0)\n    timeBiasAxis = d3.axisLeft(timeScaleBias)\n      .ticks(5).tickSize(-params.width - params.margin.left - params.margin.right)\n  }\n\n  // then instantiate the chart svg itself\n  d3.select(\"#timeline-container\").select(\"svg\").remove();\n  d3.select(\"#timeline-container\").selectAll(\"text\").remove();\n  timeSvg = makeTimeseriesChart(params);\n  timeseriesDataLayer = timeSvg.append(\"g\");\n  timeseriesBiasAxisLayer = timeSvg.append(\"g\");\n  timeseriesIdAxisLayer = timeSvg.append(\"g\");\n\n  // then place the axes\n  positionTimeAxes(orientation, params);\n\n  // then draw the current data\n  updatePath();\n}\n\n  \n\n  \n  function makeTimeseriesChart(params) {\n    \n    // text labels\n    timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .text(\"Average under/over-estimation\")\n  \n  timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"line-height\", \"1em\")\n    .style(\"bottom\", 0)\n    .style(\"right\", 0)\n    .style(\"text-align\", \"right\")\n    .html(\"Total<br>samples\")\n    \n    const svg = d3.select(\"#timeline-container\")\n    .append(\"svg\").attr(\"id\", \"timeline-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + params.width + \" \" + params.height)\n    \n    // background panel\n  svg.append(\"rect\")\n    .attr(\"width\", params.width)\n    .attr(\"height\", params.height)\n    .attr(\"rx\", 5)\n    .attr(\"fill\", \"var(--timeseries-panel-background)\")\n    \n    return svg;\n    \n  }\n  \n  \n  function positionTimeAxes(orientation, params) {\n    if (orientation === \"vertical\") {\n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(0, ${params.margin.top})`)\n\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"width\", params.width)\n        .attr(\"y\", -params.margin.top)\n        .attr(\"height\", params.margin.top)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n\n        timeseriesIdAxisLayer.attr(\"transform\", `translate(${params.width - params.margin.right}, 0)`)\n  \n    } else {\n      timeseriesIdAxisLayer.attr(\"transform\", `translate(0, ${params.height - params.margin.bottom})`)\n\n      // todo: this isn't positioned correctly\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"x\", -params.margin.left)\n        .attr(\"width\", params.margin.left)\n        .attr(\"height\", params.height)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n      \n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(${params.margin.left}, 0)`)\n        \n      \n    }\n    timeseriesIdAxisLayer.call(timeIdAxis)\n    timeseriesBiasAxisLayer.call(timeBiasAxis);\n    timeseriesBiasAxisLayer.select(\".domain\").remove();\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    formatAxes(timeSvg.selectAll(\"line\"));\n    \n    timeSvg.selectAll(\"line\").classed(\"dark\", true)\n  }\n  \n  \n  function updatePath() {\n      timeseriesDataLayer.selectAll(\"g\").remove()\n      \n      if (nSamplesDrawn > 201) {\n        timeScaleId.domain([nSamplesDrawn - 200, nSamplesDrawn]);\n        // timeIdAxis = d3.axisRight(timeScaleId).tickSize(0);\n        timeseriesIdAxisLayer.call(timeIdAxis);\n        timeseriesIdAxisLayer.select(\".domain\").remove();\n      }\n      \n      timeseriesDataLayer.selectAll(\"g\")\n        .data(running_averages)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"bias-paths\")\n        .append(\"path\")\n          .attr(\"d\", d => biasLine(d.value.slice(1), d.id.slice(1)))\n          .attr(\"id\", d => d.param + \"-path\")\n\n  }\n  \n\n\nfunction clearData() {\n    sample = [];\n    sample_estimates = [];\n    running_averages = [{param: \"population\",   value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n    nSamplesDrawn = 0;\n    \n    timeScaleId.domain([0, 200]);\n    timeseriesIdAxisLayer.call(timeIdAxis);\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    sampleCircles.selectAll('circle').remove()\n    sampleEstimates.selectAll(\"path\").remove()\n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    timeseriesDataLayer.selectAll(\"path\").remove()\n  }\n  \n  function updateRunningAverages(estimates) {\n  \n      var cur_n = nSamplesDrawn\n      var prev_n = cur_n - 1\n      \n      var old = running_averages[0].value[prev_n]\n      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n\n      running_averages[0].value.push(new_pop)\n      \n      var old = running_averages[1].value[prev_n]\n      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n\n      running_averages[1].value.push(new_sam)\n      \n      var old = running_averages[2].value[prev_n]\n      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n\n      running_averages[2].value.push(new_mea)\n    \n      running_averages[0].id.push(cur_n)\n      running_averages[1].id.push(cur_n)\n      running_averages[2].id.push(cur_n)\n\n}\n\n  function updateVisibility() {\n  \n    var params = [\"mean\", \"population\", \"sample\"]\n    \n    for (var i = 0; i < 3; i++) {\n      var param = params[i]\n      var elementIds = \"#\" + param + \"-estimate, #\" + param + \"-line\"\n      \n      populationAndSampleSvg.selectAll(elementIds).classed(\"hide\", legendStatus[i].hide)\n      <!-- populationAndSampleSvg.selectAll(\"#\" + param + \"-estimate\").classed(\"hide\", legendStatus[i].hide) -->\n      timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[i].hide)\n    }\n  }\n  \n}\n\n```\n\n:::{.content-hidden}\n# Helper functions\n:::\n\n```{ojs}\n\ndodger = radius => {\n  const radius2 = radius ** 1.9;\n  const bisect = d3.bisector(d => d.x);\n  const circles = [];\n  return x => {\n    const l = bisect.left(circles, x - radius);\n    const r = bisect.right(circles, x + radius, l);\n    let y = 0;\n    for (let i = l; i < r; ++i) {\n      const { x: xi, y: yi } = circles[i];\n      const x2 = (xi - x) ** 2;\n      const y2 = (yi - y) ** 2;\n      if (radius2 > x2 + y2) {\n        y = yi + Math.sqrt(radius2 - x2) + 1e-6;\n        i = l - 1;\n        continue;\n      }\n    }\n    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });\n    <!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) -->\n    return y;\n  };\n}\n\ndodge = dodger(radius * 2 + 0.75);\n```\n\n```{ojs}\n\nfunction mean(array) {\n    return array.reduce((a, b) => a + b) / array.length;\n}\n\nfunction sample_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / (n - 1);\n}\n\nfunction population_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / n;\n}\n\nfunction get_descriptives (array) {\n    return {mean: mean(array),\n            sample_variance: sample_variance(array) - 1, \n            population_variance: population_variance(array) - 1}\n}\n\nfunction getNewData (array) {\n    \n    return {sample_estimates: getSampleEstimates(array)\n            <!-- running_averages: getRunningAverages(array) -->\n            }\n}\n\nfunction getSampleEstimates(array) {\n    return [{param: \"population\", value: population_variance(array) - 1},\n            {param: \"sample\",     value: sample_variance(array) - 1},\n            {param: \"mean\",       value: mean(array)}]\n}\n\n\nfunction formatAxes(elements) {\n  elements._groups[0].forEach((l) => {\n    if (l.__data__ === 0) {\n      l.classList = \"axis-major\";\n    } else {\n      l.classList = \"axis-minor\";\n    }\n  })\n}\n  \n```\n\n::: {.content-hidden}\n# CSS\n:::\n\n```{css}\n\n:root {\n  --population-color: pink;\n  --sample-color: dodgerblue;\n  --mean-color: purple;\n  --mu-color: purple;\n  --sigma-color: var(--link-color);\n  --population-panel-background: #c3ddff;\n  --sample-panel-background: #d3d8a8;\n  --estimates-panel-background: #eee;\n  --timeseries-panel-background: #444;\n}\n\n.g-row {\n  width: 100%;\n}\n\n/* for desktop */\n#population-container {\n  float: left; \n  width: 59.7%;\n}\n\n#timeline-container {\n  color: var(--text-color-dark);\n  float: right;\n  width: 39.8%;\n}\n\n#controls {\n  width: fit-content;\n  display: flex;\n  margin: auto;\n}\n\n#controls-container {\n  color: var(--text-color);\n  font-size: 0.8em;\n  /* float: right; */\n  width: fit-content;\n  margin-right: 1em;\n}\n\n#select-estimates {\n  width: fit-content;\n  font-size: 0.7em;\n}\n\n@media screen and (max-width: 600px) {\n  #population-container {\n    width: 100%;\n  }\n\n  #timeline-container {\n    width: 100%;\n    margin-top: 1vw;\n  }\n\n  #controls {\n    width: 100%;\n    display: block;\n  }\n  #controls-container {\n    width: fit-content;\n    margin: auto;\n  }\n\n  #select-estimate {\n    width: fit-content;\n    margin: auto;\n  }\n}\n\n.axis {\n  font-size: 0.75em;\n}\n.bias-chart-title {\n  font-size: 1.2em;\n}\n.axis-major {\n  stroke: #aaa;\n  stroke-width: 1;\n}\n.axis-minor {\n  stroke: #ddd;\n  stroke-width: 1;\n}\n\n.axis-major.dark {\n  stroke: #ccc;\n  stroke-width: 1;\n}\n.axis-minor.dark {\n  stroke: #777;\n  stroke-width: 1;\n}\n\n\n.sample {\n  stroke: white;\n}\n\n#sample-estimate, #sample-line, #sample-legend {\n  fill: var(--sample-color);\n  stroke: var(--sample-color);\n}\n\n#mean-estimate, #mean-line, #mean-legend {\n  fill:   var(--mean-color);\n  stroke: var(--mean-color);\n}\n\n#population-estimate, #population-line, #population-legend {\n  fill:   var(--population-color);\n  stroke: var(--population-color);\n}\n\n.legend-unselected {\n  fill-opacity: 0.1 !important;\n}\n\n\n.bias-paths {\n  fill: none;\n  stroke-width: 2;\n}\n\n#mean-path {\n  stroke: var(--mean-color);\n}\n#sample-path {\n  stroke: var(--sample-color);\n}\n#population-path {\n  stroke: var(--population-color);\n}\n\n.hide {\n  fill: none !important;\n  stroke: none !important;\n}\n\n\n.button {\n   font-family: Times;\n}\n.button:hover {\n  fill: red;\n  cursor: pointer;\n}\n\n\n.legend-dots:hover {\n  cursor: pointer;\n}\n\n\n.selector {\n  margin-right: 1em;\n  cursor: pointer;\n}\n.selector::after {\n  content: \"\";\n  display: inline-block;\n  width: 10px;\n  height: 10px;\n  transform: translate(50%, -10%) rotate(45deg);\n}\n\n.select-mean::after {\n  background-color: var(--mean-color);\n  border: 1px solid var(--mean-color);\n}\n.select-mean::after .unselected {\n  background-color: \"black\";\n  border: 1px solid var(--mean-color);\n}\n.select-population::after {\n  background-color: var(--population-color);\n  border: 1px solid var(--population-color);\n}\n.select-sample::after {\n  background-color: var(--sample-color);\n  border: 1px solid var(--sample-color);\n}\n\n.unselected::after {\n  opacity: 0.2;\n}\n\n.unselected:hover::after {\n  opacity: 0.5;\n}\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":false,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":false,"output-file":"unbiased-estimates.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.78","theme":{"light":"sketchy","dark":["sketchy","../theme-dark.scss"]},"header-includes":["<link rel=\"stylesheet\" media=\"screen\" href=\"https://fontlibrary.org//face/tex-gyre-adventor\" type=\"text/css\"/>\n"],"title":"(Un)Biased estimates","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}}}