[
  {
    "objectID": "games/guess-the-correlation.html",
    "href": "games/guess-the-correlation.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Guess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\ngame = {\nconst f = d3.format(\".2f\");\nconst res = d3.format(\"+.2f\");\nconst line = d3.line();\n\n\n// SVG\n\nconst w = 500;\nconst h = 350;\nconst margin = {top: 10, right: 10, bottom: 30, left: 10}\nconst radius = 4;\nvar r;\nvar p1error, p2error, winnerIndex;\nvar scores = [0,0];\n\n\nconst scoreValues = [d3.select(\"#p1-points\"), d3.select(\"#p2-points\")];\n\n\nconst svg = d3.select(\".svg-container\")\n.append(\"svg\")\n.attr(\"class\", \"svg-content\")\n.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n.attr(\"viewBox\", `0 0 ${w} ${h}`);\n\nconst axisLine = svg.append(\"path\")\n    .style(\"stroke\", \"black\").style(\"fill\", \"none\")\n    .style(\"stroke-linecap\", \"square\").style(\"stroke-width\", 2);\n    \naxisLine.attr(\"d\", line([[margin.left, margin.top],\n                        [margin.left, h - margin.bottom],\n                        [w - margin.right, h - margin.bottom]]));\n                              \n\nfunction makeChart() {\n    var data = makeData(100);\n\n    var x = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.xVal), d3.max(data, d =&gt; d.xVal)])\n        .range([margin.left + 2*radius, w - margin.right - 2*radius])\n    const y = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.yVal), d3.max(data, d =&gt; d.yVal)])\n        .range([h - margin.bottom - 2*radius, margin.top + 2*radius])\n\n    svg.selectAll(\"circle\").remove();\n    svg.selectAll(\"circle\").data(data).enter()\n        .append(\"circle\")\n        .attr(\"cx\", d =&gt; x(d.xVal))\n        .attr(\"cy\", d =&gt; y(d.yVal))\n        .attr(\"r\", radius)\n        .style(\"fill\", \"plum\")\n        .style(\"opacity\", 0)\n        .transition().delay((d,i) =&gt; i * 10).duration(0)\n            .style(\"opacity\" ,1)\n \n}\n\nfunction adjudicateGuesses() {\n    var p1guess = d3.select(\"#p1-guess\").property(\"value\");\n    var p2guess = d3.select(\"#p2-guess\").property(\"value\");\n    p1error = r - p1guess;\n    p2error = r - p2guess;\n\n    var errors = [Math.abs(p1error), Math.abs(p2error)]\n    winnerIndex = errors.indexOf(Math.min(...errors));\n    \n    showResults();\n    addPoint(winnerIndex);\n    d3.select(\"#refresh\").text(\"Next\").on(\"click\", reset);\n}\n\nfunction showResults() {\n    let winner = Array(2).fill(\"\");\n    winner[winnerIndex] = \"&lt;span style='font-size: 2em;'&gt;ðŸ‘‘&lt;/span&gt;\";\n    d3.select(\"#p1-error\").html(res(p1error * -1) + \"&lt;br&gt;\" + winner[0]);\n    d3.select(\"#p2-error\").html(res(p2error * -1) + \"&lt;br&gt;\" + winner[1]);\n    d3.select(\"#true-r\").text(\"True r = \" + f(r));\n}\n\nd3.select(\"#p1-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ðŸª™\")\nd3.select(\"#p2-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ðŸª™\")\n\nfunction addPoint(i) {\n    scores[i]++;\n    if(scores[i] &gt; 2) {\n        // declareWinner(i);\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    } else {\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    }\n}\n\nfunction declareWinner(winnerIndex) {\n    // alert(\"Player \" + (winnerIndex + 1) + \" wins!!!\")\n    // window.location.reload();\n}\n\n\nfunction reset() {\n    d3.selectAll(\".resettable\").html(\"\")\n    d3.selectAll(\".guess\").property(\"value\", \"\");\n    \n    d3.select(\"#refresh\").text(\"Guess\").on(\"click\", adjudicateGuesses);\n    makeChart();\n}\n\n// d3.selectAll(\".points-label\").each(() =&gt; this.on(\"click\", this.select()));\n\nfunction makeData(n) {\n    let arr = [];\n    let arrX = [];\n    let arrY = [];\n\n    var target_r = Math.random();\n    console.log(\"target r = \" + target_r);\n\n    for (var i = 0; i &lt; n; i++) {\n        var A = jStat.normal.inv(Math.random(), 0, 1);\n        var B = jStat.normal.inv(Math.random(), 0, 1);\n        \n        var X = A;\n        var Y = A * target_r + B * Math.pow(1 - Math.pow(target_r, 2), 0.5);\n        \n        arr.push({xVal: X, yVal: Y});\n        arrX.push(X);\n        arrY.push(Y);\n    }\n    // var stats = new Statistics(arr, {xVal: 'metric', yVal: 'metric'});\n    // r = stats.correlationCoefficient('xVal', 'yVal').correlationCoefficient;\n    console.log(arrX);\n    r = jStat.corrcoeff(arrX, arrY);\n    console.log(\"Actual r = \" + r);\n    return arr;\n}\n\nd3.select(\"#refresh\").on(\"click\", adjudicateGuesses);\nmakeChart();\n\n}"
  },
  {
    "objectID": "games/jellybeans.html",
    "href": "games/jellybeans.html",
    "title": "Psych Stats",
    "section": "",
    "text": "How many jellybeans in the jar?\n    \n    \n        \n    \n\n\n    Reveal\n\n\nimport { scaleCanvas } from '../utils/utils.js';\n\njar = {\n    let width = 500;\nlet height = 600;\nlet x0 = width / 2;\n\nlet colorPal = [\n    '#ff8aa6', // Pastel Pink\n    '#ff9b48', // Pastel Orange\n    '#fff067', // Pastel Yellow\n    '#9EE09E', // Pastel Green\n    '#71c4e6', // Pastel Blue\n    '#edceff', // Pastel Purple\n    '#fc5c30', // Pastel Brown\n    '#CAF7E2'  // Pastel Mint\n];\n\n\nfunction randomColor(colorPal) {\n    return colorPal[Math.floor(Math.random() * colorPal.length)];\n}\n\nfunction getBeanProperties(colorPal) {\n    return {\n        label: \"circle\",\n        mass: 100,\n        restitution: 0.5,\n        friction: 0.01,\n        frictionAir: 0.025,\n        frictionStatic: 0,\n        density: 1,\n        slop: 0.05,\n        sleepThreshold: 15,\n        render: { fillStyle: randomColor(colorPal) }\n    };\n}\n\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet intervalId = null;\nconst generationSpeed = 20;\n\nlet params = randomizeParams();\nlet engine = initializeWorld(\"board\", \"canvas\", width, height);\n\nComposite.add(engine.world, makeJar(params));\n\nlet generateBean = createBeanGenerator(params, x0, colorPal);\naddBeansToWorld(engine.world, generateBean, generationSpeed);\n\nengine;\n\nfunction randomizeParams() {\n    const generationSpeed = 20;\n    const jarCount = 0;\n    const jarWidth = 0.5 + Math.random() * 0.4;\n    const jarHeight = 0.5 + Math.random() * 0.2;\n    const beanRadius = 6 + Math.random() * 6;\n    const nBeans = Math.floor(4000 * (jarWidth * jarHeight) * (1 / beanRadius));\n    \n    return {nBeans, beanRadius, generationSpeed, jarWidth, jarHeight, jarCount};\n}\n\nfunction initializeWorld(element, canvas, width, height) {\n    let engine = Engine.create({\n        enableSleeping: true\n    }),\n    world = engine.world;\n    // create renderer\n    let render = Render.create({\n        element: document.getElementById(element),\n        canvas: document.getElementById(canvas),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n    \n    let runner = Runner.create();\n    Runner.run(runner, engine);\n\n    // Reset simulation on mousedown events\n    render.canvas.addEventListener(\"mousedown\", handleReset);\n\n    return {world, render};\n}\n\n\nfunction createBeanGenerator(params, x, colors) {\n    let total = params.nBeans;\n\n    return function generateBean() {\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x + (-0.5 + Math.random()) * 250, -20, params.beanRadius + Math.random() * 8, \n            getBeanProperties(colorPal)\n            );\n\n            Events.on(circle, \"sleepStart\", function () {\n                circle.isStatic = true;\n                circle.label = \"inJar\";\n            });\n\n            return circle;\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction addBeansToWorld(world, generatorFunction, speed) {\n    intervalId = setInterval(() =&gt; {\n        let bean = generatorFunction();\n        if (bean) {\n            Composite.add(world, bean);\n        } else {\n            clearInterval(intervalId);\n            intervalId = null;\n        }\n    }, speed);\n}\n\n\nconst existingBalls = () =&gt; {\n    return engine.world.bodies.filter((body) =&gt; body.label === \"circle\");\n};\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach((ball) =&gt; removeBall(engine, ball, height));\n}, 200);\n\nfunction removeBall(engine, ball, canvasHeight) {\n    let ballHeight = ball.position.y;\n    if (ballHeight &gt; canvasHeight) {\n        console.log(\"gonner\");\n        Composite.remove(engine.world, ball);\n    }\n}\n\nfunction makeJar(params) {\n\n    const thickness = 10;\n    const properties = {\n        isStatic: true,\n        render: {\n            fillStyle: \"#000000\",\n            visible: true\n        },\n        chamfer: { radius: [5, 5, 5, 5]}\n    };\n\n    const leftWall = Bodies.rectangle(width * (1 - params.jarWidth) / 2, (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const rightWall = Bodies.rectangle(width * (1 - (1 - params.jarWidth) / 2), (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const bottom = Bodies.rectangle(width * 0.5, height - 5, width * params.jarWidth, thickness, properties);\n\n    return [leftWall, rightWall, bottom];\n}\n\nconst btn = document.getElementById(\"revealBtn\");\n\nfunction countBeansInJar(world) {\n    return world.bodies.filter((body) =&gt; body.label === \"inJar\").length;\n}\n\nbtn.addEventListener(\"click\", function(event) {\n    btn.innerHTML = countBeansInJar(engine.world);\n})\n\nfunction resetRevealButton(button) {\n    button.innerHTML = \"Reveal\";\n}\n\n\nfunction reset() {\n    const newParams = randomizeParams();\n    const newEngine = initializeWorld(\"board\", \"canvas\");\n    const newJar = makeJar(newParams);\n    const newBeans = createBeanGenerator(newParams, x0, colorPal);\n\n    return { newParams, newEngine, newBeans, newJar };\n}\n\nfunction handleReset() {\n    resetRevealButton(btn);\n    // Composite.clear(engine.world);\n    \n    if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n    }\n    \n    const { newParams, newEngine, newBeans, newJar } = reset();\n    params = newParams;\n    engine = newEngine;\n    Composite.add(engine.world, newJar)\n    generateBean = newBeans;\n    addBeansToWorld(engine.world, generateBean, generationSpeed);\n}\n\nscaleCanvas(\"container\", width, height);\nwindow.addEventListener(\"resize\", () =&gt; scaleCanvas(\"container\", width, height))\n\n}"
  },
  {
    "objectID": "visualizations/quincunx.html",
    "href": "visualizations/quincunx.html",
    "title": "Quincunx",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\nboard = {\n\n\n// https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n\n\nlet width = 700;\nlet height = 600;\nlet x0 = width / 2;\n\n// ball properties\nconst ballRadius = 4;\nlet y_start = 0;\n\nlet generation_speed = 20;\nlet nBalls = 650;\nlet mass = 100;\nlet density = 1;\n\n// peg board properties\nlet rows = 20;\nlet y_peg_start = 20;\nlet pegGap = 6.5 * ballRadius;\nlet pegRadius = 0.5 * ballRadius;\nlet xGap = pegGap;\nlet yGap = 0.6 * xGap;\nlet pegAngle = 0; // Math.PI / 4;\nlet gap_between_pegs_and_buckets = 0;\n\n// funnel properties\nconst funnelTostartGap = yGap;\nconst funnelWallLength = 600;\nconst funnelAngle = Math.PI / 3;\nconst funnelOpening = 5 * ballRadius;\n\n// physics properties\nlet restitution = 0.5; // bounciness\nlet friction = 0.01;\nlet frictionAir = 0.045;\nlet frictionStatic = 0;\n\n\nlet intervalId;\n\n\nvar {Engine, Render, Runner, \n    Composite, Composites, Common, \n    MouseConstraint, Mouse, Events, \n    World, Bodies, Body} = Matter;\n\nlet engine, render, runner, world;\n\n\n\nfunction initialize() {\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n    \n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"board\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    \n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.addEventListener(\"mousedown\", reset);\n    render.canvas.position = \"absolute\";\n}\n\n\n\n// Create top funnel\nlet leftBumper_x =  x0 - (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet rightBumper_x = x0 + (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet bumper_y = y_peg_start - ((funnelWallLength * Math.sin(funnelAngle)) / 2 - funnelTostartGap);\nconsole.log(bumper_y)\n\nlet createFunnel = () =&gt; {\n\n        let leftBumper = Bodies.rectangle(leftBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(leftBumper, funnelAngle);\n\n        let rightBumper = Bodies.rectangle(rightBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution: 0.6,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(rightBumper, -funnelAngle);\n\n        Matter.Composite.add(world, [leftBumper, rightBumper]);\n}\n\n\nfunction make_balls() {\n\n    let total = nBalls;\n    clearInterval(intervalId);\n\n    intervalId = setInterval(() =&gt; {\n        let balls = [];\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x0 + (-0.5 + Math.random()) * 1, -20, ballRadius, {\n                label: \"circle\",\n                friction: 0.001,\n                restitution,\n                mass,\n                slop: 0.05,\n                density,\n                frictionAir,\n                sleepThreshold: Infinity,\n                render: {\n                    fillStyle: d3.schemeCategory10[total % 10]\n                }\n            });\n            // Matter.Events.on(circle, \"sleepStart\", () =&gt; {\n            //     Matter.Body.setStatic(circle, true);\n            // });\n            \n            Matter.Composite.add(world, circle);\n        }\n    }, generation_speed);\n}\n\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; body.label === \"circle\");\n  };\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach(function(ball) {\n      let ballHeight = ball.position.y;\n      let ballSpeed = ball.speed;\n      let minHeight = 350; // height - (floorHeight + wallHeight);\n      if (ballHeight &gt; minHeight && ballSpeed &lt; 0.02) {\n        // ball.render.opacity = 0.5;\n        Body.setStatic(ball, true);\n      }\n    });\n  }, 200);\n\n\nfunction make_pegs() {\n    const pegs = [];\n    const spacingY = ballRadius*4;\n    const spacingX = ballRadius*4;\n    var i, j, lastI;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 1; j &lt; i; j++) {\n            pegs.push(\n                // Bodies.rectangle(\n                Bodies.circle(\n                    x0 + (j * xGap - i * (xGap / 2)),\n                    y_peg_start + i * yGap,\n                    pegRadius,\n                    // ballRadius * 1.2,\n                    // 2,\n                    {\n                        angle: pegAngle,\n                        isStatic: true,\n                        friction: 0,\n                        frictionStatic: 0,\n                        render: {\n                            fillStyle: \"black\"\n                        },\n                    chamfer: {\n                        radius: [ballRadius * 0.2, ballRadius * 0.2, 0, 0]\n                    }\n        })\n            );\n        }\n        lastI = i;\n    }\n    // bins\n    for (i = 0; i &lt; rows; i++) {\n        Matter.Composite.add(\n            world,\n            Bodies.rectangle(\n\n                x0 - (rows - 1) * (xGap / 2) + i * xGap,\n                y_peg_start + rows * yGap + gap_between_pegs_and_buckets + (height-(y_peg_start + rows * yGap))/2,\n                4,\n                (height-(y_peg_start + rows * yGap)),\n                {\n                    isStatic: true,\n                    density: 1000,\n                    mass: 1000,\n                    slop: 0,\n                    render: {\n                        fillStyle: \"#000000\",\n                        visible: true\n                    },\n                    chamfer: {\n                        radius: [ballRadius * 0.4, ballRadius * 0.4, 0, 0]\n                    }\n                }\n            )\n        );\n    }\n    // ground\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(400, height, 1000, 10, {\n            isStatic: true,\n            render: {\n                fillStyle: \"#000000\",\n                visible: true\n            }\n        })\n    );\n\n\n    World.add(world, pegs);\n}\n\nconst canvas = d3.select(\"#overlay\")\n.append(\"canvas\")\n.attr(\"id\", \"overlay\")\n.attr(\"position\", \"absolute\")\n.attr(\"width\", width)\n.attr(\"height\", height);\n\nconst ctx = canvas.node().getContext('2d');\ncanvas.on(\"mousedown\", reset);\n\nfunction drawNormalDistribution() {\n\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(0, height - 5);\n\n    let yMultiplier = (height-(y_peg_start + rows * yGap));\n    var values = jStat(-4, 4, 210)[0]\n\n\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, 0, 0.8);\n        ctx.lineTo((value + 4)*(width/8), height-(density*1.95*yMultiplier) - 5);\n        ctx.stroke();\n    }\n}\n\nfunction reset() {\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    console.log('reset clicked');\n    \n    initialize();\n    scaleCanvas();\n    make_pegs();\n    make_balls();\n    createFunnel();\n    drawNormalDistribution();\n}\n\n\nfunction scaleCanvas() {\n    \n    var containerWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = containerWidth / (width * 1);\n    d3.select(\"canvas\")\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n    canvas\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    // d3.select(\"#flex-container\")\n    //     .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    // d3.select(\"#container\")\n    //     .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n//\n\ninitialize();\nscaleCanvas();\nmake_pegs();\nmake_balls();\ncreateFunnel();\ndrawNormalDistribution();\n  \n}"
  },
  {
    "objectID": "visualizations/mean-balance-beam.html",
    "href": "visualizations/mean-balance-beam.html",
    "title": "Central Tendency",
    "section": "",
    "text": "Central Tendency: The Mean as the Balance Point\n\n\nShow/hide deviations\n\n\nShow/hide squared deviations\n\n\n\n\n\n\nwidth = 600\nheight = 600\nn_boxes = 5\nscale_width = 11\nbox_size = width / scale_width\nbeam_height = box_size / 4\nradius = box_size\n\n// multiply the deviations lined up at the bottom to fit on the screen\nmultiplier = 6/n_boxes\n\nbox_data_ = make_box_data(n_boxes)\n\n\nchart = {\n\n  let deviations_hidden = false;\n  let squared_deviations_hidden = false;\n  \n  &lt;!-- const controls = d3.select(\"#controls\") --&gt;\n  &lt;!-- const button = controls --&gt;\n  &lt;!--     .append(\"input\") --&gt;\n  &lt;!--     .attr(\"type\", \"button\") --&gt;\n  &lt;!--     .attr(\"name\", \"showDevs\") --&gt;\n  &lt;!--     .attr(\"value\", \"Toggle\") --&gt;\n  &lt;!--     .attr(\"onclick\", noDevs) --&gt;\n\n  function round_position(x) {\n    let interval = width / scale_width\n    return Math.round(x / interval)*interval\n  }\n\n  function rounded_position_index(x) {\n    let interval = width / scale_width\n    let x0 = Math.round(x / interval)*interval\n    return Math.round(x0/(width/scale_width))  \n  }\n  \n  let positions = d3.range(scale_width).map(i =&gt; (0))\n\n  function stack_boxes() {\n    for (let i = 0; i &lt; box_data.length; i++) {\n      box_data[i].level = positions[box_data[i].x0]\n      positions[box_data[i].x0]++\n    }\n  }\n\n  let starting_boxes = [1, 2, 6, 6, 10]\n  \n  // let box_data = d3.range(n_boxes).map(i =&gt; ({\n  //     // x: (Math.random() * (width - box_size * 2) + box_size),\n  //     x0: Math.floor(Math.random() *   scale_width),\n  //     y: -box_size, // height/2 - beam_height/2 - radius,\n  //     color: d3.schemeCategory10[i % 10],\n  //     level: 0\n  //     }))\n      \n  let box_data = box_data_;\n\n  for (let i = 0; i &lt; box_data.length; i++) box_data[i].x = box_data[i].x0 * box_size\n  \n  \n  let mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n  let pivot = mean\n  \n  box_data = box_data.sort(function(a, b) { return Math.abs(a.x - pivot) - Math.abs(b.x - pivot); })\n  for (let i = 0; i &lt; box_data.length; i++) {\n    box_data[i].id = i\n  }\n    \n    stack_boxes()\n    \n    \n  const svg = d3.select(\"#chart\").append(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"stroke-width\", 2)\n\n  const x_ = d3.scaleLinear()\n    .range([0, width])\n    .domain([0, 10])\n    \n  // draw the ground\n  svg.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\", 50)\n    .attr(\"fill\", \"#f0f0f0\")\n    .attr(\"stroke\", \"none\")\n    .attr(\"transform\", `translate(0, ${height - 51})`)\n\n  const beam_and_boxes = svg.append(\"g\")\n    .attr(\"transform\", `translate(0, ${height - 50 - radius - beam_height})`)\n  \n  // draw the beam\n  beam_and_boxes.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\",  beam_height)\n    .attr(\"rx\", 3)\n    .attr(\"fill\", \"black\")\n    // .attr(\"transform\", `translate(0, ${height/2 - beam_height / 2})`)\n\n  const boxes = beam_and_boxes.append(\"g\")\n  const deviations = beam_and_boxes.append(\"g\")\n  const deviations_vertical = deviations.append(\"g\")\n  const deviations_horizontal = deviations.append(\"g\")\n  const deviations_sum = svg.append(\"g\").attr(\"transform\", `translate(0, ${height - 25})`)\n  const deviations_sum_negative = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, -10)`)\n  const deviations_sum_positive = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, 10)`)\n  \n  // draw the boxes\n  boxes.selectAll(\"rect\")\n    .data(box_data)\n    .join(\"rect\")\n      .attr(\"x\", d =&gt; d.x)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n      .attr(\"width\", box_size)\n      .attr(\"height\", box_size)\n      .attr(\"rx\", 1)\n      .attr(\"fill\", d =&gt; d.color)\n      .attr(\"stroke\", null)\n      .call(d3.drag().on(\"start\", start_dragging_box)\n                     .on(\"drag\", dragging_box)\n                     .on(\"end\", stop_dragging_box));\n  \n  // draw a circle at the true mean point\n  const circle = beam_and_boxes.append(\"circle\")\n    .attr(\"cx\", mean)\n    .attr(\"cy\", beam_height/2)\n    .attr(\"r\", 5)\n    .attr(\"fill\", \"#777777\")\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n  // draw a triangle at the pivot point\n  const triangle = svg.append(\"polygon\")\n    .attr(\"points\", [[0, -radius/2], [radius/2, radius/2], [-radius/2, radius/2]])\n    .attr(\"fill\", \"red\")\n    .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n    \n  draw_deviations()\n  \n\n  function start_dragging_mean(event, d) {triangle.attr(\"fill\", \"dodgerblue\")}\n  \n  function stop_dragging_mean(event, d) {triangle.attr(\"fill\", \"red\")}\n  \n  function dragging_mean(event, d) {\n      pivot = event.x\n      tip_scale()\n  }\n  \n  function tip_scale() {\n  \n    let angle = Math.abs((mean - pivot)*0.5);\n    let hypotenuse, direction;\n    \n    if (pivot &lt; mean) {\n      hypotenuse = width - pivot;\n      direction = 1;\n    } else {\n      hypotenuse = pivot;\n      direction = -1;\n    }\n    \n    let tri_angle = 90 - (Math.acos(radius / hypotenuse) * 180/Math.PI)\n    angle = direction * (Math.min(angle, tri_angle))\n    \n      triangle\n        .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n      beam_and_boxes\n        .attr(\"transform\", `translate(0, ${height-50-radius-beam_height}) rotate(${angle}, ${pivot}, ${0})`)\n      draw_deviations()\n  }\n\n  \n  function start_dragging_box(event, d) {\n    d3.select(this).raise().attr(\"stroke\", \"black\")\n    // console.log(\"x:\" + d.x + \" x0:\" + d.x0 + \" level:\" + d.level)\n  }\n\n  function dragging_box(event, d) {\n    box_data[d.id].x = event.x\n    // box_data[d.id].x0 = round_position(box_data[d.id].x) + box_size/2\n    \n    let current_position = box_data[d.id].x0\n    let current_level = box_data[d.id].level\n    let new_position = rounded_position_index(event.x)\n    \n    if(new_position != current_position) {\n      console.log(\"moved! from \" + current_position + \" to \" + new_position)\n      \n      // update the box's position\n      box_data[d.id].x0 = new_position\n      \n      // now this box should go on top of the stack for new_position\n      box_data[d.id].level = positions[new_position]\n      \n      // and update the total number of boxes in that position\n      positions[new_position]++\n      \n      // for the old position, reduce the number of boxes by one, and\n      // bump down any boxes that had a higher level that this box\n      positions[current_position]--\n      for (let i = 0; i &lt; box_data.length; i++) {\n        if (d.id==i) continue\n        if (box_data[i].x0==current_position && box_data[i].level &gt; current_level) {\n            box_data[i].level--\n            console.log(\"movin on down\")\n        } \n      }\n    }\n    \n    tip_scale()\n    // draw_deviations()\n  }\n\n  function stop_dragging_box(event, d) {\n    d3.select(this).attr(\"stroke\", null)\n  }\n  \n  \n\n\n  function draw_deviations() {\n    \n    mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n    \n    boxes.selectAll(\"rect\")\n      .attr(\"x\", d =&gt; d.x0 * box_size)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n    \n    circle.attr(\"cx\", mean)\n    \n    // calculate deviations\n    for (let i = 0; i &lt; box_data.length; i++) box_data[i].dev = (box_data[i].x0*box_size + (box_size/2)) - pivot\n    \n    let deviations_negative = box_data.filter(function(d){ return d.dev &lt; 0})\n    for (let i = 0; i &lt; deviations_negative.length; i++) {\n      if (i==0) deviations_negative[i].dev_start = 0\n      else deviations_negative[i].dev_start = deviations_negative[i-1].dev_end\n      deviations_negative[i].dev_end = deviations_negative[i].dev_start + Math.abs(deviations_negative[i].dev)\n    }\n    \n    let deviations_positive = box_data.filter(function(d){ return d.dev &gt; 0})\n    for (let i = 0; i &lt; deviations_positive.length; i++) {\n      if (i==0) deviations_positive[i].dev_start = 0\n      else deviations_positive[i].dev_start = deviations_positive[i-1].dev_end\n      deviations_positive[i].dev_end = deviations_positive[i].dev_start + Math.abs(deviations_positive[i].dev)\n    }\n    \n    deviations_vertical.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"y1\", d =&gt; d.y - d.level * box_size)\n        .attr(\"y2\", d =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        \n    deviations_vertical\n      .append(\"line\")\n      .attr(\"x1\", pivot).attr(\"x2\", pivot)\n      .attr(\"y1\", 0).attr(\"y2\", -height)\n      .attr(\"stroke\", \"red\").attr(\"stroke-dasharray\", [10, 10])\n\n    deviations_horizontal.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", pivot)\n        .attr(\"y1\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"y2\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 3)\n        \n    if (!squared_deviations_hidden) update_squared_deviations();\n    \n\n    deviations_sum_negative.selectAll(\"line\")\n      .data(deviations_negative)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n        \n    deviations_sum_positive.selectAll(\"line\")\n      .data(deviations_positive)\n      .join(\"line\")\n      .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n  };\n  \n  \n  function update_squared_deviations() {\n      deviations_horizontal.selectAll(\"rect\")\n      .data(box_data)\n      .join(\"rect\")\n        .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n        .attr(\"width\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", function(d){if(squared_deviations_hidden){return 0} else{return Math.abs(d.dev)}})\n        .attr(\"fill\", d =&gt; d.color)\n        .attr(\"opacity\", 0.5)\n        .attr(\"stroke\", \"none\")\n  }\n  \n  \n\n  function noDevs() {\n    deviations_hidden = !deviations_hidden\n    deviations.attr(\"opacity\", Number(!deviations_hidden))\n  }\n  \n  function noDevsSq() {\n    squared_deviations_hidden = !squared_deviations_hidden\n  \n    if (squared_deviations_hidden) {\n      deviations_horizontal\n        .selectAll(\"rect\")\n        .data(box_data)\n        .transition().duration(1000)\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"height\", 0)\n    } else {\n        deviations_horizontal\n          .selectAll(\"rect\")\n          .data(box_data)\n          .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n          .attr(\"width\", d =&gt; Math.abs(d.dev))\n          .transition().duration(1000)\n          .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n          .attr(\"height\", d =&gt; Math.abs(d.dev))\n    }\n    \n  }\n\n  noDevs()\n  noDevsSq()\n  d3.select(\"#showDevs\").on(\"click\", noDevs)\n  d3.select(\"#showDevsSq\").on(\"click\", noDevsSq)\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction make_box_data(n) {\n    return d3.range(n).map(i =&gt; ({\n      // x: (Math.random() * (width - box_size * 2) + box_size),\n      x0: Math.floor(Math.random() *   scale_width),\n      y: -box_size, // height/2 - beam_height/2 - radius,\n      color: d3.schemeCategory10[i % 10],\n      level: 0\n      }))\n  }"
  },
  {
    "objectID": "visualizations/sampling/sampling-backend.html",
    "href": "visualizations/sampling/sampling-backend.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsampling = {\n    // https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n// https://onlinestatbook.com/stat_sim/sampling_dist/\n\nlet width = 700;\nlet height = 700;\nlet x0 = width / 2;\n\nlet populationHeight = height * 0.4;\nlet sampleHeight = 50;\nlet samplingDistributionHeight = height - (populationHeight + sampleHeight);\n\n// ball properties\nconst ballRadius = 5;\nlet generationSpeed = 1;\nlet nBalls = 500;\n\nlet sampleSize = d3.select(\"#sampleSize\").property(\"value\");\nlet distributionFunction = d3.select(\"#dist\").value\n\nlet balls = [], means = [], currentMean;\n\n\n\nlet showSleeping = false;\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet engine, render, runner, world;\n\nvar pos, mouseX, mouseY;\n\nlet populationMean = x0;\nlet populationSd = width * 0.12;\nlet updatePopulationInterval;\nlet creationIntervalId;\n\nlet y = d3.scaleLinear()\n    .domain([0, jStat.normal.pdf(x0, x0, 80 / Math.sqrt(sampleSize))])\n    .range([samplingDistributionHeight, 0])\n\n\n\n    \n// ========================================================================== //\n// Buttons and listeners\n// ========================================================================== //\n\nd3.select( \"#singleSampleBtn\").on(\"click\", logBalls)\nd3.select(\"#startSamplingBtn\").on(\"click\", takeSamples)\nd3.select( \"#stopSamplingBtn\").on(\"click\", stopSamples)\nd3.select(  \"#samples1000Btn\").on(\"click\", e =&gt; takeNSamples(1000))\nd3.select( \"#samples10000Btn\").on(\"click\", e =&gt; takeNSamples(10000))\nd3.select( \"#samples100000Btn\").on(\"click\", e =&gt; takeNSamples(100000))\nd3.select( \"#clearSamplesBtn\").on(\"click\", resetMeans)\n\nconst sampleSizeInput = d3.select(\"#sampleSize\")\n    .on(\"change\", function () {\n        resetMeans();\n        sampleSize = d3.select(\"#sampleSize\").property(\"value\");\n        updateSamplingDistributionParams();\n        updateSamplingDistributionDescriptives(true);\n        updateSampleDescriptives();\n        drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    });\n\nconst distributionInput = d3.select(\"#dist\")\n    .on(\"change\", function () {\n        reset();\n    });\n\nfunction scaleCanvas() {\n    console.log(document.getElementById(\"quarto-document-content\").offsetWidth)\n    // var availableWidth = window.visualViewport.width;\n    // var availableWidth = d3.select(\"#container\").attr(\"width\")\n\n    var availableWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = Math.min(1, availableWidth / (width * 1));\n    d3.select(\"#container\")\n        .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    d3.select(\"#flex-container\")\n        .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    d3.select(\"#container\")\n        .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n\n// ========================================================================== //\n// Physics\n// ========================================================================== //\n\n// physics properties\nconst populationDotParams = {\n    label: \"circle\",\n    restitution: 0,\n    friction: 0.1,\n    frictionAir: 0.045,\n    frictionStatic: 1,\n    slop: 0,\n    mass: 0.1,\n    density: 100,\n    sleepThreshold: 15,\n    collisionFilter: { group: 1 }\n}\n\nfunction populationDotColor() {\n    return d3.schemeCategory10[Math.floor(Math.random() * 10)]\n}\n\n// let restitution = 0; // bounciness\nlet friction = Infinity;\n// let frictionAir = 0.05;\nlet frictionStatic = Infinity;\n// let slop = 0;\n// let mass = 0.1;\n// let density = 100;\n\n\n\n\nfunction initialize() {\n\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n\n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"container\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: showSleeping\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    engine.positionIterations = 6;\n    engine.velocityIterations = 8;\n\n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.position = \"absolute\";\n\n    drawDots();\n}\n\nfunction drawDots() {\n    var isDrawing = false;\n    function startDrawing(x, y) {\n        isDrawing = true;\n        resetMeans();\n        Composite.add(world, makePopulationDot(x, y, ballRadius));\n        creationIntervalId = setInterval(function () {\n            if (pos.y &gt; (populationHeight - 5)) {\n                stopDrawing;\n                return null;\n            }\n            Composite.add(world, makePopulationDot(pos.x, pos.y, ballRadius));\n        }, generationSpeed);\n        updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n    }\n    function stopDrawing() {\n        isDrawing = false;\n        clearInterval(creationIntervalId);\n    }\n\n    // Add an event listener to the canvas to detect mouse clicks\n    render.canvas.addEventListener('mousedown', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    render.canvas.addEventListener('touchstart', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    // Update the mouse position if it's moved\n    render.canvas.addEventListener('mousemove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n    render.canvas.addEventListener('touchmove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n\n\n    // Stop generating balls when the mouse button is released\n    render.canvas.addEventListener('mouseup', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('mouseout', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('touchend', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n}\n\nconst getRelativeMousePosition = (event, target) =&gt; {\n    const bounds = target.getBoundingClientRect();\n    const scaleX = target.width / bounds.width;\n    const scaleY = target.height / bounds.height;\n    const clientX = event.clientX || event.touches[0].clientX;\n    const clientY = event.clientY || event.touches[0].clientY;\n    return {\n        x: (clientX - bounds.left) * scaleX,\n        y: (clientY - bounds.top) * scaleY,\n    };\n};\n\n// ========================================================================== //\n//      Make the world\nvar panelRadius = [10, 10, 10, 10];\nfunction makeGround() {\n    // background of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight * 0.5, width, populationHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"dodgerblue\", opacity: 0.3 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + 4, width * 2, 10, {\n            isStatic: true,\n            density: Infinity,\n            collisionFilter: { group: 1, category: 1, mask: 0 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight * 0.5, width, sampleHeight - 10, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d3d8a9\" },\n            chamfer: { radius: panelRadius }\n        })\n    );\n    // floor of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight, width, 10, {\n            friction, frictionStatic,\n            density: Infinity, mass: Infinity,\n            isStatic: true,\n            collisionFilter: { group: 2, category: 4, mask: 2 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height - samplingDistributionHeight * 0.5, width, samplingDistributionHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d49fd4\", opacity: 0.7 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height + 9, width, 20, {\n            friction, frictionStatic,\n            isStatic: true,\n            collisionFilter: { group: 3, category: 8, mask: 6 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n}\n\n\n\n// ========================================================================== //\n//      Generate population\n\nlet intervalId;\n\nfunction makePopulation(distributionFunction) {\n\n    clearInterval(intervalId);\n    let total = nBalls;\n\n    if (distributionFunction == \"custom\") { total = 0 };\n\n    intervalId = setInterval(() =&gt; {\n\n        if (total-- &gt; 0) {\n\n            let x = distributionFunction();\n            let y = -500 + Math.random() * 500;\n\n            let circle = makePopulationDot(x, y, ballRadius);\n            Matter.Composite.add(world, circle);\n\n        }\n    }, generationSpeed);\n}\n\n\nfunction makePopulationDot(x, y, radius) {\n    \n    let dot = Matter.Bodies.circle(x, y, radius, populationDotParams);\n    dot.render.fillStyle = populationDotColor();\n    \n    Events.on(dot, \"sleepStart\", function () {\n        dot.isStatic = true;\n        balls.push(dot);\n        updateDescriptives();\n    });\n\n    return dot;\n}\n\n\n// ========================================================================== //\n//      Update population\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"circle\" && !body.isStatic));\n};\n\nlet populationInterval;\n\nfunction checkStatic(body) {\n    return body.isStatic;\n}\n\nlet popChecks = 0;\nfunction updatePopulation() {\n    console.log(\"checking pop\");\n    popChecks++;\n    let allBalls = world.bodies.filter((body) =&gt; (body.label === \"circle\"));\n\n    // compute the population mean\n    let total = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        total += allBalls[i].position.x;\n    }\n    populationMean = total / allBalls.length;\n\n    let ss = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        ss += Math.pow(allBalls[i].position.x - populationMean, 2);\n    }\n    populationSd = Math.sqrt(ss / allBalls.length);\n    // console.log(populationSd);\n    drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    updateSamplingDistributionParams();\n    if (allBalls.every(checkStatic) || popChecks &gt; 1000) {\n        popChecks = 0;\n        clearInterval(updatePopulationInterval);\n    }\n}\n\nlet existingMeans = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"mean\"));\n};\n\nconst makeStaticMeanInterval = setInterval(() =&gt; {\n    existingMeans().forEach(function (mean) {\n        let meanHeight = mean.position.y;\n        let meanSpeed = mean.speed;\n        // let minHeight = 10; // height - (floorHeight + wallHeight);\n        let minHeight = populationHeight + sampleHeight + 50;\n        if (meanHeight &gt; minHeight && meanSpeed &lt; 0.5) {\n            // mean.render.fillStyle = \"black\";\n            mean.isStatic = true;\n            // mean.density = Infinity;\n            //balls.push({ position: ball.position, fill: ball.render.fillStyle });\n            //Body.setStatic(mean, true);\n        }\n    });\n}, 10);\n\n\n// ========================================================================== //\n// Sampling\nfunction logBalls() {\n    let s = sample(sampleSize);\n    // console.log(balls);\n    // console.log(s);\n\n    d3.select(\"#mean\").html(currentMean);\n}\n\n\n// ========================================================================== //\n//      Single sample\n\nfunction sample(sampleSize, fast = false) {\n    let arr = [];\n    let sampleCircles = [];\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"sample\")));\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"meanGhost\")));\n\n    for (let i = 0; i &lt; sampleSize; i++) {\n        let index = Math.floor(Math.random() * balls.length);\n        let pos = balls[index].position;\n        arr.push(pos.x);\n\n        let yPos = pos.y;\n\n        if (fast) yPos = populationHeight + sampleHeight - ballRadius;\n\n\n        sampleCircles.push(Bodies.circle(pos.x, yPos, ballRadius, {\n            label: \"sample\",\n            restitution: 0.4, friction, frictionStatic,\n            density: 1, mass: 1, slop: 0.05,\n            sleepThreshold: Infinity,\n            collisionFilter: { group: -1, category: 2, mask: 4 },\n            render: { fillStyle: balls[index].render.fillStyle }\n        }));\n    };\n\n    currentMean = mean(arr);\n    means.push(currentMean);\n\n\n    let binnedMean = Math.round(currentMean / (ballRadius * 2)) * (ballRadius * 2);\n\n    const meanSquareBack = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2, ballRadius * 2, ballRadius * 2, {\n        label: \"meanGhost\",\n        isStatic: true,\n        isSensor: true,\n        render: { fillStyle: \"white\" }\n    });\n    Composite.add(world, meanSquareBack);\n\n    const meanSquare = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2 - 1, ballRadius * 2, ballRadius * 2, {\n        label: \"mean\",\n        restitution: 0,\n        friction,\n        frictionStatic,\n        frictionAir: 0.03,\n        density: Infinity,\n        mass: 0.000000000000001,\n        slop: 0,\n        collisionFilter: { group: 4, category: 6, mask: 8 },\n        render: { fillStyle: \"#d3d8a9\", strokeStyle: \"black\", lineWidth: 1 }\n    });\n    Composite.add(world, meanSquare);\n\n    Composite.add(world, sampleCircles);\n\n    updateSampleDescriptives(sampleSize, f(currentMean), f(sd(arr, false)), false);\n    updateSamplingDistributionDescriptives();\n}\n\nlet sampleInterval;\n\nfunction takeSamples() {\n    sampleInterval = setInterval(() =&gt; {\n        sample(sampleSize, true);\n    }, 100);\n}\n\n\nfunction stopSamples() {\n    clearInterval(sampleInterval);\n}\n\n\n// ========================================================================== //\n//      Multiple samples\nlet meanCounts = {};\nfunction takeNSamples(nSamples) {\n\n\n    for (let i = 0; i &lt; nSamples; i++) {\n\n        let thisSample = [];\n\n        for (let j = 0; j &lt; sampleSize; j++) {\n            let index = Math.floor(Math.random() * balls.length);\n            thisSample.push(balls[index].position.x);\n        }\n\n        let thisSampleMean = mean(thisSample);\n        means.push(thisSampleMean);\n\n        let thisSampleMeanBinned = bin(thisSampleMean, ballRadius);\n\n        if (meanCounts.hasOwnProperty(thisSampleMeanBinned)) {\n            meanCounts[thisSampleMeanBinned]++;\n        } else {\n            meanCounts[thisSampleMeanBinned] = 1;\n        }\n    }\n\n    updateSamplingDistributionDescriptives();\n    let meanProportions = transformCountsToProportions(meanCounts, means.length);\n    drawProportions(meanProportions);\n}\n\n\n// ========================================================================== //\n//      Reset\nfunction reset() {\n\n    balls = [];\n    means = [];\n\n    clearInterval(updatePopulationInterval);\n    clearInterval(intervalId);\n    histogram.selectAll(\"rect\").remove();\n    curve.selectAll(\"path\").remove();\n\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    // console.log('reset clicked');\n\n    initialize();\n    makeGround();\n    makePopulation(eval(d3.select(\"#dist\").node().value));\n    updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n\n    updateSampleDescriptives(0, 0, 0, true);\n    updateSamplingDistributionDescriptives(true);\n}\n\n\nfunction resetMeans() {\n    means = [];\n    meanCounts = {};\n    histogram.selectAll(\"rect\").remove();\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\" || body.label === \"sample\" || body.label === \"meanGhost\")));\n    d3.select(\"#samplingDistStats\").classed(\"hide\", true);\n    d3.select(\"#sampleStats\").classed(\"hide\", true);\n}\n\n\n\n\n// ========================================================================== //\n// Overlay and panel labels\n// ========================================================================== //\n\n// ==================\n//      Labels\nvar labels = [{ label: \"Population\", top: 0 },\n{ label: \"Sample\", top: populationHeight + 5 },\n{ label: \"Distribution of sample means\", top: populationHeight + sampleHeight }];\n\nd3.select(\"#container\").selectAll(\"span\")\n    .data(labels).enter().append(\"span\")\n    .classed(\"panel-label\", true)\n    .classed(\"labels\", true)\n    .style(\"position\", \"absolute\").style(\"left\", \"0.1em\")\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .text(d =&gt; d.label)\n\nvar labels2 = [{\n    label: `&lt;i&gt;N&lt;/i&gt; = &lt;span id=\"n\"&gt;0&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;Î¼&lt;/i&gt; = &lt;span id=\"mu\"&gt;&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;Ïƒ&lt;/i&gt; = &lt;span id=\"sigma\"&gt;&lt;/span&gt;`,\n    top: 0\n},\n{\n    label: `&lt;div id=\"sampleStats\"&gt;&lt;i&gt;n&lt;/i&gt; = &lt;span id=\"sampleN\"&gt;&lt;/span&gt;;\n              &lt;i&gt;M&lt;/i&gt; = &lt;span id=\"sampleM\"&gt;&lt;/span&gt;;\n              &lt;i&gt;SD&lt;/i&gt; = &lt;span id=\"sampleSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + 5\n},\n{\n    label: `&lt;div id=\"samplingDistParams\"&gt;Predicted:&lt;br&gt;\n              &lt;i&gt;Î¼&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;Î¼&lt;/i&gt; = &lt;span id=\"muM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Ïƒ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;Ïƒ&lt;/i&gt;/âˆš&lt;i&gt;n&lt;/i&gt;  = &lt;span id=\"sigmaM\"&gt;&lt;/span&gt;&lt;/div&gt;\n              &lt;div id=\"samplingDistStats\"&gt;Observed:&lt;br&gt;&lt;i&gt;N&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distN\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Î¼&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Ïƒ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + sampleHeight\n}];\n\nconst overlay2 = d3.select(\"#container\").append(\"div\")\n    .style(\"position\", \"absolute\")\n    .style(\"z-index\", 13)\n    .style(\"text-align\", \"right\")\n\noverlay2.selectAll(\"span\")\n    .data(labels2).enter().append(\"span\")\n    .style(\"width\", width - 5 + \"px\")\n    .style(\"z-index\", 0)\n    // .style(\"margin-right\", \"1em\")\n    .classed(\"panel-label\", true)\n    .classed(\"numbers\", true)\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .html(d =&gt; d.label)\n\nconst f = d3.format(\".1f\");\nconst fComma = d3.format(\",\");\n\nfunction updateDescriptives() {\n    d3.select(\"#n\").text(fComma(balls.length))\n    d3.select(\"#mu\").text(f(populationMean))\n    d3.select(\"#sigma\").text(f(populationSd))\n}\n\nfunction updateSampleDescriptives(n, m, sd, hidden = true) {\n    d3.select(\"#sampleStats\").classed(\"hide\", hidden)\n    d3.select(\"#sampleN\").text(n)\n    d3.select(\"#sampleM\").text(f(m))\n    d3.select(\"#sampleSd\").text(f(sd));\n}\nfunction updateSamplingDistributionParams() {\n    d3.select(\"#muM\").text(f(populationMean))\n    d3.select(\"#sigmaM\").text(f(populationSd / Math.sqrt(sampleSize)));\n}\n\nfunction updateSamplingDistributionDescriptives(hidden = false) {\n    d3.select(\"#samplingDistStats\").classed(\"hide\", hidden)\n    d3.select(\"#distN\").text(fComma(means.length));\n    d3.select(\"#distM\").text(f(mean(means)));\n    d3.select(\"#distSd\").text(f(sd(means)));\n}\n\n\n\n// ========================================================================== //\n//      Normal distribution\n\n// create svg overlay\nconst svg = d3.select(\"#container\")\n    .append(\"svg\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .style(\"transform\", `translateY(${height - samplingDistributionHeight}px)`)\n    // .append(\"div\")\n    .style(\"z-index\", 0)\n    .attr(\"id\", \"samplingDistCanvas\")\n    // .style(\"left\", 0)\n    .attr(\"height\", samplingDistributionHeight)\n    .attr(\"width\", width);\n\nconst histogram = svg.append(\"g\");\nconst curve = svg.append(\"g\");\n\n\nfunction drawNormalDistribution(mean, sd) {\n\n    // remove the old path\n    curve.selectAll(\"path\").remove();\n\n    // reset the y-axis according to new population parameters\n    y.domain([0, 1.1 * jStat.normal.pdf(populationMean, populationMean, populationSd / Math.sqrt(sampleSize))]);\n\n    var values = jStat(0, width, 210)[0];\n\n    let data = [];\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, mean, sd);\n        data.push({ value: value, density: density });\n    }\n\n    const line = d3.line()\n        .x(d =&gt; d.value)\n        .y(d =&gt; y(d.density));\n\n    // draw the new path\n    curve.append(\"path\")\n        .attr(\"d\", line(data))\n        .attr(\"stroke\", \"grey\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        .attr(\"stroke-width\", 2)\n        .attr(\"fill\", \"none\");\n}\n\n// ========================================================================== //\n//      Histogram\nfunction drawProportions(proportions) {\n\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\")));\n    histogram.selectAll(\"rect\").remove();\n\n    Object.entries(proportions).forEach(([key, value]) =&gt; {\n        histogram.append(\"rect\")\n            .attr(\"fill\", \"#d3d8a9\")\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5)\n            .attr(\"x\", key - ballRadius * 0.5)\n            // .attr(\"y\", 0)\n            .attr(\"y\", y(value * 0.2))\n            .attr(\"width\", 5)\n            // .attr(\"height\", samplingDistributionHeight * 2)\n            .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n        // .transition().duration(value * 15000)\n        //     .attr(\"y\", y(value * 0.2))\n        //     .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n    });\n}\n\n\n\n\n// ========================================================================== //\n// Helper functions\n// ========================================================================== //\n\n\n// ========================================================================== //\n//      Distribution functions\n\n// functions to make skewed distribution\n// see https://spin.atomicobject.com/2019/09/30/skew-normal-prng-javascript/\nconst randomNormals = (rng) =&gt; {\n    let u1 = 0, u2 = 0;\n    //Convert [0,1) to (0,1)\n    while (u1 === 0) u1 = rng();\n    while (u2 === 0) u2 = rng();\n    const R = Math.sqrt(-2.0 * Math.log(u1));\n    const Î˜ = 2.0 * Math.PI * u2;\n    return [R * Math.cos(Î˜), R * Math.sin(Î˜)];\n};\n\n\nconst randomSkewNormal = (rng, Î¾ = 0, Ï‰ = 1, Î± = 0) =&gt; {\n    const [u0, v] = randomNormals(rng);\n    if (Î± === 0) {\n        return Î¾ + Ï‰ * u0;\n    }\n    const ð›¿ = Î± / Math.sqrt(1 + Î± * Î±);\n    const u1 = ð›¿ * u0 + Math.sqrt(1 - ð›¿ * ð›¿) * v;\n    const z = u0 &gt;= 0 ? u1 : -u1;\n    return Î¾ + Ï‰ * z;\n};\n\n// functions to generate single observations from those distributions\nfunction normal() {\n    return randomSkewNormal(Math.random, x0, width * 0.12, 0);\n}\nfunction negative() {\n    return randomSkewNormal(Math.random, width * 0.9, width * 0.25, -10);\n}\nfunction positive() {\n    return randomSkewNormal(Math.random, width * 0.1, width * 0.25, 10);\n}\nfunction uniform() {\n    return ((width * 0.05) + width * 0.9 * Math.random());\n}\n\n// ============================================================\n//      Other low-level helper functions\n\nfunction sleep(milliseconds) {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date &lt; milliseconds);\n}\n\n\nfunction bin(x, binWidth) {\n    return Math.round(x / binWidth) * binWidth;\n}\n\n\nArray.prototype.max = function () {\n    return Math.max.apply(null, this);\n};\n\n\nfunction transformCountsToProportions(counts, totalCount) {\n    // let totalCount = Object.values(counts).reduce((a, b) =&gt; a + b, 0);\n    let proportions = {};\n\n    for (let mean in counts) {\n        if (counts.hasOwnProperty(mean)) {\n            proportions[mean] = counts[mean] / totalCount;\n        }\n    }\n\n    return proportions;\n}\n\nfunction mean(arr) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    return total / n;\n}\n\nfunction sd(arr, population = true) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    let mean = total / n;\n\n    let ss = 0;\n\n    for (let i = 0; i &lt; arr.length; i++) {\n        ss += Math.pow(arr[i] - mean, 2);\n    }\n\n    let denominator = arr.length;\n\n    if (!population) { denominator--; }\n\n    return Math.sqrt(ss / denominator);\n}\n\n\nscaleCanvas();\ninitialize();\nreset();\n}"
  },
  {
    "objectID": "visualizations/dice/dice.html",
    "href": "visualizations/dice/dice.html",
    "title": "Dice Roller",
    "section": "",
    "text": "Throw the dice\n\n\n+100\n\n\n+1,000\n\nNumber of dice:  1 2 3 4 5 10 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThrows:  Reset"
  },
  {
    "objectID": "visualizations/bees/bees.html#about",
    "href": "visualizations/bees/bees.html#about",
    "title": "Bees",
    "section": "About",
    "text": "About\nHow do you like these bees?"
  },
  {
    "objectID": "visualizations/confidence-intervals.html",
    "href": "visualizations/confidence-intervals.html",
    "title": "Confidence Intervals",
    "section": "",
    "text": "CI =Â 80%\n\nNumber of cards:  3 5 10 30  Draw \n\n\n\n\n\nM ="
  },
  {
    "objectID": "visualizations/confidence-intervals.html#about",
    "href": "visualizations/confidence-intervals.html#about",
    "title": "Confidence Intervals",
    "section": "About",
    "text": "About\nA deck of playing cards is a known population consisting of the numbers 1 through 13 repeated 4 times, once for each suit. The average of this population (\\(\\mu\\)) is 7.00, and the standard deviation (\\(\\sigma\\)) is 3.78.\nIn the visualization above, you can take samples from this population repeatedly. Each sample produces an estimate of the population parameter with a margin of uncertainty: this is the confidence interval for the sample.\nThe interpretation of the confidence interval, however, is subtle. The confidence interval is a statement about repeated, long-run probabilities. If we sample from a population repeatedly, the proportion of confidence intervals which include the true population mean will be equal to the specified level of confidence. For example, if we compute an 80% CI for each sample, around 80% of those CIs will include the population mean.\nSo what does the confidence interval for a single sample tell us? The width of the CI reflects the variability in our sample, but it doesnâ€™t allow us to put a probabilistic value on the population parameter. A common mistake is to think that the confidence interval tells us, with the given degree of confidence, that the true population parameter is a value somewhere within the stated range. This sounds intuitive but itâ€™s not quite true. Under the frequentist approach, the population parameter is a fixed constant, and we canâ€™t make probabilistic statements about constants. So strictly speaking, the CI for a single sample reflects the uncertainty in that sampleâ€™s estimate of the parameter rather than uncertainty about the true value of the parameter.\nMaybe that sounds a bit disappointing. Surely the whole point of taking a sample is to be able to say something about the population it came from? Well, yes. This is where confidence intervals connect to Null Hypothesis Significance Testing. Rather than saying how confident we are that the population parameter is within a certain range, the sample (and its CI) can help us make an inference about whether the parameter is (or isnâ€™t) some specific hypothetical value.\nLetâ€™s say we suspect that someone has removed some cards from our deck and so its population mean is not, in fact, 7. Our â€œalternative hypothesisâ€ would be that \\(\\mu \\ne 7\\). The null hypothesis, that our deck hasnâ€™t been tampered with, would be that \\(\\mu = 7\\). We will reject the null hypothesis if the sample looks sufficiently unlikely to have been produced by the hypotheical null hypothesis population. To quantify â€œsufficiently unlikelyâ€ we choose an â€œalphaâ€ (\\(\\alpha\\)) value, some low probability. Weâ€™re willing to accept that level of risk that weâ€™re making a mistake, rejecting the null hypothesis when we shouldnâ€™t.\nThe visualization above really is sampling from a fair deck with a mean of 7. But as youâ€™ll see, some of the confidence intervals in the visualization above donâ€™t include the true population mean. They would cause us to reject the null hypothesis (\\(\\mu = 7\\)) and lead us to believe that someone has indeed tampered with the cards. Weâ€™d be making a mistake; it just so happened that we obtained a sample for which the confidence interval didnâ€™t contain the true population meanâ€“which is what we can expect to happen with a probability equal to the specified confidence. So in this sense, the interpretation of any single confidence interval is most closely related to the binary decision about the null hypothesis; if the null value lies outside our confidence interval, we reject the null hypothesis; if itâ€™s inside, we donâ€™t reject it.\nThe deck cards is a convenient example of a known population, but generally speaking we donâ€™t know the true population parameterâ€“thatâ€™s the whole reason for taking samples and applying statistics!\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\nchart = {\n\n  let sampleSize = Number(d3.select(\"#sampleSize\").property(\"value\"));\n  let sampling = false;\n  let sample = [], sampleArr = [];\n  let numberOfCIsThatContainMu = 0;\n  const samplingSpeed = 150;\n\n  const w = 1050\n  const h = 600\n  const margin = {left: 50, right: 50, top: 50, bottom: 50}\n  \n  let x = d3.scaleLinear()\n    .domain([0, 30])\n    .range([margin.left, w - margin.right])\n  const y = d3.scaleLinear()\n    .domain([1, 13])\n    .range([h - margin.bottom, margin.top])\n    \n  const yAxis = d3.axisLeft(y)\n    .ticks(11)\n\n  const f = d3.format(\".2f\")\n  const f1 = d3.format(\".1f\")\n  \n  const ciInput = document.getElementById('ci-input');\n  const sampleSizeInput = d3.select('#sampleSize');\n  const buttonRandom = document.getElementById('addRandom');\n  \n\n  sampleSizeInput.on(\"change\", () =&gt; setup()); \n\n  let ciWidth = Number(ciInput.value)\n\n  function makeCards(n, divId) {\n\n    d3.select(\"#\" + divId).selectAll(\"div\").remove();\n    for (let i = 0; i &lt; n; i++) {\n\n      d3.select(\"#\" + divId).append(\"div\")\n        .attr(\"id\", \"card\" + (i + 1))\n        .attr(\"class\", \"playing-card-container\")\n        .classed(\"playing-card-blank\", true)\n    }\n  }\n\n  function setup() {\n    sampleSize = Number(d3.select(\"#sampleSize\").property(\"value\"));\n    reset();\n    makeCards(sampleSize, \"cards\");\n  }\n\n  function reset() {\n    sample = [];\n    sampleArr = [];\n    numberOfCIsThatContainMu = 0;\n\n    dots.selectAll(\"circle\").remove();\n    lines.selectAll(\"line\").remove();\n\n    d3.select(\"#proportion\").text(\"#\");\n    d3.select(\"#count\").text(\"#\");\n    d3.select(\"#mean\").text(\"\");\n\n    x.domain([0, 30]);\n  }\n\n  makeCards(sampleSize, \"cards\");\n  \n  \n  function addSampleToPlot(values) {\n  \n    let mean = jStat.mean(values);\n    let sd = jStat.stdev(values, true);\n    let ci = getCI(values, ciWidth);\n    let containsMu = ciContainsMu(mean, ci);\n    let n = sampleArr.length + 1;\n\n    numberOfCIsThatContainMu += containsMu;\n    \n    sampleArr.push({sample: values, mean: mean, ci: ci, containsMu: containsMu, id: n})\n    \n    drawNewCI(n, mean, ci);\n\n    d3.select(\"#proportion\").text(f1(numberOfCIsThatContainMu / n * 100));\n    d3.select(\"#count\").text(n);\n    d3.select(\"#mean\").text(f(mean) + \" [\" + f(mean - ci) + \", \" + f(mean + ci) + \"]\");\n  }\n  \n  buttonRandom.onclick = () =&gt; newSample(sampleSize, false);\n  d3.select(\"#drawContinuously\").on(\"click\", sampleContinuously);\n\n  function newSample(sampleSize, quick = true) {\n\n    sample = [];\n    for (let i = 1; i &lt; sampleSize + 1; i++) {\n      const value = Math.floor(Math.random() * 13 + 1);\n      sample.push(value);\n      d3.select(\"#card\" + i).html(randomCard(value - 1))\n    }\n\n    console.log(sample);\n\n    addSampleToPlot(sample);\n\n    if (!quick) {\n    d3.selectAll(\".playing-card-container\")\n      .data(sample)\n      .classed(\"playing-card-blank\", true)\n      .transition().duration(0).delay((d,i) =&gt; 100 + i * 100)\n      .attr(\"class\", \"playing-card-container\")\n    }\n\n  }\n  \n  function randomCard(value) {\n\n    const suits = [\"\\u2660\",\"\\u2665\",\"\\u2666\",\"\\u2663\"];\n    const colors = [\"black\", \"red\", \"red\", \"black\"];\n    const cards = [\"A\",2,3,4,5,6,7,8,9,10,\"J\",\"Q\",\"K\"];\n    \n    const suitIndex = Math.floor(Math.random() * suits.length);\n    const cardIndex = value;\n\n    return \"&lt;div class='playing-card-value'&gt;\" + cards[cardIndex] + \"&lt;/div&gt;\" + \"&lt;div class='playing-card playing-card-\" + colors[suitIndex] + \"'&gt;\" + suits[suitIndex] + \"&lt;/div&gt;\";\n  }\n  \n  ciInput.oninput = function() {\n    ciWidth = ciInput.value\n    d3.select(\"#ci-width\").text(ciWidth);\n    updateCIs(ciWidth)\n\n    const newCI = getCI(sample, ciWidth);\n    const m = jStat.mean(sample);\n    d3.select(\"#mean\").text(f(m) + \" [\" + f(m - newCI) + \", \" + f(m + newCI) + \"]\");\n  }\n\nlet samplingInterval;\nconst sampleContinuouslyBtn = d3.select(\"#drawContinuously\");\n\n  function sampleContinuously() {\n\n    if (!sampling) {\n      sampling = true;\n      d3.selectAll(\".playing-card-container\")\n      .classed(\"playing-card-blank\", false);\n\n      samplingInterval = setInterval(() =&gt; {\n        newSample(sampleSize);\n    }, samplingSpeed);\n\n    sampleContinuouslyBtn.html(\"&lt;i class='bi bi-stop'&gt;&lt;/i&gt;\").attr(\"class\", \"btn btn-danger\")\n\n    } else {\n      sampleContinuouslyBtn.html(\"&lt;i class='bi bi-play'&gt;&lt;/i&gt;\").attr(\"class\", \"btn btn-outline-success\")\n      clearInterval(samplingInterval);\n      sampling = false;\n    }\n  }\n\n  \n  \n  const svg = d3.select(\"#plot-container\").append(\"svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + w + \" \" + h)\n    \n  const svgDataLayer = svg.append(\"g\")\n  const lines = svgDataLayer.append(\"g\")\n  const dots = svgDataLayer.append(\"g\")\n  const gridY = svg.append(\"g\")\n  \n  // population mean line\n  gridY.append(\"line\")\n    .attr(\"x1\", x(0))\n    .attr(\"x2\", x(30))\n    .attr(\"y1\", y(7))\n    .attr(\"y2\", y(7))\n    .style(\"stroke\", \"grey\")\n    .attr(\"stroke-width\", 2)\n    .attr(\"stroke-dasharray\", [5,5])\n  gridY.append(\"text\")\n    .attr(\"x\", x(0.2))\n    .attr(\"y\", y(7.05))\n    .text(\"true population mean\")\n    \n  \n  const axisY = svg.append(\"g\")\n  axisY.append(\"rect\").attr(\"x\", -margin.left).attr(\"width\", margin.left).attr(\"height\", h)\n    .attr(\"fill\", \"var(--mermaid-bg-color)\");\n  axisY.call(yAxis)\n    .attr(\"transform\", `translate(${x(0)},0)`)\n\nfunction drawNewCI(n, point, margin) {\n\n    const includesMu = ciContainsMu(point, margin);\n\n    dots.append(\"circle\")\n      .attr(\"r\", 4)\n      .attr(\"cx\", x(n))\n      .attr(\"cy\", y(point))\n\n    lines.append(\"line\")\n      .attr(\"x1\", x(n))\n      .attr(\"x2\", x(n))\n      .attr(\"y1\", y(point))\n      .attr(\"y2\", y(point))\n      .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", includesMu)\n      .transition(\"grow\").duration(samplingSpeed)\n      .attr(\"y1\", y(point + margin))\n      .attr(\"y2\", y(point - margin))\n  \n    if (n &gt; 30) {\n      x.domain([n - 30, n]);\n\n      dots.selectAll(\"circle\").data(sampleArr)\n      .transition().duration(samplingSpeed).ease(d3.easeLinear)\n      .attr(\"cx\", d =&gt; x(d.id));\n\n      lines.selectAll(\"line\").data(sampleArr)\n      .transition().duration(samplingSpeed).ease(d3.easeLinear)\n      .attr(\"x1\", d =&gt; x(d.id)).attr(\"x2\", d =&gt; x(d.id));\n    } \n  }\n\n\n  function updateCIs (confidence) {\n  \n  // take the array and recalculate all CIs\n  const n = sampleArr.length;\n  numberOfCIsThatContainMu = 0;\n  for (var i = 0; i &lt; sampleArr.length; i++) {\n    sampleArr[i].ci = getCI(sampleArr[i].sample, confidence);\n    sampleArr[i].containsMu = ciContainsMu(sampleArr[i].mean, sampleArr[i].ci);\n    numberOfCIsThatContainMu += sampleArr[i].containsMu;\n  }\n  \n  // then redraw all CIs on the svg\n  lines.selectAll(\"line\")\n  .data(sampleArr)\n      .attr(\"y1\", d =&gt; y(d.mean + d.ci))\n      .attr(\"y2\", d =&gt; y(d.mean - d.ci))\n      // .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", d =&gt; ciContainsMu(d.mean, d.ci))\n    \n    // and update the description text\n    d3.select(\"#proportion\").text(f1(numberOfCIsThatContainMu / n * 100));\n  }\n  \n  \n  \n}\n\nfunction getCI (array, confidence) {\n  const mean = jStat.mean(array);\n  const alpha = 1 - confidence / 100;\n  return mean - jStat.tci(mean, alpha, array )[0];\n\n}\n\n\nfunction ciContainsMu (point, ci) {\n  return (point + ci &gt; 7 && point - ci &lt; 7);\n}\n\nfunction countOfCIs(arr) {\n    const x = arr.map(a =&gt; a.containsMu);\n    const count = x.reduce((acc, curr) =&gt; {\n  return acc + (curr ? curr : 0);\n}, 0);\n\n    return count;\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nBees\n\nConfidence Intervals"
  },
  {
    "objectID": "index.html#visualizations",
    "href": "index.html#visualizations",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nBees\n\nConfidence Intervals"
  },
  {
    "objectID": "index.html#games",
    "href": "index.html#games",
    "title": "PSYCH STATS",
    "section": "Games",
    "text": "Games\nSome â€˜gamesâ€™ (Iâ€™m using the term loosely!) that I use to illustrate statistical concepts or generate data for analysis.\nGuess the Correlation\nTriplett\nJellybeans\nQuincunx\nDice Roller\n\nbannerImage = {\n\n    const svg = d3.select(\".quarto-title\").append(\"svg\")\n        .attr(\"id\", \"title-svg\")\n        .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n        .attr(\"viewBox\", \"0 0 \" + 50 + \" \" + 20)\n\n    svg.selectAll(\"circle\").data(data).enter().append(\"circle\")\n        .attr(\"cx\", d =&gt; d.x)\n        .attr(\"cy\", -5)\n        .attr(\"r\", 0.5)\n        .attr(\"stroke\", \"none\")\n        .attr(\"fill\", (d, i) =&gt; d3.schemeCategory10[i % 10])\n        .transition().duration(800).ease(d3.easeCubicIn)\n        .delay( (d, i) =&gt; i * 8)\n        .attr(\"cy\", d =&gt; 20 - d.y)\n\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website was made by Rob Brotherton. Iâ€™m an academic psychologist and writer. I teach statistics and political psychology at Barnard College in New York City.\n\n\nThis site collects together some of the visualizations and games Iâ€™ve made as part of my statistics course. Statistics, at its core, is about understanding the patterns and principles that shape our world. Itâ€™s more than just a set of abstract equations. To help bring this vision to life, I created an array of interactive visualizations and games. Rather than just learning about a statistical concept like the Central Limit Theorem, these help you to experience it in action, to see the narratives that numbers can create. My hope is to bridge the gap between abstract equations and hypothetical distributions and the real, messy processes that somehow produce those predictable patterns. Seeing these basic processes in action goes a long way towards understanding how statistical stories play out in our day-to-day lives.\nThe design philosophy is grounded in the notion that statistics is a tactile, organic, and sometimes messy process. The visualizations I use show statistical populations not as abstract curves, but as hundreds of individual dots piled up into a normal (or not-so-normal) distribution. When you draw a sample from these populations, you can see and interact with the specific dots that have been selected, keeping track of the progression from the individual to the aggregate. This is designed to instill a sense of the concrete nature of statistics, reinforcing that behind every data point there is a story.\nThis approach to bringing statistics to life also shapes my choice of visual design. I use bright colors and a â€˜sketchyâ€™ theme that harks back to a time of hand-drawn graphs and chalkboard equations. The intention is to remind users that what they are interacting with is not a dry, abstract mathematical concept, but a dynamic process that reflects the vibrant, sometimes chaotic reality of our world. Itâ€™s about more than numbers â€“ itâ€™s about people, processes, and the patterns that tie it all together."
  },
  {
    "objectID": "visualizations/unbiased-estimates.html",
    "href": "visualizations/unbiased-estimates.html",
    "title": "(Un)Biased estimates",
    "section": "",
    "text": "Show: \\(M\\) \\(SD_{n}\\) \\(SD_{n - 1}\\)\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\nw = 800\nh = 400\n\nmaxWidth = 900;\nmaxHeight = 550;\n\ntimeseriesVertical = false;\n\npanelSpacing = 5;\n\npopulationPanelWidth = maxWidth * 0.6;\npopulationPanelHeight = maxHeight;\n\npopulationSubPanelProportion = 0.4;\nsampleSubPanelProportion = 0.05;\n\nestimatesSubPanelProportion = 0.55;\n\nestimatesPanelWidth = maxWidth - populationPanelWidth;\nestimatesPanelHeight = populationPanelHeight;\n\ntimeSeriesPanelWidth = maxWidth - populationPanelWidth;\n\n\n\nradius = 4; //1.4\nsampleSize = 5;\n\n    \nxScalePopulation = d3.scaleLinear()\n    .domain([-4, 4])\n    .range([0 + radius, (populationPanelWidth) - radius])\nyScalePopulation = d3.scaleLinear()\n    .domain([0, 300])\n    .range([populationPanelHeight * populationSubPanelProportion, 0])\n\nxScaleEstimates = d3.scaleLinear()\n    .domain([-1.25, 1.25])\n    .range([0, estimatesPanelWidth])\n    \nyScaleEstimates = d3.scaleLinear()\n    .domain([20, 0])\n    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])\n\nxAxisEstimatesValues = [-2, -1, 0, 1, 2];\nxAxisEstimates = d3.axisBottom(xScalePopulation)\n  .tickValues(xAxisEstimatesValues)\n  .tickFormat(d =&gt; d)\n  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)\nupdate_svg = {\n\n  var sample = [];\n  var sampleData = [];\n  var sample_estimates = [];\n  var running_averages = [{param: \"population\", value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n  \n  var nSamplesDrawn = 0;\n  \n  var legendSelected = [\"sample\", \"population\"]\n  \n  var timeX, timeY, biasLine, timeXAxis, timeYAxis;\n  var timeSvg, \n  timeScaleBias, \n  timeScaleId, \n  timeBiasAxis, \n  timeIdAxis, \n  timeseriesDataLayer,\n  timeseriesBiasAxisLayer,\n  timeseriesIdAxisLayer;\n\n  let isLargeScreen;\n\n  function newSample() {\n    \n    nSamplesDrawn++\n    \n    // pick random observations from the population by their index\n    for (var i = 0; i &lt; sampleSize; i++) {\n      let randomIndex = Math.floor(Math.random() * popData.length);\n      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);\n      sampleData[i] = popData[randomIndex];\n    }\n    \n    var estimates = getSampleEstimates(sample)\n    estimates.map(d =&gt; d.id = nSamplesDrawn);\n    sample_estimates.push(estimates)\n    \n    updateRunningAverages(estimates);\n    updateBiasChart();\n    updateSampleCircles();\n    animateEstimates(sampleData, estimates);\n    updatePath();\n    updateVisibility();\n  }\n  \n  function updateBiasChart() {\n      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])\n      \n      biasDots.selectAll(\"path\").remove()\n      biasDots.selectAll(\"path\")\n          .data(sample_estimates.flat())\n          .enter()\n          .append(\"path\")\n            .attr(\"id\", d =&gt; d.param + \"-estimate\")\n            .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)\n            .attr(\"opacity\", d =&gt; (d.id === nSamplesDrawn ? 0 : 1))\n            .transition()\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)\n            \n  }\n  \n\n  \n  function updateSampleCircles() {\n  \n  let durationMultiplier = 5;\n  if (playing) durationMultiplier = 1;\n  \n    sampleCircles.selectAll('circle').remove()\n    sampleCircles.selectAll('circle')\n      .data(sampleData)\n      .enter().append(\"circle\")\n      .attr(\"class\", \"sample\")\n      .attr(\"r\", radius)\n      .attr(\"cx\", d =&gt; d.cx)\n      .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n      .attr(\"fill\", d =&gt; d.fill)\n      .transition()\n      .duration(d =&gt; d.cy * durationMultiplier)\n      .ease(d3.easeBounceOut)\n      .attr(\"cy\", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)\n  }\n  \n  \n  \n  function animateEstimates(sampleData, estimates) {\n  \n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    \n    var wait = Math.max(...sampleData.map(z =&gt; z.cy));\n    \n    for (let i = 0; i &lt; estimates.length; i++) {\n\n    var p = estimates[i].param;\n    var endPosition = estimates[i].value;\n    var dur = (playing ? 0 : 1000);\n    var convergeWait = (playing ? 0 : wait * 5);\n    var moveDownWait = (playing ? 250 : 0);\n    \n    sampleData.forEach((s) =&gt; {\n    \n    // first, place estimate symbols where each sample dot lands\n      sampleEstimatesTemp\n      .append(\"path\")\n      .attr(\"id\", p + \"-estimate\")\n      .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n        .attr(\"transform\", d =&gt; `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        .attr(\"opacity\", 0)\n        \n    // then move them all to the estimate\n        .transition().duration(dur * 0.67).delay(convergeWait)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", d =&gt; `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        \n    // then move them down to the estimates tracker\n    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)\n      .ease(d3.easeCubicOut)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)\n    })\n\n    }\n  }\n  \n  const sleep = (milliseconds) =&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, milliseconds))\n  }\n  var playing = false;\n  function playButtonClicked() {\n    \n    playing = !playing; \n  \n  play_button.text(function(){\n    if(playing) {\n      play_button.attr(\"class\", \"btn btn-danger\")\n      return \"â—¼\"\n  } else {\n    play_button.attr(\"class\", \"btn btn-outline-success\")\n    return \"â–¶\"\n  }\n  })\n  \n  if (playing) {\n    continuouslyDrawSamples();\n  }\n  }\n  \n  function continuouslyDrawSamples() {\n    if (playing) {\n      newSample();\n      sleep(200).then(continuouslyDrawSamples);\n    }\n  }\n  \n    \n  var popData = [];\n  const color = d3.scaleOrdinal(d3.schemeCategory10);\n  for (let i = 0; i &lt; population.length; ++i) {\n    const cx = xScalePopulation(population[i]);\n    const cy = 10 + (dodge(cx) - radius - 1);\n    &lt;!-- const cy = yScalePopulation(dodge(cx)); --&gt;\n    const fill = color(i % 10);\n    popData.push({cx, cy, fill})\n  }\n  \n  \n  \n  const populationLabels = [{label: \"Population\", top: 0},\n                            {label: \"Sample\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion) * 100},\n                            {label: \"Under/over-&lt;/br&gt;estimation of&lt;/br&gt;parameter\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion + sampleSubPanelProportion) * 100}]\n  \n  const populationContainer = d3.select(\"#population-container\")\n    .style(\"position\", \"relative\")\n    &lt;!-- .style(\"height\", maxHeight) --&gt;\n    \n    // panel labels\n  populationContainer.selectAll(\"text\").data(populationLabels).enter()\n    .append(\"text\")\n    .style(\"position\", \"absolute\")\n    .html(d =&gt; d.label)\n    .attr(\"class\", \"panel-label\")\n    .style(\"top\", d =&gt; d.top + \"%\")\n    .style(\"line-height\", \"1em\")\n\n  const populationAndSampleSvg = d3.select(\"#population-container\")\n    .append(\"svg\").attr(\"id\", \"populationAndSample-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + (populationPanelWidth) + \" \" + populationPanelHeight)\n    \n    // panel backgrounds\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight * populationSubPanelProportion)\n    .attr(\"fill\", \"var(--population-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * populationSubPanelProportion)\n    .attr(\"height\", populationPanelHeight * sampleSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--sample-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * (1 - estimatesSubPanelProportion))\n    .attr(\"height\", populationPanelHeight * estimatesSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n    \n\n    \n  const pop = populationAndSampleSvg.append(\"g\")\n  const parameters = populationAndSampleSvg.append(\"g\")\n  const sampleEstimates = populationAndSampleSvg.append(\"g\")\n  const sampleEstimatesTemp = populationAndSampleSvg.append(\"g\")\n  const sampleCircles = populationAndSampleSvg.append(\"g\")\n\n  const biasDots  = sampleEstimates.append(\"g\")\n  \n  pop.selectAll(\"circle\")\n      .data(popData)\n      .enter()\n      .append(\"circle\")\n        .attr(\"class\", \"pop\")\n        .attr(\"cx\", d =&gt; d.cx)\n        .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n        .attr(\"r\", radius)\n        .attr(\"fill\", d =&gt; d.fill)\n        \n    // estimates axis\n    \n  const estimatesAxis = sampleEstimates.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScaleEstimates(21)})`)\n  \n  estimatesAxis.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight - yScaleEstimates(21))\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n  estimatesAxis.call(xAxisEstimates)\n  estimatesAxis.select(\".domain\").remove()\n  \n\n\n  \n  formatAxes(estimatesAxis.selectAll(\"line\"));\n  \n    \n  var legendStatus = [{param: \"mean\",       hide: true},\n                      {param: \"population\", hide: false},\n                      {param: \"sample\",     hide: false}]\n                      \n  \n  function updateLegendStatus(param) {\n    var index;\n    if (param===\"mean\") {index = 0;}\n    if (param===\"population\") {index = 1;}\n    if (param===\"sample\") {index = 2;}\n    legendStatus[index].hide = !legendStatus[index].hide\n\n    var classes = \"#\" + param + \"-estimate\"\n    \n    populationAndSampleSvg.selectAll(classes).classed(\"hide\", legendStatus[index].hide)\n    timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[index].hide)\n    legend.classed(\"unselected\", d =&gt; d.hide)\n  }\n  \n    const legend = d3.selectAll(\".selector\")\n    legend\n      .data(legendStatus)\n      .classed(\"unselected\", d =&gt; d.hide)\n      .on(\"click\", function(event, d){updateLegendStatus(d.param);})\n  \n\n\n  \n  // buttons\n  const controls = d3.select(\"#controls-container\")\n  \n  const reset_button = controls.append(\"button\")\n    .attr(\"class\", \"btn btn-outline-primary\")\n    // .attr(\"type\", \"button\")\n    .text(\"Reset\")\n    .on(\"click\", clearData)\n  \n  const button = controls.append(\"button\")\n    .attr(\"class\", \"btn btn-outline-primary\")\n    .text(\"Take one sample\")\n    .on(\"click\", newSample)\n    \n  const play_button = controls.append(\"button\")\n    .attr(\"id\", \"play-button\")\n    .attr(\"class\", \"btn btn-outline-success\")\n    // .attr(\"class\", \"button invertable\")\n    .attr(\"x\", 50)\n    .attr(\"y\", h - 50)\n    .text(\"â–¶\")\n    .on(\"click\", playButtonClicked)\n    \n\n\n// make timeseries chart\nconst timeChart = {\n    width: timeSeriesPanelWidth,\n    height: maxHeight,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\nconst timeChartHorizontal = {\n    width: populationPanelWidth,\n    height: 300,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\n  const timeseriesContainer = d3.select(\"#timeline-container\");\n  timeseriesContainer.style(\"position\", \"relative\")\n\n  updateTimeseriesDimensions(window.innerWidth);\n\n  // Re-render the chart whenever the window size changes\n  window.addEventListener(\"resize\", () =&gt; updateTimeseriesDimensions(window.innerWidth));\n\n\n\n  function updateTimeseriesDimensions(winWidth) {\n\n    const largeScreen = winWidth &gt; 600;\n    if (largeScreen === isLargeScreen) return;\n    // Update the screen state\n    isLargeScreen = largeScreen;\n    \n  var params;\n  var orientation = (winWidth &gt; 600) ? \"vertical\" : \"horizontal;\"\n\n  console.log(orientation);\n\n  // first, set up chart dimensions and axes\n  if (winWidth &gt; 600) {\n\n    params = timeChart;\n\n    timeScaleBias = d3.scaleLinear()\n      .domain([-0.5, 0.5])\n      .range([params.margin.left, params.width - params.margin.right])\n    timeScaleId = d3.scaleLinear()\n      .domain([0, 200])\n      .range([params.margin.top, params.height - params.margin.bottom])\n    biasLine = function(x, y){\n        return d3.line()\n        .x(function(d,i) { return timeScaleBias(x[i]); })\n        .y(function(d,i) { return timeScaleId(y[i]); })\n        (Array(x.length));\n    }\n    timeBiasAxis = d3.axisTop(timeScaleBias)\n      .ticks(5)\n      .tickSize(-(params.height - params.margin.top - params.margin.bottom)) // 440\n    timeIdAxis = d3.axisRight(timeScaleId).tickSize(0)\n  } else {\n\n      params = timeChartHorizontal;\n\n      timeScaleBias = d3.scaleLinear()\n        .domain([-0.5, 0.5])\n        .range([params.height - params.margin.bottom, params.margin.top])\n        \n      timeScaleId = d3.scaleLinear()\n        .domain([0, 200])\n        .range([params.margin.left, params.width - params.margin.right])\n      biasLine = function(x, y){\n          return d3.line()\n          .x(function(d,i) { return timeScaleId(y[i]); })\n          .y(function(d,i) { return timeScaleBias(x[i]); })\n          (Array(x.length));\n      }\n    timeIdAxis = d3.axisBottom(timeScaleId)\n      .tickSize(0)\n    timeBiasAxis = d3.axisLeft(timeScaleBias)\n      .ticks(5).tickSize(-params.width - params.margin.left - params.margin.right)\n  }\n\n  // then instantiate the chart svg itself\n  d3.select(\"#timeline-container\").select(\"svg\").remove();\n  d3.select(\"#timeline-container\").selectAll(\"text\").remove();\n  timeSvg = makeTimeseriesChart(params);\n  timeseriesDataLayer = timeSvg.append(\"g\");\n  timeseriesBiasAxisLayer = timeSvg.append(\"g\").attr(\"class\", \"timeseries\");\n  timeseriesIdAxisLayer = timeSvg.append(\"g\").attr(\"class\", \"timeseries\");\n\n  // then place the axes\n  positionTimeAxes(orientation, params);\n\n  // then draw the current data\n  updatePath();\n}\n  \n\n  \n  function makeTimeseriesChart(params) {\n    \n    // text labels\n    timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .attr(\"class\", \"panel-label timeseries\")\n    .text(\"Average under/over-estimation\")\n  \n  timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"line-height\", \"1em\")\n    .style(\"bottom\", 0)\n    .style(\"right\", 0)\n    .style(\"text-align\", \"right\")\n    .attr(\"class\", \"timeseries\")\n    .html(\"Total&lt;br&gt;samples\")\n    \n    const svg = d3.select(\"#timeline-container\")\n    .append(\"svg\").attr(\"id\", \"timeline-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + params.width + \" \" + params.height)\n    \n    // background panel\n  svg.append(\"rect\")\n    .attr(\"width\", params.width)\n    .attr(\"height\", params.height)\n    .attr(\"rx\", 5)\n    .attr(\"fill\", \"var(--timeseries-panel-background)\")\n    \n    return svg;\n    \n  }\n  \n  \n  function positionTimeAxes(orientation, params) {\n    if (orientation === \"vertical\") {\n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(0, ${params.margin.top})`)\n\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"width\", params.width)\n        .attr(\"y\", -params.margin.top)\n        .attr(\"height\", params.margin.top)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n\n        timeseriesIdAxisLayer.attr(\"transform\", `translate(${params.width - params.margin.right}, 0)`)\n  \n    } else {\n      timeseriesIdAxisLayer.attr(\"transform\", `translate(0, ${params.height - params.margin.bottom})`)\n\n      // todo: this isn't positioned correctly\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"x\", -params.margin.left)\n        .attr(\"width\", params.margin.left)\n        .attr(\"height\", params.height)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n      \n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(${params.margin.left}, 0)`)\n        \n      \n    }\n    timeseriesIdAxisLayer.call(timeIdAxis)\n    timeseriesBiasAxisLayer.call(timeBiasAxis);\n    timeseriesBiasAxisLayer.select(\".domain\").remove();\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    formatAxes(timeSvg.selectAll(\"line\"));\n    \n    timeSvg.selectAll(\"line\").classed(\"dark\", true)\n  }\n  \n  \n  function updatePath() {\n      timeseriesDataLayer.selectAll(\"g\").remove()\n      \n      if (nSamplesDrawn &gt; 201) {\n        timeScaleId.domain([nSamplesDrawn - 200, nSamplesDrawn]);\n        // timeIdAxis = d3.axisRight(timeScaleId).tickSize(0);\n        timeseriesIdAxisLayer.call(timeIdAxis);\n        timeseriesIdAxisLayer.select(\".domain\").remove();\n      }\n      \n      timeseriesDataLayer.selectAll(\"g\")\n        .data(running_averages)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"bias-paths\")\n        .append(\"path\")\n          .attr(\"d\", d =&gt; biasLine(d.value.slice(1), d.id.slice(1)))\n          .attr(\"id\", d =&gt; d.param + \"-path\")\n\n  }\n  \n\n\nfunction clearData() {\n    sample = [];\n    sample_estimates = [];\n    running_averages = [{param: \"population\",   value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n    nSamplesDrawn = 0;\n    \n    timeScaleId.domain([0, 200]);\n    timeseriesIdAxisLayer.call(timeIdAxis);\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    sampleCircles.selectAll('circle').remove()\n    sampleEstimates.selectAll(\"path\").remove()\n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    timeseriesDataLayer.selectAll(\"path\").remove()\n  }\n  \n  function updateRunningAverages(estimates) {\n  \n      var cur_n = nSamplesDrawn\n      var prev_n = cur_n - 1\n      \n      var old = running_averages[0].value[prev_n]\n      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n\n      running_averages[0].value.push(new_pop)\n      \n      var old = running_averages[1].value[prev_n]\n      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n\n      running_averages[1].value.push(new_sam)\n      \n      var old = running_averages[2].value[prev_n]\n      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n\n      running_averages[2].value.push(new_mea)\n    \n      running_averages[0].id.push(cur_n)\n      running_averages[1].id.push(cur_n)\n      running_averages[2].id.push(cur_n)\n\n}\n\n  function updateVisibility() {\n  \n    var params = [\"mean\", \"population\", \"sample\"]\n    \n    for (var i = 0; i &lt; 3; i++) {\n      var param = params[i]\n      var elementIds = \"#\" + param + \"-estimate, #\" + param + \"-line\"\n      \n      populationAndSampleSvg.selectAll(elementIds).classed(\"hide\", legendStatus[i].hide)\n      &lt;!-- populationAndSampleSvg.selectAll(\"#\" + param + \"-estimate\").classed(\"hide\", legendStatus[i].hide) --&gt;\n      timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[i].hide)\n    }\n  }\n  \n}\ndodger = radius =&gt; {\n  const radius2 = radius ** 1.9;\n  const bisect = d3.bisector(d =&gt; d.x);\n  const circles = [];\n  return x =&gt; {\n    const l = bisect.left(circles, x - radius);\n    const r = bisect.right(circles, x + radius, l);\n    let y = 0;\n    for (let i = l; i &lt; r; ++i) {\n      const { x: xi, y: yi } = circles[i];\n      const x2 = (xi - x) ** 2;\n      const y2 = (yi - y) ** 2;\n      if (radius2 &gt; x2 + y2) {\n        y = yi + Math.sqrt(radius2 - x2) + 1e-6;\n        i = l - 1;\n        continue;\n      }\n    }\n    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });\n    &lt;!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) --&gt;\n    return y;\n  };\n}\n\ndodge = dodger(radius * 2 + 0.75);\nfunction mean(array) {\n    return array.reduce((a, b) =&gt; a + b) / array.length;\n}\n\nfunction sample_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / (n - 1);\n}\n\nfunction population_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / n;\n}\n\nfunction get_descriptives (array) {\n    return {mean: mean(array),\n            sample_variance: sample_variance(array) - 1, \n            population_variance: population_variance(array) - 1}\n}\n\nfunction getNewData (array) {\n    \n    return {sample_estimates: getSampleEstimates(array)\n            &lt;!-- running_averages: getRunningAverages(array) --&gt;\n            }\n}\n\nfunction getSampleEstimates(array) {\n    return [{param: \"population\", value: population_variance(array) - 1},\n            {param: \"sample\",     value: sample_variance(array) - 1},\n            {param: \"mean\",       value: mean(array)}]\n}\n\n\nfunction formatAxes(elements) {\n  elements._groups[0].forEach((l) =&gt; {\n    if (l.__data__ === 0) {\n      l.classList = \"axis-major\";\n    } else {\n      l.classList = \"axis-minor\";\n    }\n  })\n}"
  },
  {
    "objectID": "visualizations/unbiased-estimates.html#about",
    "href": "visualizations/unbiased-estimates.html#about",
    "title": "(Un)Biased estimates",
    "section": "About",
    "text": "About\nTo say a statistic is unbiased is to say that, on average, its value is equal to the parameter it is estimating. Sampling error, the inherent randomness which determines which observations appear in the sample, ensures that each individual sample will produce a different estimate; any given sampleâ€™s statistic wonâ€™t be exactly equal to the parameter. But if many samples are taken, the average of all those statistics will converge on the true population parameterâ€™s value.\nThe arithmetic average is an unbiased statistic. Each sampleâ€™s mean will be different, some above the true population mean and some below. Because the discrepancy is random, however, with many samples the overestimates and underestimates balance out. The average of all the differences between each sample average and the true population average will be close to zero. Thatâ€™s what makes the mean unbiased.\nStandard deviation is more complicated. There are two different equations for standard deviation. In both cases, you first calculate the mean, then the sum of squared deviations from the mean. If the data represents a complete population, you then divide the sum of squared deviations by N, the total number of observations in the entire population. With data from a sample, however, you divide by n - 1, the number of scores in the sample minus 1. This is because if you use the first approach with data from a sample, dividing by N, the statistic will be biased.\nMore specifically, using the population standard deviation equation with sample data has the effect of systematically underestimating the population parameter. As with the mean, each sample produces a slightly different estimate, but unlike the mean, the difference between estimate and parameter is not completely random. More samples will underestimate the population variability than overestimate it. As a result, the average of all sample estimates of standard deviation would be lower than the true population value.\nDividing by n - 1 when calculating a sampleâ€™s standard deviation corrects for that bias, producing an unbiased estimate. Why? It has to do with the fact that the standard deviation is a measure of variability, a measure of how spread out the data is. When you estimate the population standard deviation from a sample, youâ€™re trying to use a small subset of the population to estimate the variability in the entire population.\nBut, thereâ€™s an inherent problem here. When we calculate the standard deviation of a sample, weâ€™re using the sample mean, not the population mean, because the population mean is usually unknown. The sample mean, being calculated from the data in the sample, is more likely to be closer to the individual data points in the sample than the population mean would be. This means the squared deviations from the sample mean are likely to be smaller, on average, than the squared deviations from the population mean. This is what leads to the underestimate of the variance, and hence the standard deviation, when we divide by Nâ€™ instead of n - 1.\nNow, why n - 1 instead of, say, n - 2 or n - 3? This has to do with something in statistics known as â€˜degrees of freedomâ€™. Degrees of freedom are, in a way, the number of values that are free to vary given the constraints in the problem.\nIn the case of variance and standard deviation, the constraint is the sample mean. Once weâ€™ve calculated the sample mean, the sum of the deviations from the mean must equal zero. This means that once we know the deviations of n - 1 values, the deviation of the nth value is completely determined. So, we say we have n - 1 degrees of freedom.\nWhen you divide by n - 1 instead of â€˜nâ€™, you are effectively adjusting the sample variance and sample standard deviation upwards to account for the fact that youâ€™ve underestimated the squared deviations because you used the sample mean instead of the population mean. This adjustment gives a larger value for the sample variance and sample standard deviation, which on average gives a better (i.e., unbiased) estimate of the population variance and population standard deviation.\nThis visualization can demonstrate this effect: if you take many samples and calculate the sample standard deviation using n and n - 1 in the denominator, youâ€™ll see that the average of the sample standard deviations calculated with n - 1 in the denominator will be closer to the true population standard deviation, while those calculated with â€˜nâ€™ in the denominator will tend to underestimate it. This shows how the n - 1 adjustment corrects for the bias in estimating the population standard deviation from a sample."
  },
  {
    "objectID": "visualizations/least-squared-error.html",
    "href": "visualizations/least-squared-error.html",
    "title": "Regression: The Least Squared Error Solution",
    "section": "",
    "text": "Regression: The Least Squared Error Solution\nIntercept (\\(a\\)): hi \nSlope (\\(b\\)): hi \n\n\n\n\n\n\n\n\n\n\nchangable_chart = {\n\n  const w = 900;\n  const h = 500;\n  \n  const margin = {top: 20, right: 20, left: 110, bottom: 75}\n\n  const x_values = [4,5,7,8,11]\n  const y_values = [5,8,8,10,9]\n  const yhat_values = [0,0,0,0,0]\n  \n  const data = [{xVal: 4, yVal: 5},\n                {xVal: 5, yVal: 8},\n                {xVal: 7, yVal: 8},\n                {xVal: 8, yVal: 10},\n                {xVal: 11, yVal: 9}]\n                \n  const aInput = d3.select(\"#a-control\")\n  const bInput = d3.select(\"#b-control\")\n  \n  aInput.on(\"input\", function() {\n    // Log slider value and event details for debugging\n    // Remove/comment out after debugging\n    // console.log(\"a-control value:\", this.value, \"event:\", d3.event);\n    drawFitLine();\n  });\n  bInput.on(\"input\", function() {\n    // console.log(\"b-control value:\", this.value, \"event:\", d3.event);\n    drawFitLine();\n  });\n  \n  const x = d3.scaleLinear()\n    .range([margin.left, w - margin.right - 300])\n    .domain([0, 12])\n  const y = d3.scaleLinear()\n    .range([h - margin.bottom, margin.top])\n    .domain([0, 10])\n  \n  const xAxis = d3.axisBottom(x);\n  const yAxis = d3.axisLeft(y);\n  \n  \n  const svg = d3.select(\"#error-plot-container\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n    \n  const sumSquaresSvg = d3.select(\"#sum-squares-container\").append(\"svg\")\n    .attr(\"width\", 400)\n    .attr(\"height\", 400)\n    \n  const axes = svg.append(\"g\")\n  const axisFontSize = \"0.7em\"\n  axes.append(\"g\").attr(\"transform\", `translate(0, ${h - margin.bottom})`).call(xAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  axes.append(\"g\").attr(\"transform\", `translate(${margin.left}, 0)`).call(yAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  \n  const sumSquaresPlot = sumSquaresSvg.append(\"g\")\n  sumSquaresPlot.attr(\"transform\", `translate(50, 50)`)\n  \n  const axisTitles = svg.append(\"g\")\n    .style(\"font-size\", \"0.8em\")\n    .style(\"font-family\", \"Times New Roman\")\n    .style(\"fill\", \"var(--text-color)\")\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(${margin.left + (w - margin.left - margin.right) / 2}, ${h - 10})`).text(\"Sleep duration\")\n    .attr(\"text-anchor\", \"middle\");\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(0, ${margin.top + (h - margin.top - margin.bottom) / 2})`)\n    .text(\"Score\")\n    \n  \n  const residuals = svg.append(\"g\")\n  residuals.selectAll(\"line\").data(data).enter()\n      .append(\"line\")\n        .attr(\"x1\", d =&gt; x(d.xVal))\n        .attr(\"x2\", d =&gt; x(d.xVal))\n        .attr(\"y1\", d =&gt; y(d.yVal))\n        &lt;!-- .attr(\"y2\", d =&gt; y(d.yVal)) --&gt;\n        .style(\"stroke\", \"red\")\n        .style(\"stroke-width\", 2)\n        .attr(\"stroke-dasharray\", [5, 3])\n        \n  const fitLine = svg.append(\"line\")\n    .style(\"stroke\", \"dodgerblue\")\n    .style(\"stroke-width\", 3)\n    \n  const dots = svg.append(\"g\")\n  const squares = svg.append(\"g\")\n  \n  const ssResidualSquare = sumSquaresPlot.append(\"g\").append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.8)\n  \n  const ssResidualLabel = sumSquaresPlot.append(\"text\")\n    .text(\"SSresidual\")\n    .attr(\"x\", 0)\n    .style(\"font-size\", \"0.9em\")\n    .style(\"fill\", \"plum\")\n    \n  dots.selectAll(\"circle\").data(data).enter().append(\"circle\")\n    .attr(\"cx\", d =&gt; x(d.xVal))\n    .attr(\"cy\", d =&gt; y(d.yVal))\n    .attr(\"r\", 5)\n    .style(\"fill\", \"var(--text-color)\")\n    \n  squares.selectAll(\"polygon\").data(data).enter()\n    .append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.5)\n    \n  function drawFitLine() {\n    var a = Number(aInput.property(\"value\"));\n    d3.select(\"#a-output\").text(a.toFixed(2));\n    var b = Number(bInput.property(\"value\"));\n    d3.select(\"#b-output\").text(b.toFixed(2));\n    \n    var yhat1 = a\n    var yhat2 = b * 12 + a\n    \n    fitLine\n      .attr(\"x1\", x(0))\n      .attr(\"x2\", x(12))\n      .attr(\"y1\", y(yhat1))\n      .attr(\"y2\", y(yhat2))\n      \n    var ssResidual = 0;\n    \n    for(var i = 0; i &lt; data.length; i++) {\n      var yHat = b * data[i].xVal + a;\n      var residual = data[i].yVal - yHat\n      data[i].yHat = yHat;\n      data[i].res = residual;\n      \n      ssResidual += Math.pow(residual, 2);\n    }\n    \n    residuals.selectAll(\"line\")\n        .attr(\"y2\", d =&gt; y(d.yHat))\n        \n    squares.selectAll(\"polygon\")\n      .attr(\"points\", d =&gt; [[x(d.xVal), y(d.yVal)],\n                            [x(d.xVal), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yVal)]])\n                            \n    const squareSize = x(Math.sqrt(ssResidual)) - x(0);\n    ssResidualSquare\n    .attr(\"points\", [[0, 0],\n                     [0, squareSize],\n                     [squareSize, squareSize],\n                     [squareSize, 0]])\n    \n    ssResidualLabel\n    .attr(\"y\", squareSize + 15)\n  }\n  \n  drawFitLine();\n  \n  // this is the dashed outline of the minimum SSresidual\n  const lseSquareSize = x(Math.sqrt(6.5)) - x(0);\n  sumSquaresPlot.append(\"polygon\")\n    .attr(\"points\", [[0, 0],\n                     [0, lseSquareSize],\n                     [lseSquareSize, lseSquareSize],\n                     [lseSquareSize, 0]])\n    .style(\"fill\", \"none\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-dasharray\", [5, 3])\n    \n    sumSquaresPlot.append(\"text\")\n      .text(\"LSE solution\")\n      .attr(\"x\", 0)\n      .attr(\"y\", -5)\n      .style(\"font-size\", \"0.8em\")\n  \n}"
  },
  {
    "objectID": "visualizations/sampling/sampling.html",
    "href": "visualizations/sampling/sampling.html",
    "title": "Sampling",
    "section": "",
    "text": "Distribution:  Normal Positive skew Negative skew Uniform Custom  Sample size:  Reset\n\n\n\n\n\n\nTake a sample\n\n\nStart\n\n\nStop\n\n\n+1,000\n\n\n+10,000\n\n\n+100,000\n\n\nclear\n\n\n\n\n\nimport {sampling} from \"./sampling-backend.qmd\""
  },
  {
    "objectID": "visualizations/mean-balance-beam/balance.html#about",
    "href": "visualizations/mean-balance-beam/balance.html#about",
    "title": "Central Tendency",
    "section": "About",
    "text": "About\nThe arithmetic mean is one of the most familiar statistics. It is found by summing a set of scores and dividing the sum by the number of scores.1 The mean is a summary of the data, conveying the â€˜central tendencyâ€™. I find it useful to think about the mean in mechanical terms, as the balance point of a distribution. Each data point deviates to some extent from the mean. The mean is the point at which these deviations are in balance; the (absolute) sum of deviations below the mean will be equal to the sum of deviations above the mean.\nRunning with the mechanical metaphor, it should be clear that if the mean was any other value, the scales would not be in balance; the deviations above and below the mean would not be equal and the scale would tip over. In the visualization above, you can drag the triangle to see the effect of arbitrarly changing the value of the mean.\nChanging any data point would also affect the deviations. Try dragging a box around to see how its deviation changes, and how the resulting change to the sum of deviations affects the balance of the scale.\nLikewise, adding or removing any data point would change the sum of deviations above or below the mean, knocking them out of balance and tipping the scales. You can click a blank spot to add a new data point, or click an existing point to remove it. The only exception is adding or removing a data point which is exactly equal to the mean. Since the deviation of a point equal to the mean is zero, adding or removing it will have no effect on the sum of deviations, and therefore wonâ€™t tip the scales off balance."
  },
  {
    "objectID": "visualizations/mean-balance-beam/balance.html#footnotes",
    "href": "visualizations/mean-balance-beam/balance.html#footnotes",
    "title": "Central Tendency",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n\\(M = \\dfrac{\\Sigma X}{N}\\)â†©ï¸Ž"
  },
  {
    "objectID": "visualizations/correlation.html",
    "href": "visualizations/correlation.html",
    "title": "Correlation",
    "section": "",
    "text": "Strength of correlation\n\n-1  1\n\n\n Show deviation lines\n\n\n Show deviation rectangles\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\nchart = {\n\nconst width = 500\nconst height = 400\n\n\nconst xScale = d3.scaleLinear()\n  .domain([-0.1, 1.1])\n  .range([0, width])\nlet yScale = d3.scaleLinear()\n  .domain([0, 1])\n  .range([height, 0])\n\n\n  \nconst svg = d3.select(\"#container\").append(\"svg\")\n  .attr(\"width\", width)\n  .attr(\"height\", height)\n  \nconst meanLines = svg.append(\"g\")\nconst axisLines = svg.append(\"g\")\n\naxisLines.append(\"line\")\n  .attr(\"class\", \"axis-line\")\n  .attr(\"x1\", 1).attr(\"x2\", width)\n  .attr(\"y1\", height - 1).attr(\"y2\", height - 1)\n  .style(\"stroke\", \"black\")\naxisLines.append(\"line\")\n  .attr(\"class\", \"axis-line\")\n  .attr(\"x1\", 1).attr(\"x2\", 1)\n  .attr(\"y1\", height - 1).attr(\"y2\", 1)\n  .style(\"stroke\", \"black\")\n\n// variables for viz options\nlet showRectangles = true;\nlet showDeviationLines = true;\n\n// inputs for viz options\nconst rInput = d3.select(\"#target-r\");\nconst rectanglesToggle = d3.select(\"#show-rectangles\");\nconst deviationLinesToggle = d3.select(\"#show-deviation-lines\");\n\nrInput.on(\"input\", () =&gt; updateChart(rInput.property(\"value\")));\n\nrectanglesToggle.on(\"change\", function() {\n  showRectangles = this.checked;\n  updateChart(rInput.property(\"value\"));\n});\n\ndeviationLinesToggle.on(\"change\", function() {\n  showDeviationLines = this.checked;\n  updateChart(rInput.property(\"value\"));\n});\n\nlet data = makeInitialData(10);\n  \n\n\nfunction makeInitialData(n) {\n    let arr = [];\n    for (var i = 0; i &lt; n; i++) {\n        var A = Math.random();\n        var B = Math.random();\n        arr.push({xVal: A, y0: B});\n    }\n\n    let xMin = Math.min(...arr.map(obj =&gt; obj.xVal));\n    let xMax = Math.max(...arr.map(obj =&gt; obj.xVal));\n    \n    // Normalize the x-values to the range 0 to 1.\n    for (let i = 0; i &lt; arr.length; i++) {\n        arr[i].xVal = (arr[i].xVal - xMin) / (xMax - xMin);\n    }\n    \n    let meanX = jStat.mean(arr.map(obj =&gt; obj.xVal));\n    \n    // Adjust x-values to have a mean of 0.5.\n    const desiredMeanX = 0.5;\n    for (let i = 0; i &lt; arr.length; i++) {\n        arr[i].xVal = arr[i].xVal - meanX + desiredMeanX;\n    }\n\n    return arr;\n}\n\nfunction computeYValue(x, y, r) {\n return x * r + y * Math.pow(1 - Math.pow(r, 2), 0.5);\n}\n\n\nfunction updateChart(targetR) {\n  \n  let newData = [];\n  \n  for (let i = 0; i &lt; data.length; i++) {\n    newData.push({\n      xVal: data[i].xVal,\n      yVal: computeYValue(data[i].xVal, data[i].y0, targetR)\n    });\n  }\n  \n  let yLimits = [\n    -0.1, 1.1\n  ];\n\n  let yMin = Math.min(...newData.map(obj =&gt; obj.yVal));\n  let yMax = Math.max(...newData.map(obj =&gt; obj.yVal));\n  \n  // Normalize the y-values to the range 0 to 1.\n  for (let i = 0; i &lt; newData.length; i++) {\n    newData[i].yVal = (newData[i].yVal - yMin) / (yMax - yMin);\n  }\n  \n  let meanY_ = jStat.mean(newData.map(obj =&gt; obj.yVal));\n  \n  // Adjust y-values to have a mean of 0.5.\n  const desiredMeanY = 0.5;\n  for (let i = 0; i &lt; newData.length; i++) {\n    newData[i].yVal = newData[i].yVal - meanY_ + desiredMeanY;\n    &lt;!-- newData[i].yVal = Math.max(0, Math.min(1, newData[i].yVal)); --&gt;\n  }\n  \n  \n  yScale.domain(yLimits);\n  &lt;!-- yScale.domain(yLimits); --&gt;\n  \n  svg.selectAll(\"circle\").remove()\n  svg.selectAll(\"circle\").data(newData).enter().append(\"circle\")\n    .attr(\"cx\", d =&gt; xScale(d.xVal))\n    .attr(\"r\", 5)\n    .attr(\"cy\", d =&gt; yScale(d.yVal));\n    \n  let xArr = newData.map(obj =&gt; obj.xVal);\n  let yArr = newData.map(obj =&gt; obj.yVal);\n  \n  let meanX = jStat.mean(xArr);\n  let meanY = jStat.mean(yArr);\n  \n  meanLines.selectAll(\"line\").remove()\n  meanLines.append(\"line\")\n    .attr(\"x1\", xScale(0)).attr(\"x2\", xScale(1))\n    .attr(\"y1\", yScale(meanY)).attr(\"y2\", yScale(meanY))\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", 2)\n    .attr(\"stroke-dasharray\", [5,5])\n  meanLines.append(\"line\")\n    .attr(\"x1\", xScale(meanX)).attr(\"x2\", xScale(meanX))\n    .attr(\"y1\", yScale(yLimits[0] + 0.1)).attr(\"y2\", yScale(yLimits[1] - 0.1))\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", 2)\n    .attr(\"stroke-dasharray\", [5,5])\n    \n  drawDeviationPolygons(meanX, meanY, yLimits);\n  \n  let actualR = jStat.corrcoeff(xArr, yArr);\n  console.log(\"target r: \" + targetR);\n  console.log(\"actual r: \" + actualR);\n  \n}\n\n// Step 1: Add new state variable to track if deviation lines are shown\nfunction drawDeviationPolygons(meanX, meanY, yLimits) {\n    // Clear previous polygons and lines\n    meanLines.selectAll(\"polygon\").remove();\n    meanLines.selectAll(\".deviation-line\").remove();\n    \n    // Get all circles (data points)\n    svg.selectAll(\"circle\").each(function(d) {\n        const point = d3.select(this);\n        const x = +point.attr(\"cx\");\n        const y = +point.attr(\"cy\");\n        \n        // Calculate deviations\n        const xDeviation = d.xVal - meanX;\n        const yDeviation = d.yVal - meanY;\n        const sameDirection = (xDeviation * yDeviation) &gt; 0;\n        \n        // Determine colors based on deviation directions\n        const xDeviationColor = xDeviation &gt; 0 ? \"green\" : \"red\";\n        const yDeviationColor = yDeviation &gt; 0 ? \"green\" : \"red\";\n        \n        // Draw deviation lines only if the toggle is checked\n        if (showDeviationLines) {\n            // Draw X deviation line\n            meanLines.append(\"line\")\n                .attr(\"class\", \"deviation-line\")\n                .attr(\"x1\", x)\n                .attr(\"x2\", xScale(meanX))\n                .attr(\"y1\", y)\n                .attr(\"y2\", y)\n                .attr(\"stroke\", xDeviationColor)\n                .attr(\"stroke-width\", 1)\n                .attr(\"stroke-dasharray\", \"2,2\");\n                \n            // Draw Y deviation line\n            meanLines.append(\"line\")\n                .attr(\"class\", \"deviation-line\")\n                .attr(\"x1\", x)\n                .attr(\"x2\", x)\n                .attr(\"y1\", y)\n                .attr(\"y2\", yScale(meanY))\n                .attr(\"stroke\", yDeviationColor)\n                .attr(\"stroke-width\", 1)\n                .attr(\"stroke-dasharray\", \"2,2\");\n        }\n            \n        // Only create rectangles if toggle is checked\n        if (showRectangles) {\n          svg.selectAll(\".deviation-line\")\n            .attr(\"stroke\", \"grey\")\n            meanLines.append(\"polygon\")\n                .attr(\"points\", [\n                    [x, y],\n                    [x, yScale(meanY)],\n                    [xScale(meanX), yScale(meanY)],\n                    [xScale(meanX), y]\n                ])\n                .attr(\"fill\", sameDirection ? \"green\" : \"red\")\n                .attr(\"opacity\", 0.1);\n        }\n    });\n    \n    // Keep the mean lines\n    meanLines.append(\"line\")\n        .attr(\"x1\", xScale(0))\n        .attr(\"x2\", xScale(1))\n        .attr(\"y1\", yScale(meanY))\n        .attr(\"y2\", yScale(meanY))\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"5,5\");\n        \n    meanLines.append(\"line\")\n        .attr(\"x1\", xScale(meanX))\n        .attr(\"x2\", xScale(meanX))\n        .attr(\"y1\", yScale(yLimits[0] + 0.1))\n        .attr(\"y2\", yScale(yLimits[1] - 0.1))\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", \"5,5\");\n}\n\nupdateChart(rInput.property(\"value\"));\n\n}"
  },
  {
    "objectID": "visualizations/anova/anova.html",
    "href": "visualizations/anova/anova.html",
    "title": "Visualizing ANOVA",
    "section": "",
    "text": "\\(.\\)\n\n\n\nSomething something sums of squares something something."
  },
  {
    "objectID": "visualizations/anova/anova.html#about",
    "href": "visualizations/anova/anova.html#about",
    "title": "Visualizing ANOVA",
    "section": "",
    "text": "Something something sums of squares something something."
  },
  {
    "objectID": "games/triplett/triplett.html",
    "href": "games/triplett/triplett.html",
    "title": "Psych Stats",
    "section": "",
    "text": "practice\n\n\nrace alone\n\n\nrace together\n\n\nAbout\n\n\n\nCompetition Machine â€”\n\n\n\n\nâ”˜\n\n\nðŸ\n\n\nðŸš©\n\n\n\n\nâ”˜\n\n\nðŸ\n\n\nðŸš©\n\n\n\n\nYour time: 0.00\n\n\nReset\n\n\n\n\nClick the â€˜handleâ€™ to the left of the â€˜trackâ€™ to start.\n\n\nKeep clicking as fast as you can until your flag reaches the end.\n\n\nClick Race Alone to do a timed race by yourself.\n\n\nClick Race Together to race against a competitor.\n\n\n\n\n\n\n\n\n\n\n\n\nðŸ‘‘ Records ðŸ‘‘\n\n\nPrevious\n\n\nBest\n\n\n\n\nðŸš© Alone\n\n\n-\n\n\n-\n\n\n\n\nðŸš©ðŸš©Competition\n\n\n-\n\n\n-\n\n\n\n\n\ngame = {\n    var start, myTimer, myTurner;\nvar sec = d3.select(\"#seconds\")\nvar cli = d3.select(\"#clicks\")\nvar flag = d3.select(\"#flag\")\nvar flag2 = d3.select(\"#flag2\")\nvar clicks = 0;\nvar state;\nconst target_clicks = 80;\nvar mode = practice;\n\nvar records = [{prev: 0, best: 0},{prev: 0, best: 0}]\n\nvar handleState = 0;\nconst handle = d3.select(\"#handle-text\");\nconst handle2 = d3.select(\"#handle2-text\");\nconst handleText = [\"â”˜\",\"â””\"]\n\nd3.select(\"#handle1\").on(\"click\", clicked);\nd3.select(\"#practice-button\").on(\"click\", practice);\nd3.select(\"#alone-button\").on(\"click\", alone);\nd3.select(\"#competition-button\").on(\"click\", competition);\nd3.select(\"#reset-button\").on(\"click\", reset);\n\nfunction handleClicked() {\n    handleState++;\n    handle.text(handleText[handleState % 2]);\n}\n\nfunction turnHandle2() {\n    var handle2State = 0;\n    myTurner = setInterval( function(){\n        handle2State++;\n        handle2.text(handleText[handle2State % 2]);\n        if (handle2State &gt; target_clicks) clearInterval(myTurner);\n    }, 10000 / target_clicks);\n}\n\nfunction clicked() {\n    handleClicked();\n    \n    if (clicks==0) {startTimer(); turnHandle2();}\n    if (clicks &lt; target_clicks) {\n        clicks++;\n    cli.text(clicks);\n    flag.transition().duration(300).style(\"left\", `${clicks*(100/target_clicks)*1.00}%`);\n    } \n    if (clicks == target_clicks) stopTimer();\n}\n\nfunction startTimer() {\n    start = Date.now();\n    myTimer= setInterval( function(){\n        var delta = Date.now() - start; // milliseconds elapsed since start\n        sec.html(delta / 1000);\n    }, 10);\n\n    flag2.transition().ease(d3.easeLinear).duration(10000).style(\"left\", \"100%\")\n}\n\nfunction stopTimer() {\n    clearInterval(myTimer);\n\n    var time = Number(sec.html());\n\n    if(state!=\"practice\") {\n        d3.select(\"#\" + state + \"-previous\").text(time);\n\n        var previousBest = Number(d3.select(\"#\" + state + \"-best\").text());\n        if(isNaN(previousBest)) d3.select(\"#\" + state + \"-best\").text(time);\n        else if (time &lt; previousBest) d3.select(\"#\" + state + \"-best\").text(time);\n    }\n}\n\n// function updateTable(time, cell) {\n//     d3.select(cell).text(time);\n// }\n\nfunction practice() {\n    state = \"practice\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#practice-button\").classed(\"selected\", true);\n    // d3.select(\"#practice\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#time\").style(\"display\", \"none\");\n}\n\nfunction alone() {\n    state = \"alone\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#alone-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction competition() {\n    state = \"competition\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#competition-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction reset() {\n    clearInterval(myTimer);\n    clearInterval(myTurner);\n    sec.text(\"0.00\");\n    cli.text(0);\n    flag.transition().duration(1000).style(\"left\", \"0%\");\n    flag2.transition().duration(1000).style(\"left\", \"0%\");\n    clicks = 0;\n}\n\npractice();\n}"
  }
]