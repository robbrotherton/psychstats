[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nRegression: The Least Squared Error Method\nConfidence Intervals"
  },
  {
    "objectID": "index.html#visualizations",
    "href": "index.html#visualizations",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nRegression: The Least Squared Error Method\nConfidence Intervals"
  },
  {
    "objectID": "index.html#games",
    "href": "index.html#games",
    "title": "PSYCH STATS",
    "section": "Games",
    "text": "Games\nSome ‘games’ (I’m using the term loosely!) that I use to illustrate statistical concepts or generate data for analysis.\nGuess the Correlation\nTriplett\nJellybeans\nQuincunx\nDice Roller\n\nbannerImage = {\n\n    const svg = d3.select(\".quarto-title\").append(\"svg\")\n        .attr(\"id\", \"title-svg\")\n        .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n        .attr(\"viewBox\", \"0 0 \" + 50 + \" \" + 20)\n\n    svg.selectAll(\"circle\").data(data).enter().append(\"circle\")\n        .attr(\"cx\", d =&gt; d.x)\n        .attr(\"cy\", d =&gt; 20 - d.y)\n        .attr(\"r\", 0)\n        .attr(\"stroke\", \"none\")\n        .attr(\"fill\", (d, i) =&gt; d3.schemeCategory10[i % 10])\n        .transition().duration(300)\n        .delay(d =&gt; d.y * 100)\n        .attr(\"r\", radius/2)\n\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is the personal website of Rob Brotherton. I’m an academic psychologist and writer. I teach statistics and political psychology at Barnard College in New York City.\n\n\nThis site collects together some of the visualizations and games I’ve made as part of my statistics course. Statistics, at its core, is about understanding the patterns and principles that govern our world, and it’s much more than just a set of abstract equations. To help bring this vision to life, I created an array of interactive visualizations and games. Rather than just learning about a statistical concept like the Central Limit Theorem, these help you to experience it in action, to see the narratives that numbers can create. My hope is to bridge the gap between abstract equations and hypothetical distributions on one hand, and on the other hand, the real, messy processes that somehow produce those predictable patterns. Seeing these basic processes in action goes a long way towards understanding how statistical stories play out in our day-to-day lives.\nThe design philosophy is grounded in the notion that statistics is a tactile, organic, and sometimes messy process. I consciously avoid the conventional abstract approach to teaching statistics. The visualizations I use show statistical populations not as abstract curves, but as hundreds of individual dots piled up into a normal (or not-so-normal) distribution. When you draw a sample from these populations, you can see and interact with the specific dots that have been selected. This is designed to instill a sense of the concrete nature of statistics, reinforcing that behind every data point, there is a story, a reality.\nThis approach to bringing statistics to life is embodied in my choice of visual design. The website is crafted in bright colors and a ‘sketchy’ bootstrap theme that harks back to a time of hand-drawn graphs and chalkboard equations. The intention is to remind users that what they are interacting with is not a dry, abstract mathematical concept, but a dynamic process that reflects the vibrant, sometimes chaotic reality of our world. It’s about more than numbers – it’s about people, processes, and the fascinating patterns that tie it all together."
  },
  {
    "objectID": "visualizations/unbiased-estimates.html",
    "href": "visualizations/unbiased-estimates.html",
    "title": "(Un)Biased estimates",
    "section": "",
    "text": "Show: \\(M\\) \\(SD_{n}\\) \\(SD_{n - 1}\\)\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\nw = 800\nh = 400\n\nmaxWidth = 900;\nmaxHeight = 550;\n\ntimeseriesVertical = false;\n\npanelSpacing = 5;\n\npopulationPanelWidth = maxWidth * 0.6;\npopulationPanelHeight = maxHeight;\n\npopulationSubPanelProportion = 0.4;\nsampleSubPanelProportion = 0.05;\n\nestimatesSubPanelProportion = 0.55;\n\nestimatesPanelWidth = maxWidth - populationPanelWidth;\nestimatesPanelHeight = populationPanelHeight;\n\ntimeSeriesPanelWidth = maxWidth - populationPanelWidth;\n\n\n\nradius = 4; //1.4\nsampleSize = 5;\n\n    \nxScalePopulation = d3.scaleLinear()\n    .domain([-4, 4])\n    .range([0 + radius, (populationPanelWidth) - radius])\nyScalePopulation = d3.scaleLinear()\n    .domain([0, 300])\n    .range([populationPanelHeight * populationSubPanelProportion, 0])\n\nxScaleEstimates = d3.scaleLinear()\n    .domain([-1.25, 1.25])\n    .range([0, estimatesPanelWidth])\n    \nyScaleEstimates = d3.scaleLinear()\n    .domain([20, 0])\n    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])\n\nxAxisEstimatesValues = [-2, -1, 0, 1, 2];\nxAxisEstimates = d3.axisBottom(xScalePopulation)\n  .tickValues(xAxisEstimatesValues)\n  .tickFormat(d =&gt; d)\n  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nupdate_svg = {\n\n  var sample = [];\n  var sampleData = [];\n  var sample_estimates = [];\n  var running_averages = [{param: \"population\", value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n  \n  var nSamplesDrawn = 0;\n  \n  var legendSelected = [\"sample\", \"population\"]\n  \n  var timeX, timeY, biasLine, timeXAxis, timeYAxis;\n  var timeSvg, \n  timeScaleBias, \n  timeScaleId, \n  timeBiasAxis, \n  timeIdAxis, \n  timeseriesDataLayer,\n  timeseriesBiasAxisLayer,\n  timeseriesIdAxisLayer;\n\n  let isLargeScreen;\n\n  function newSample() {\n    \n    nSamplesDrawn++\n    \n    // pick random observations from the population by their index\n    for (var i = 0; i &lt; sampleSize; i++) {\n      let randomIndex = Math.floor(Math.random() * popData.length);\n      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);\n      sampleData[i] = popData[randomIndex];\n    }\n    \n    var estimates = getSampleEstimates(sample)\n    estimates.map(d =&gt; d.id = nSamplesDrawn);\n    sample_estimates.push(estimates)\n    \n    updateRunningAverages(estimates);\n    updateBiasChart();\n    updateSampleCircles();\n    animateEstimates(sampleData, estimates);\n    updatePath();\n    updateVisibility();\n  }\n  \n  function updateBiasChart() {\n      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])\n      \n      biasDots.selectAll(\"path\").remove()\n      biasDots.selectAll(\"path\")\n          .data(sample_estimates.flat())\n          .enter()\n          .append(\"path\")\n            .attr(\"id\", d =&gt; d.param + \"-estimate\")\n            .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)\n            .attr(\"opacity\", d =&gt; (d.id === nSamplesDrawn ? 0 : 1))\n            .transition()\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)\n            \n  }\n  \n\n  \n  function updateSampleCircles() {\n  \n  let durationMultiplier = 5;\n  if (playing) durationMultiplier = 1;\n  \n    sampleCircles.selectAll('circle').remove()\n    sampleCircles.selectAll('circle')\n      .data(sampleData)\n      .enter().append(\"circle\")\n      .attr(\"class\", \"sample\")\n      .attr(\"r\", radius)\n      .attr(\"cx\", d =&gt; d.cx)\n      .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n      .attr(\"fill\", d =&gt; d.fill)\n      .transition()\n      .duration(d =&gt; d.cy * durationMultiplier)\n      .ease(d3.easeBounceOut)\n      .attr(\"cy\", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)\n  }\n  \n  \n  \n  function animateEstimates(sampleData, estimates) {\n  \n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    \n    var wait = Math.max(...sampleData.map(z =&gt; z.cy));\n    \n    for (let i = 0; i &lt; estimates.length; i++) {\n\n    var p = estimates[i].param;\n    var endPosition = estimates[i].value;\n    var dur = (playing ? 0 : 1000);\n    var convergeWait = (playing ? 0 : wait * 5);\n    var moveDownWait = (playing ? 250 : 0);\n    \n    sampleData.forEach((s) =&gt; {\n    \n    // first, place estimate symbols where each sample dot lands\n      sampleEstimatesTemp\n      .append(\"path\")\n      .attr(\"id\", p + \"-estimate\")\n      .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n        .attr(\"transform\", d =&gt; `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        .attr(\"opacity\", 0)\n        \n    // then move them all to the estimate\n        .transition().duration(dur * 0.67).delay(convergeWait)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", d =&gt; `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        \n    // then move them down to the estimates tracker\n    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)\n      .ease(d3.easeCubicOut)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)\n    })\n\n    }\n  }\n  \n  const sleep = (milliseconds) =&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, milliseconds))\n  }\n  var playing = false;\n  function playButtonClicked() {\n    \n    playing = !playing; \n  \n  play_button.text(function(){\n    if(playing) {\n      return \"◼\"\n  } else {\n    return \"▶\"\n  }\n  })\n  \n  if (playing) {\n    continuouslyDrawSamples();\n  }\n  }\n  \n  function continuouslyDrawSamples() {\n    if (playing) {\n      newSample();\n      sleep(200).then(continuouslyDrawSamples);\n    }\n  }\n  \n    \n  var popData = [];\n  const color = d3.scaleOrdinal(d3.schemeCategory10);\n  for (let i = 0; i &lt; population.length; ++i) {\n    const cx = xScalePopulation(population[i]);\n    const cy = 10 + (dodge(cx) - radius - 1);\n    &lt;!-- const cy = yScalePopulation(dodge(cx)); --&gt;\n    const fill = color(i % 10);\n    popData.push({cx, cy, fill})\n  }\n  \n  \n  \n  const populationLabels = [{label: \"Population\", top: 0},\n                            {label: \"Sample\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion) * 100},\n                            {label: \"Under/over-&lt;/br&gt;estimation of&lt;/br&gt;parameter\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion + sampleSubPanelProportion) * 100}]\n  \n  const populationContainer = d3.select(\"#population-container\")\n    .style(\"position\", \"relative\")\n    &lt;!-- .style(\"height\", maxHeight) --&gt;\n    \n    // panel labels\n  populationContainer.selectAll(\"text\").data(populationLabels).enter()\n    .append(\"text\")\n    .style(\"position\", \"absolute\")\n    .html(d =&gt; d.label)\n    .style(\"top\", d =&gt; d.top + \"%\")\n    .style(\"line-height\", \"1em\")\n\n  const populationAndSampleSvg = d3.select(\"#population-container\")\n    .append(\"svg\").attr(\"id\", \"populationAndSample-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + (populationPanelWidth) + \" \" + populationPanelHeight)\n    \n    // panel backgrounds\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight * populationSubPanelProportion)\n    .attr(\"fill\", \"var(--population-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * populationSubPanelProportion)\n    .attr(\"height\", populationPanelHeight * sampleSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--sample-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * (1 - estimatesSubPanelProportion))\n    .attr(\"height\", populationPanelHeight * estimatesSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n    \n\n    \n  const pop = populationAndSampleSvg.append(\"g\")\n  const parameters = populationAndSampleSvg.append(\"g\")\n  const sampleEstimates = populationAndSampleSvg.append(\"g\")\n  const sampleEstimatesTemp = populationAndSampleSvg.append(\"g\")\n  const sampleCircles = populationAndSampleSvg.append(\"g\")\n\n  const biasDots  = sampleEstimates.append(\"g\")\n  \n  pop.selectAll(\"circle\")\n      .data(popData)\n      .enter()\n      .append(\"circle\")\n        .attr(\"class\", \"pop\")\n        .attr(\"cx\", d =&gt; d.cx)\n        .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n        .attr(\"r\", radius)\n        .attr(\"fill\", d =&gt; d.fill)\n        \n    // estimates axis\n    \n  const estimatesAxis = sampleEstimates.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScaleEstimates(21)})`)\n  \n  estimatesAxis.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight - yScaleEstimates(21))\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n  estimatesAxis.call(xAxisEstimates)\n  estimatesAxis.select(\".domain\").remove()\n  \n\n\n  \n  formatAxes(estimatesAxis.selectAll(\"line\"));\n  \n    \n  var legendStatus = [{param: \"mean\",       hide: true},\n                      {param: \"population\", hide: false},\n                      {param: \"sample\",     hide: false}]\n                      \n  \n  function updateLegendStatus(param) {\n    var index;\n    if (param===\"mean\") {index = 0;}\n    if (param===\"population\") {index = 1;}\n    if (param===\"sample\") {index = 2;}\n    legendStatus[index].hide = !legendStatus[index].hide\n\n    var classes = \"#\" + param + \"-estimate\"\n    \n    populationAndSampleSvg.selectAll(classes).classed(\"hide\", legendStatus[index].hide)\n    timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[index].hide)\n    legend.classed(\"unselected\", d =&gt; d.hide)\n  }\n  \n    const legend = d3.selectAll(\".selector\")\n    legend\n      .data(legendStatus)\n      .classed(\"unselected\", d =&gt; d.hide)\n      .on(\"click\", function(event, d){updateLegendStatus(d.param);})\n  \n\n\n  \n  // buttons\n  const controls = d3.select(\"#controls-container\")\n  \n  const reset_button = controls.append(\"button\")\n    // .attr(\"class\", \"button invertable\")\n    // .attr(\"type\", \"button\")\n    .text(\"Reset\")\n    .on(\"click\", clearData)\n  \n  const button = controls.append(\"button\")\n    .text(\"Take one sample\")\n    .on(\"click\", newSample)\n    \n  const play_button = controls.append(\"button\")\n    .attr(\"id\", \"play-button\")\n    // .attr(\"class\", \"button invertable\")\n    .attr(\"x\", 50)\n    .attr(\"y\", h - 50)\n    .html(\"►\")\n    .on(\"click\", playButtonClicked)\n    \n\n\n// make timeseries chart\nconst timeChart = {\n    width: timeSeriesPanelWidth,\n    height: maxHeight,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\nconst timeChartHorizontal = {\n    width: populationPanelWidth,\n    height: 300,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\n  const timeseriesContainer = d3.select(\"#timeline-container\");\n  timeseriesContainer.style(\"position\", \"relative\")\n\n  updateTimeseriesDimensions(window.innerWidth);\n\n  // Re-render the chart whenever the window size changes\n  window.addEventListener(\"resize\", () =&gt; updateTimeseriesDimensions(window.innerWidth)); \n\n\n\n  function updateTimeseriesDimensions(winWidth) {\n\n    const largeScreen = winWidth &gt; 600;\n    if (largeScreen === isLargeScreen) return;\n    // Update the screen state\n    isLargeScreen = largeScreen;\n    \n  var params;\n  var orientation = (winWidth &gt; 600) ? \"vertical\" : \"horizontal;\"\n\n  console.log(orientation);\n\n  // first, set up chart dimensions and axes\n  if (winWidth &gt; 600) {\n\n    params = timeChart;\n\n    timeScaleBias = d3.scaleLinear()\n      .domain([-0.5, 0.5])\n      .range([params.margin.left, params.width - params.margin.right])\n    timeScaleId = d3.scaleLinear()\n      .domain([0, 200])\n      .range([params.margin.top, params.height - params.margin.bottom])\n    biasLine = function(x, y){\n        return d3.line()\n        .x(function(d,i) { return timeScaleBias(x[i]); })\n        .y(function(d,i) { return timeScaleId(y[i]); })\n        (Array(x.length));\n    }\n    timeBiasAxis = d3.axisTop(timeScaleBias)\n      .ticks(5)\n      .tickSize(-(params.height - params.margin.top - params.margin.bottom)) // 440\n    timeIdAxis = d3.axisRight(timeScaleId).tickSize(0)\n  } else {\n\n      params = timeChartHorizontal;\n\n      timeScaleBias = d3.scaleLinear()\n        .domain([-0.5, 0.5])\n        .range([params.height - params.margin.bottom, params.margin.top])\n        \n      timeScaleId = d3.scaleLinear()\n        .domain([0, 200])\n        .range([params.margin.left, params.width - params.margin.right])\n      biasLine = function(x, y){\n          return d3.line()\n          .x(function(d,i) { return timeScaleId(y[i]); })\n          .y(function(d,i) { return timeScaleBias(x[i]); })\n          (Array(x.length));\n      }\n    timeIdAxis = d3.axisBottom(timeScaleId)\n      .tickSize(0)\n    timeBiasAxis = d3.axisLeft(timeScaleBias)\n      .ticks(5).tickSize(-params.width - params.margin.left - params.margin.right)\n  }\n\n  // then instantiate the chart svg itself\n  d3.select(\"#timeline-container\").select(\"svg\").remove();\n  d3.select(\"#timeline-container\").selectAll(\"text\").remove();\n  timeSvg = makeTimeseriesChart(params);\n  timeseriesDataLayer = timeSvg.append(\"g\");\n  timeseriesBiasAxisLayer = timeSvg.append(\"g\");\n  timeseriesIdAxisLayer = timeSvg.append(\"g\");\n\n  // then place the axes\n  positionTimeAxes(orientation, params);\n\n  // then draw the current data\n  updatePath();\n}\n\n  \n\n  \n  function makeTimeseriesChart(params) {\n    \n    // text labels\n    timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .text(\"Average under/over-estimation\")\n  \n  timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"line-height\", \"1em\")\n    .style(\"bottom\", 0)\n    .style(\"right\", 0)\n    .style(\"text-align\", \"right\")\n    .html(\"Total&lt;br&gt;samples\")\n    \n    const svg = d3.select(\"#timeline-container\")\n    .append(\"svg\").attr(\"id\", \"timeline-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + params.width + \" \" + params.height)\n    \n    // background panel\n  svg.append(\"rect\")\n    .attr(\"width\", params.width)\n    .attr(\"height\", params.height)\n    .attr(\"rx\", 5)\n    .attr(\"fill\", \"var(--timeseries-panel-background)\")\n    \n    return svg;\n    \n  }\n  \n  \n  function positionTimeAxes(orientation, params) {\n    if (orientation === \"vertical\") {\n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(0, ${params.margin.top})`)\n\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"width\", params.width)\n        .attr(\"y\", -params.margin.top)\n        .attr(\"height\", params.margin.top)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n\n        timeseriesIdAxisLayer.attr(\"transform\", `translate(${params.width - params.margin.right}, 0)`)\n  \n    } else {\n      timeseriesIdAxisLayer.attr(\"transform\", `translate(0, ${params.height - params.margin.bottom})`)\n\n      // todo: this isn't positioned correctly\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"x\", -params.margin.left)\n        .attr(\"width\", params.margin.left)\n        .attr(\"height\", params.height)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n      \n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(${params.margin.left}, 0)`)\n        \n      \n    }\n    timeseriesIdAxisLayer.call(timeIdAxis)\n    timeseriesBiasAxisLayer.call(timeBiasAxis);\n    timeseriesBiasAxisLayer.select(\".domain\").remove();\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    formatAxes(timeSvg.selectAll(\"line\"));\n    \n    timeSvg.selectAll(\"line\").classed(\"dark\", true)\n  }\n  \n  \n  function updatePath() {\n      timeseriesDataLayer.selectAll(\"g\").remove()\n      \n      if (nSamplesDrawn &gt; 201) {\n        timeScaleId.domain([nSamplesDrawn - 200, nSamplesDrawn]);\n        // timeIdAxis = d3.axisRight(timeScaleId).tickSize(0);\n        timeseriesIdAxisLayer.call(timeIdAxis);\n        timeseriesIdAxisLayer.select(\".domain\").remove();\n      }\n      \n      timeseriesDataLayer.selectAll(\"g\")\n        .data(running_averages)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"bias-paths\")\n        .append(\"path\")\n          .attr(\"d\", d =&gt; biasLine(d.value.slice(1), d.id.slice(1)))\n          .attr(\"id\", d =&gt; d.param + \"-path\")\n\n  }\n  \n\n\nfunction clearData() {\n    sample = [];\n    sample_estimates = [];\n    running_averages = [{param: \"population\",   value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n    nSamplesDrawn = 0;\n    \n    timeScaleId.domain([0, 200]);\n    timeseriesIdAxisLayer.call(timeIdAxis);\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    sampleCircles.selectAll('circle').remove()\n    sampleEstimates.selectAll(\"path\").remove()\n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    timeseriesDataLayer.selectAll(\"path\").remove()\n  }\n  \n  function updateRunningAverages(estimates) {\n  \n      var cur_n = nSamplesDrawn\n      var prev_n = cur_n - 1\n      \n      var old = running_averages[0].value[prev_n]\n      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n\n      running_averages[0].value.push(new_pop)\n      \n      var old = running_averages[1].value[prev_n]\n      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n\n      running_averages[1].value.push(new_sam)\n      \n      var old = running_averages[2].value[prev_n]\n      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n\n      running_averages[2].value.push(new_mea)\n    \n      running_averages[0].id.push(cur_n)\n      running_averages[1].id.push(cur_n)\n      running_averages[2].id.push(cur_n)\n\n}\n\n  function updateVisibility() {\n  \n    var params = [\"mean\", \"population\", \"sample\"]\n    \n    for (var i = 0; i &lt; 3; i++) {\n      var param = params[i]\n      var elementIds = \"#\" + param + \"-estimate, #\" + param + \"-line\"\n      \n      populationAndSampleSvg.selectAll(elementIds).classed(\"hide\", legendStatus[i].hide)\n      &lt;!-- populationAndSampleSvg.selectAll(\"#\" + param + \"-estimate\").classed(\"hide\", legendStatus[i].hide) --&gt;\n      timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[i].hide)\n    }\n  }\n  \n}\n\n\n\n\n\n\n\ndodger = radius =&gt; {\n  const radius2 = radius ** 1.9;\n  const bisect = d3.bisector(d =&gt; d.x);\n  const circles = [];\n  return x =&gt; {\n    const l = bisect.left(circles, x - radius);\n    const r = bisect.right(circles, x + radius, l);\n    let y = 0;\n    for (let i = l; i &lt; r; ++i) {\n      const { x: xi, y: yi } = circles[i];\n      const x2 = (xi - x) ** 2;\n      const y2 = (yi - y) ** 2;\n      if (radius2 &gt; x2 + y2) {\n        y = yi + Math.sqrt(radius2 - x2) + 1e-6;\n        i = l - 1;\n        continue;\n      }\n    }\n    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });\n    &lt;!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) --&gt;\n    return y;\n  };\n}\n\ndodge = dodger(radius * 2 + 0.75);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mean(array) {\n    return array.reduce((a, b) =&gt; a + b) / array.length;\n}\n\nfunction sample_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / (n - 1);\n}\n\nfunction population_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / n;\n}\n\nfunction get_descriptives (array) {\n    return {mean: mean(array),\n            sample_variance: sample_variance(array) - 1, \n            population_variance: population_variance(array) - 1}\n}\n\nfunction getNewData (array) {\n    \n    return {sample_estimates: getSampleEstimates(array)\n            &lt;!-- running_averages: getRunningAverages(array) --&gt;\n            }\n}\n\nfunction getSampleEstimates(array) {\n    return [{param: \"population\", value: population_variance(array) - 1},\n            {param: \"sample\",     value: sample_variance(array) - 1},\n            {param: \"mean\",       value: mean(array)}]\n}\n\n\nfunction formatAxes(elements) {\n  elements._groups[0].forEach((l) =&gt; {\n    if (l.__data__ === 0) {\n      l.classList = \"axis-major\";\n    } else {\n      l.classList = \"axis-minor\";\n    }\n  })\n}"
  },
  {
    "objectID": "visualizations/sampling/sampling.html",
    "href": "visualizations/sampling/sampling.html",
    "title": "Sampling",
    "section": "",
    "text": "Distribution:  Normal Positive skew Negative skew Uniform Custom  Sample size:  Reset\n\n\n\n\n\n\nTake a sample\n\n\nStart\n\n\nStop\n\n\n1,000\n\n\n10,000\n\n\n100,000\n\n\nclear\n\n\n\n\n\n\nimport {sampling} from \"./sampling-backend.qmd\""
  },
  {
    "objectID": "visualizations/sampling/sampling-backend.html",
    "href": "visualizations/sampling/sampling-backend.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsampling = {\n    // https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n// https://onlinestatbook.com/stat_sim/sampling_dist/\n\nlet width = 700;\nlet height = 700;\nlet x0 = width / 2;\n\nlet populationHeight = height * 0.4;\nlet sampleHeight = 50;\nlet samplingDistributionHeight = height - (populationHeight + sampleHeight);\n\n// ball properties\nconst ballRadius = 5;\nlet generationSpeed = 1;\nlet nBalls = 500;\n\nlet sampleSize = d3.select(\"#sampleSize\").property(\"value\");\nlet distributionFunction = d3.select(\"#dist\").value\n\nlet balls = [], means = [], currentMean;\n\n\n\nlet showSleeping = false;\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet engine, render, runner, world;\n\nvar pos, mouseX, mouseY;\n\nlet populationMean = x0;\nlet populationSd = width * 0.12;\nlet updatePopulationInterval;\nlet creationIntervalId;\n\nlet y = d3.scaleLinear()\n    .domain([0, jStat.normal.pdf(x0, x0, 80 / Math.sqrt(sampleSize))])\n    .range([samplingDistributionHeight, 0])\n\n\n\n    \n// ========================================================================== //\n// Buttons and listeners\n// ========================================================================== //\n\nd3.select( \"#singleSampleBtn\").on(\"click\", logBalls)\nd3.select(\"#startSamplingBtn\").on(\"click\", takeSamples)\nd3.select( \"#stopSamplingBtn\").on(\"click\", stopSamples)\nd3.select(  \"#samples1000Btn\").on(\"click\", e =&gt; takeNSamples(1000))\nd3.select( \"#samples10000Btn\").on(\"click\", e =&gt; takeNSamples(10000))\nd3.select( \"#samples100000Btn\").on(\"click\", e =&gt; takeNSamples(100000))\nd3.select( \"#clearSamplesBtn\").on(\"click\", resetMeans)\n\nconst sampleSizeInput = d3.select(\"#sampleSize\")\n    .on(\"change\", function () {\n        resetMeans();\n        sampleSize = d3.select(\"#sampleSize\").property(\"value\");\n        updateSamplingDistributionParams();\n        updateSamplingDistributionDescriptives(true);\n        updateSampleDescriptives();\n        drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    });\n\nconst distributionInput = d3.select(\"#dist\")\n    .on(\"change\", function () {\n        reset();\n    });\n\nfunction scaleCanvas() {\n    console.log(document.getElementById(\"quarto-document-content\").offsetWidth)\n    // var availableWidth = window.visualViewport.width;\n    // var availableWidth = d3.select(\"#container\").attr(\"width\")\n\n    var availableWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = Math.min(1, availableWidth / (width * 1));\n    d3.select(\"#container\")\n        .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    d3.select(\"#flex-container\")\n        .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    d3.select(\"#container\")\n        .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n\n// ========================================================================== //\n// Physics\n// ========================================================================== //\n\n// physics properties\nconst populationDotParams = {\n    label: \"circle\",\n    restitution: 0,\n    friction: 0.1,\n    frictionAir: 0.045,\n    frictionStatic: 1,\n    slop: 0,\n    mass: 0.1,\n    density: 100,\n    sleepThreshold: 15,\n    collisionFilter: { group: 1 }\n}\n\nfunction populationDotColor() {\n    return d3.schemeCategory10[Math.floor(Math.random() * 10)]\n}\n\n// let restitution = 0; // bounciness\nlet friction = Infinity;\n// let frictionAir = 0.05;\nlet frictionStatic = Infinity;\n// let slop = 0;\n// let mass = 0.1;\n// let density = 100;\n\n\n\n\nfunction initialize() {\n\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n\n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"container\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: showSleeping\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    engine.positionIterations = 6;\n    engine.velocityIterations = 8;\n\n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.position = \"absolute\";\n\n    drawDots();\n}\n\nfunction drawDots() {\n    var isDrawing = false;\n    function startDrawing(x, y) {\n        isDrawing = true;\n        resetMeans();\n        Composite.add(world, makePopulationDot(x, y, ballRadius));\n        creationIntervalId = setInterval(function () {\n            if (pos.y &gt; (populationHeight - 5)) {\n                stopDrawing;\n                return null;\n            }\n            Composite.add(world, makePopulationDot(pos.x, pos.y, ballRadius));\n        }, generationSpeed);\n        updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n    }\n    function stopDrawing() {\n        isDrawing = false;\n        clearInterval(creationIntervalId);\n    }\n\n    // Add an event listener to the canvas to detect mouse clicks\n    render.canvas.addEventListener('mousedown', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    render.canvas.addEventListener('touchstart', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    // Update the mouse position if it's moved\n    render.canvas.addEventListener('mousemove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n    render.canvas.addEventListener('touchmove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n\n\n    // Stop generating balls when the mouse button is released\n    render.canvas.addEventListener('mouseup', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('mouseout', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('touchend', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n}\n\nconst getRelativeMousePosition = (event, target) =&gt; {\n    const bounds = target.getBoundingClientRect();\n    const scaleX = target.width / bounds.width;\n    const scaleY = target.height / bounds.height;\n    const clientX = event.clientX || event.touches[0].clientX;\n    const clientY = event.clientY || event.touches[0].clientY;\n    return {\n        x: (clientX - bounds.left) * scaleX,\n        y: (clientY - bounds.top) * scaleY,\n    };\n};\n\n// ========================================================================== //\n//      Make the world\nvar panelRadius = [10, 10, 10, 10];\nfunction makeGround() {\n    // background of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight * 0.5, width, populationHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"dodgerblue\", opacity: 0.3 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + 4, width * 2, 10, {\n            isStatic: true,\n            density: Infinity,\n            collisionFilter: { group: 1, category: 1, mask: 0 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight * 0.5, width, sampleHeight - 10, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d3d8a9\" },\n            chamfer: { radius: panelRadius }\n        })\n    );\n    // floor of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight, width, 10, {\n            friction, frictionStatic,\n            density: Infinity, mass: Infinity,\n            isStatic: true,\n            collisionFilter: { group: 2, category: 4, mask: 2 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height - samplingDistributionHeight * 0.5, width, samplingDistributionHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d49fd4\", opacity: 0.7 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height + 9, width, 20, {\n            friction, frictionStatic,\n            isStatic: true,\n            collisionFilter: { group: 3, category: 8, mask: 6 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n}\n\n\n\n// ========================================================================== //\n//      Generate population\n\nlet intervalId;\n\nfunction makePopulation(distributionFunction) {\n\n    clearInterval(intervalId);\n    let total = nBalls;\n\n    if (distributionFunction == \"custom\") { total = 0 };\n\n    intervalId = setInterval(() =&gt; {\n\n        if (total-- &gt; 0) {\n\n            let x = distributionFunction();\n            let y = -500 + Math.random() * 500;\n\n            let circle = makePopulationDot(x, y, ballRadius);\n            Matter.Composite.add(world, circle);\n\n        }\n    }, generationSpeed);\n}\n\n\nfunction makePopulationDot(x, y, radius) {\n    \n    let dot = Matter.Bodies.circle(x, y, radius, populationDotParams);\n    dot.render.fillStyle = populationDotColor();\n    \n    Events.on(dot, \"sleepStart\", function () {\n        dot.isStatic = true;\n        balls.push(dot);\n        updateDescriptives();\n    });\n\n    return dot;\n}\n\n\n// ========================================================================== //\n//      Update population\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"circle\" && !body.isStatic));\n};\n\nlet populationInterval;\n\nfunction checkStatic(body) {\n    return body.isStatic;\n}\n\nlet popChecks = 0;\nfunction updatePopulation() {\n    console.log(\"checking pop\");\n    popChecks++;\n    let allBalls = world.bodies.filter((body) =&gt; (body.label === \"circle\"));\n\n    // compute the population mean\n    let total = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        total += allBalls[i].position.x;\n    }\n    populationMean = total / allBalls.length;\n\n    let ss = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        ss += Math.pow(allBalls[i].position.x - populationMean, 2);\n    }\n    populationSd = Math.sqrt(ss / allBalls.length);\n    // console.log(populationSd);\n    drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    updateSamplingDistributionParams();\n    if (allBalls.every(checkStatic) || popChecks &gt; 1000) {\n        popChecks = 0;\n        clearInterval(updatePopulationInterval);\n    }\n}\n\nlet existingMeans = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"mean\"));\n};\n\nconst makeStaticMeanInterval = setInterval(() =&gt; {\n    existingMeans().forEach(function (mean) {\n        let meanHeight = mean.position.y;\n        let meanSpeed = mean.speed;\n        // let minHeight = 10; // height - (floorHeight + wallHeight);\n        let minHeight = populationHeight + sampleHeight + 50;\n        if (meanHeight &gt; minHeight && meanSpeed &lt; 0.5) {\n            // mean.render.fillStyle = \"black\";\n            mean.isStatic = true;\n            // mean.density = Infinity;\n            //balls.push({ position: ball.position, fill: ball.render.fillStyle });\n            //Body.setStatic(mean, true);\n        }\n    });\n}, 10);\n\n\n// ========================================================================== //\n// Sampling\nfunction logBalls() {\n    let s = sample(sampleSize);\n    // console.log(balls);\n    // console.log(s);\n\n    d3.select(\"#mean\").html(currentMean);\n}\n\n\n// ========================================================================== //\n//      Single sample\n\nfunction sample(sampleSize, fast = false) {\n    let arr = [];\n    let sampleCircles = [];\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"sample\")));\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"meanGhost\")));\n\n    for (let i = 0; i &lt; sampleSize; i++) {\n        let index = Math.floor(Math.random() * balls.length);\n        let pos = balls[index].position;\n        arr.push(pos.x);\n\n        let yPos = pos.y;\n\n        if (fast) yPos = populationHeight + sampleHeight - ballRadius;\n\n\n        sampleCircles.push(Bodies.circle(pos.x, yPos, ballRadius, {\n            label: \"sample\",\n            restitution: 0.4, friction, frictionStatic,\n            density: 1, mass: 1, slop: 0.05,\n            sleepThreshold: Infinity,\n            collisionFilter: { group: -1, category: 2, mask: 4 },\n            render: { fillStyle: balls[index].render.fillStyle }\n        }));\n    };\n\n    currentMean = mean(arr);\n    means.push(currentMean);\n\n\n    let binnedMean = Math.round(currentMean / (ballRadius * 2)) * (ballRadius * 2);\n\n    const meanSquareBack = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2, ballRadius * 2, ballRadius * 2, {\n        label: \"meanGhost\",\n        isStatic: true,\n        isSensor: true,\n        render: { fillStyle: \"white\" }\n    });\n    Composite.add(world, meanSquareBack);\n\n    const meanSquare = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2 - 1, ballRadius * 2, ballRadius * 2, {\n        label: \"mean\",\n        restitution: 0,\n        friction,\n        frictionStatic,\n        frictionAir: 0.03,\n        density: Infinity,\n        mass: 0.000000000000001,\n        slop: 0,\n        collisionFilter: { group: 4, category: 6, mask: 8 },\n        render: { fillStyle: \"#d3d8a9\", strokeStyle: \"black\", lineWidth: 1 }\n    });\n    Composite.add(world, meanSquare);\n\n    Composite.add(world, sampleCircles);\n\n    updateSampleDescriptives(sampleSize, f(currentMean), f(sd(arr, false)), false);\n    updateSamplingDistributionDescriptives();\n}\n\nlet sampleInterval;\n\nfunction takeSamples() {\n    sampleInterval = setInterval(() =&gt; {\n        sample(sampleSize, true);\n    }, 100);\n}\n\n\nfunction stopSamples() {\n    clearInterval(sampleInterval);\n}\n\n\n// ========================================================================== //\n//      Multiple samples\nlet meanCounts = {};\nfunction takeNSamples(nSamples) {\n\n\n    for (let i = 0; i &lt; nSamples; i++) {\n\n        let thisSample = [];\n\n        for (let j = 0; j &lt; sampleSize; j++) {\n            let index = Math.floor(Math.random() * balls.length);\n            thisSample.push(balls[index].position.x);\n        }\n\n        let thisSampleMean = mean(thisSample);\n        means.push(thisSampleMean);\n\n        let thisSampleMeanBinned = bin(thisSampleMean, ballRadius);\n\n        if (meanCounts.hasOwnProperty(thisSampleMeanBinned)) {\n            meanCounts[thisSampleMeanBinned]++;\n        } else {\n            meanCounts[thisSampleMeanBinned] = 1;\n        }\n    }\n\n    updateSamplingDistributionDescriptives();\n    let meanProportions = transformCountsToProportions(meanCounts, means.length);\n    drawProportions(meanProportions);\n}\n\n\n// ========================================================================== //\n//      Reset\nfunction reset() {\n\n    balls = [];\n    means = [];\n\n    clearInterval(updatePopulationInterval);\n    clearInterval(intervalId);\n    histogram.selectAll(\"rect\").remove();\n    curve.selectAll(\"path\").remove();\n\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    // console.log('reset clicked');\n\n    initialize();\n    makeGround();\n    makePopulation(eval(d3.select(\"#dist\").node().value));\n    updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n\n    updateSampleDescriptives(0, 0, 0, true);\n    updateSamplingDistributionDescriptives(true);\n}\n\n\nfunction resetMeans() {\n    means = [];\n    meanCounts = {};\n    histogram.selectAll(\"rect\").remove();\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\" || body.label === \"sample\" || body.label === \"meanGhost\")));\n    d3.select(\"#samplingDistStats\").classed(\"hide\", true);\n    d3.select(\"#sampleStats\").classed(\"hide\", true);\n}\n\n\n\n\n// ========================================================================== //\n// Overlay and panel labels\n// ========================================================================== //\n\n// ==================\n//      Labels\nvar labels = [{ label: \"Population\", top: 0 },\n{ label: \"Sample\", top: populationHeight + 5 },\n{ label: \"Distribution of sample means\", top: populationHeight + sampleHeight }];\n\nd3.select(\"#container\").selectAll(\"span\")\n    .data(labels).enter().append(\"span\")\n    .classed(\"panel-label\", true)\n    .classed(\"labels\", true)\n    .style(\"position\", \"absolute\").style(\"left\", \"0.1em\")\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .text(d =&gt; d.label)\n\nvar labels2 = [{\n    label: `&lt;i&gt;N&lt;/i&gt; = &lt;span id=\"n\"&gt;0&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;μ&lt;/i&gt; = &lt;span id=\"mu\"&gt;&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;σ&lt;/i&gt; = &lt;span id=\"sigma\"&gt;&lt;/span&gt;`,\n    top: 0\n},\n{\n    label: `&lt;div id=\"sampleStats\"&gt;&lt;i&gt;n&lt;/i&gt; = &lt;span id=\"sampleN\"&gt;&lt;/span&gt;;\n              &lt;i&gt;M&lt;/i&gt; = &lt;span id=\"sampleM\"&gt;&lt;/span&gt;;\n              &lt;i&gt;SD&lt;/i&gt; = &lt;span id=\"sampleSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + 5\n},\n{\n    label: `&lt;div id=\"samplingDistParams\"&gt;Predicted:&lt;br&gt;\n              &lt;i&gt;μ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;μ&lt;/i&gt; = &lt;span id=\"muM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;σ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;σ&lt;/i&gt;/√&lt;i&gt;n&lt;/i&gt;  = &lt;span id=\"sigmaM\"&gt;&lt;/span&gt;&lt;/div&gt;\n              &lt;div id=\"samplingDistStats\"&gt;Observed:&lt;br&gt;&lt;i&gt;N&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distN\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;μ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;σ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + sampleHeight\n}];\n\nconst overlay2 = d3.select(\"#container\").append(\"div\")\n    .style(\"position\", \"absolute\")\n    .style(\"z-index\", 13)\n    .style(\"text-align\", \"right\")\n\noverlay2.selectAll(\"span\")\n    .data(labels2).enter().append(\"span\")\n    .style(\"width\", width - 5 + \"px\")\n    .style(\"z-index\", 0)\n    // .style(\"margin-right\", \"1em\")\n    .classed(\"panel-label\", true)\n    .classed(\"numbers\", true)\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .html(d =&gt; d.label)\n\nconst f = d3.format(\".1f\");\nconst fComma = d3.format(\",\");\n\nfunction updateDescriptives() {\n    d3.select(\"#n\").text(fComma(balls.length))\n    d3.select(\"#mu\").text(f(populationMean))\n    d3.select(\"#sigma\").text(f(populationSd))\n}\n\nfunction updateSampleDescriptives(n, m, sd, hidden = true) {\n    d3.select(\"#sampleStats\").classed(\"hide\", hidden)\n    d3.select(\"#sampleN\").text(n)\n    d3.select(\"#sampleM\").text(f(m))\n    d3.select(\"#sampleSd\").text(f(sd));\n}\nfunction updateSamplingDistributionParams() {\n    d3.select(\"#muM\").text(f(populationMean))\n    d3.select(\"#sigmaM\").text(f(populationSd / Math.sqrt(sampleSize)));\n}\n\nfunction updateSamplingDistributionDescriptives(hidden = false) {\n    d3.select(\"#samplingDistStats\").classed(\"hide\", hidden)\n    d3.select(\"#distN\").text(fComma(means.length));\n    d3.select(\"#distM\").text(f(mean(means)));\n    d3.select(\"#distSd\").text(f(sd(means)));\n}\n\n\n\n// ========================================================================== //\n//      Normal distribution\n\n// create svg overlay\nconst svg = d3.select(\"#container\")\n    .append(\"svg\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .style(\"transform\", `translateY(${height - samplingDistributionHeight}px)`)\n    // .append(\"div\")\n    .style(\"z-index\", 0)\n    .attr(\"id\", \"samplingDistCanvas\")\n    // .style(\"left\", 0)\n    .attr(\"height\", samplingDistributionHeight)\n    .attr(\"width\", width);\n\nconst histogram = svg.append(\"g\");\nconst curve = svg.append(\"g\");\n\n\nfunction drawNormalDistribution(mean, sd) {\n\n    // remove the old path\n    curve.selectAll(\"path\").remove();\n\n    // reset the y-axis according to new population parameters\n    y.domain([0, 1.1 * jStat.normal.pdf(populationMean, populationMean, populationSd / Math.sqrt(sampleSize))]);\n\n    var values = jStat(0, width, 210)[0];\n\n    let data = [];\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, mean, sd);\n        data.push({ value: value, density: density });\n    }\n\n    const line = d3.line()\n        .x(d =&gt; d.value)\n        .y(d =&gt; y(d.density));\n\n    // draw the new path\n    curve.append(\"path\")\n        .attr(\"d\", line(data))\n        .attr(\"stroke\", \"grey\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        .attr(\"stroke-width\", 2)\n        .attr(\"fill\", \"none\");\n}\n\n// ========================================================================== //\n//      Histogram\nfunction drawProportions(proportions) {\n\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\")));\n    histogram.selectAll(\"rect\").remove();\n\n    Object.entries(proportions).forEach(([key, value]) =&gt; {\n        histogram.append(\"rect\")\n            .attr(\"fill\", \"#d3d8a9\")\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5)\n            .attr(\"x\", key - ballRadius * 0.5)\n            // .attr(\"y\", 0)\n            .attr(\"y\", y(value * 0.2))\n            .attr(\"width\", 5)\n            // .attr(\"height\", samplingDistributionHeight * 2)\n            .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n        // .transition().duration(value * 15000)\n        //     .attr(\"y\", y(value * 0.2))\n        //     .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n    });\n}\n\n\n\n\n// ========================================================================== //\n// Helper functions\n// ========================================================================== //\n\n\n// ========================================================================== //\n//      Distribution functions\n\n// functions to make skewed distribution\n// see https://spin.atomicobject.com/2019/09/30/skew-normal-prng-javascript/\nconst randomNormals = (rng) =&gt; {\n    let u1 = 0, u2 = 0;\n    //Convert [0,1) to (0,1)\n    while (u1 === 0) u1 = rng();\n    while (u2 === 0) u2 = rng();\n    const R = Math.sqrt(-2.0 * Math.log(u1));\n    const Θ = 2.0 * Math.PI * u2;\n    return [R * Math.cos(Θ), R * Math.sin(Θ)];\n};\n\n\nconst randomSkewNormal = (rng, ξ = 0, ω = 1, α = 0) =&gt; {\n    const [u0, v] = randomNormals(rng);\n    if (α === 0) {\n        return ξ + ω * u0;\n    }\n    const 𝛿 = α / Math.sqrt(1 + α * α);\n    const u1 = 𝛿 * u0 + Math.sqrt(1 - 𝛿 * 𝛿) * v;\n    const z = u0 &gt;= 0 ? u1 : -u1;\n    return ξ + ω * z;\n};\n\n// functions to generate single observations from those distributions\nfunction normal() {\n    return randomSkewNormal(Math.random, x0, width * 0.12, 0);\n}\nfunction negative() {\n    return randomSkewNormal(Math.random, width * 0.9, width * 0.25, -10);\n}\nfunction positive() {\n    return randomSkewNormal(Math.random, width * 0.1, width * 0.25, 10);\n}\nfunction uniform() {\n    return ((width * 0.05) + width * 0.9 * Math.random());\n}\n\n// ============================================================\n//      Other low-level helper functions\n\nfunction sleep(milliseconds) {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date &lt; milliseconds);\n}\n\n\nfunction bin(x, binWidth) {\n    return Math.round(x / binWidth) * binWidth;\n}\n\n\nArray.prototype.max = function () {\n    return Math.max.apply(null, this);\n};\n\n\nfunction transformCountsToProportions(counts, totalCount) {\n    // let totalCount = Object.values(counts).reduce((a, b) =&gt; a + b, 0);\n    let proportions = {};\n\n    for (let mean in counts) {\n        if (counts.hasOwnProperty(mean)) {\n            proportions[mean] = counts[mean] / totalCount;\n        }\n    }\n\n    return proportions;\n}\n\nfunction mean(arr) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    return total / n;\n}\n\nfunction sd(arr, population = true) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    let mean = total / n;\n\n    let ss = 0;\n\n    for (let i = 0; i &lt; arr.length; i++) {\n        ss += Math.pow(arr[i] - mean, 2);\n    }\n\n    let denominator = arr.length;\n\n    if (!population) { denominator--; }\n\n    return Math.sqrt(ss / denominator);\n}\n\n\nscaleCanvas();\ninitialize();\nreset();\n}"
  },
  {
    "objectID": "visualizations/quincunx.html",
    "href": "visualizations/quincunx.html",
    "title": "Quincunx",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\nboard = {\n\n\n// https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n\n\nlet width = 700;\nlet height = 600;\nlet x0 = width / 2;\n\n// ball properties\nconst ballRadius = 4;\nlet y_start = 0;\n\nlet generation_speed = 20;\nlet nBalls = 650;\nlet mass = 100;\nlet density = 1;\n\n// peg board properties\nlet rows = 20;\nlet y_peg_start = 20;\nlet pegGap = 6.5 * ballRadius;\nlet pegRadius = 0.5 * ballRadius;\nlet xGap = pegGap;\nlet yGap = 0.6 * xGap;\nlet pegAngle = 0; // Math.PI / 4;\nlet gap_between_pegs_and_buckets = 0;\n\n// funnel properties\nconst funnelTostartGap = yGap;\nconst funnelWallLength = 600;\nconst funnelAngle = Math.PI / 3;\nconst funnelOpening = 5 * ballRadius;\n\n// physics properties\nlet restitution = 0.5; // bounciness\nlet friction = 0.01;\nlet frictionAir = 0.045;\nlet frictionStatic = 0;\n\n\nlet intervalId;\n\n\nvar {Engine, Render, Runner, \n    Composite, Composites, Common, \n    MouseConstraint, Mouse, Events, \n    World, Bodies, Body} = Matter;\n\nlet engine, render, runner, world;\n\n\n\nfunction initialize() {\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n    \n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"board\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    \n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.addEventListener(\"mousedown\", reset);\n    render.canvas.position = \"absolute\";\n}\n\n\n\n// Create top funnel\nlet leftBumper_x =  x0 - (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet rightBumper_x = x0 + (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet bumper_y = y_peg_start - ((funnelWallLength * Math.sin(funnelAngle)) / 2 - funnelTostartGap);\nconsole.log(bumper_y)\n\nlet createFunnel = () =&gt; {\n\n        let leftBumper = Bodies.rectangle(leftBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(leftBumper, funnelAngle);\n\n        let rightBumper = Bodies.rectangle(rightBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution: 0.6,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(rightBumper, -funnelAngle);\n\n        Matter.Composite.add(world, [leftBumper, rightBumper]);\n}\n\n\nfunction make_balls() {\n\n    let total = nBalls;\n    clearInterval(intervalId);\n\n    intervalId = setInterval(() =&gt; {\n        let balls = [];\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x0 + (-0.5 + Math.random()) * 1, -20, ballRadius, {\n                label: \"circle\",\n                friction: 0.001,\n                restitution,\n                mass,\n                slop: 0.05,\n                density,\n                frictionAir,\n                sleepThreshold: Infinity,\n                render: {\n                    fillStyle: d3.schemeCategory10[total % 10]\n                }\n            });\n            // Matter.Events.on(circle, \"sleepStart\", () =&gt; {\n            //     Matter.Body.setStatic(circle, true);\n            // });\n            \n            Matter.Composite.add(world, circle);\n        }\n    }, generation_speed);\n}\n\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; body.label === \"circle\");\n  };\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach(function(ball) {\n      let ballHeight = ball.position.y;\n      let ballSpeed = ball.speed;\n      let minHeight = 350; // height - (floorHeight + wallHeight);\n      if (ballHeight &gt; minHeight && ballSpeed &lt; 0.02) {\n        // ball.render.opacity = 0.5;\n        Body.setStatic(ball, true);\n      }\n    });\n  }, 200);\n\n\nfunction make_pegs() {\n    const pegs = [];\n    const spacingY = ballRadius*4;\n    const spacingX = ballRadius*4;\n    var i, j, lastI;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 1; j &lt; i; j++) {\n            pegs.push(\n                // Bodies.rectangle(\n                Bodies.circle(\n                    x0 + (j * xGap - i * (xGap / 2)),\n                    y_peg_start + i * yGap,\n                    pegRadius,\n                    // ballRadius * 1.2,\n                    // 2,\n                    {\n                        angle: pegAngle,\n                        isStatic: true,\n                        friction: 0,\n                        frictionStatic: 0,\n                        render: {\n                            fillStyle: \"black\"\n                        },\n                    chamfer: {\n                        radius: [ballRadius * 0.2, ballRadius * 0.2, 0, 0]\n                    }\n        })\n            );\n        }\n        lastI = i;\n    }\n    // bins\n    for (i = 0; i &lt; rows; i++) {\n        Matter.Composite.add(\n            world,\n            Bodies.rectangle(\n\n                x0 - (rows - 1) * (xGap / 2) + i * xGap,\n                y_peg_start + rows * yGap + gap_between_pegs_and_buckets + (height-(y_peg_start + rows * yGap))/2,\n                4,\n                (height-(y_peg_start + rows * yGap)),\n                {\n                    isStatic: true,\n                    density: 1000,\n                    mass: 1000,\n                    slop: 0,\n                    render: {\n                        fillStyle: \"#000000\",\n                        visible: true\n                    },\n                    chamfer: {\n                        radius: [ballRadius * 0.4, ballRadius * 0.4, 0, 0]\n                    }\n                }\n            )\n        );\n    }\n    // ground\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(400, height, 1000, 10, {\n            isStatic: true,\n            render: {\n                fillStyle: \"#000000\",\n                visible: true\n            }\n        })\n    );\n\n\n    World.add(world, pegs);\n}\n\nconst canvas = d3.select(\"#overlay\")\n.append(\"canvas\")\n.attr(\"id\", \"overlay\")\n.attr(\"position\", \"absolute\")\n.attr(\"width\", width)\n.attr(\"height\", height);\n\nconst ctx = canvas.node().getContext('2d');\ncanvas.on(\"mousedown\", reset);\n\nfunction drawNormalDistribution() {\n\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(0, height - 5);\n\n    let yMultiplier = (height-(y_peg_start + rows * yGap));\n    var values = jStat(-4, 4, 210)[0]\n\n\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, 0, 0.8);\n        ctx.lineTo((value + 4)*(width/8), height-(density*1.95*yMultiplier) - 5);\n        ctx.stroke();\n    }\n}\n\nfunction reset() {\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    console.log('reset clicked');\n    \n    initialize();\n    scaleCanvas();\n    make_pegs();\n    make_balls();\n    createFunnel();\n    drawNormalDistribution();\n}\n\n\nfunction scaleCanvas() {\n    \n    var containerWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = containerWidth / (width * 1);\n    d3.select(\"canvas\")\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n    canvas\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    // d3.select(\"#flex-container\")\n    //     .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    // d3.select(\"#container\")\n    //     .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n//\n\ninitialize();\nscaleCanvas();\nmake_pegs();\nmake_balls();\ncreateFunnel();\ndrawNormalDistribution();\n  \n}"
  },
  {
    "objectID": "games/jellybeans.html",
    "href": "games/jellybeans.html",
    "title": "Psych Stats",
    "section": "",
    "text": "How many jellybeans in the jar?\n    \n    \n        \n    \n\n\n    Reveal\n\n\nimport { scaleCanvas } from '../utils/utils.js';\n\njar = {\n    let width = 500;\nlet height = 600;\nlet x0 = width / 2;\n\nlet colorPal = [\n    '#ff8aa6', // Pastel Pink\n    '#ff9b48', // Pastel Orange\n    '#fff067', // Pastel Yellow\n    '#9EE09E', // Pastel Green\n    '#71c4e6', // Pastel Blue\n    '#edceff', // Pastel Purple\n    '#fc5c30', // Pastel Brown\n    '#CAF7E2'  // Pastel Mint\n];\n\n\nfunction randomColor(colorPal) {\n    return colorPal[Math.floor(Math.random() * colorPal.length)];\n}\n\nfunction getBeanProperties(colorPal) {\n    return {\n        label: \"circle\",\n        mass: 100,\n        restitution: 0.5,\n        friction: 0.01,\n        frictionAir: 0.025,\n        frictionStatic: 0,\n        density: 1,\n        slop: 0.05,\n        sleepThreshold: 15,\n        render: { fillStyle: randomColor(colorPal) }\n    };\n}\n\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet intervalId = null;\nconst generationSpeed = 20;\n\nlet params = randomizeParams();\nlet engine = initializeWorld(\"board\", \"canvas\", width, height);\n\nComposite.add(engine.world, makeJar(params));\n\nlet generateBean = createBeanGenerator(params, x0, colorPal);\naddBeansToWorld(engine.world, generateBean, generationSpeed);\n\nengine;\n\nfunction randomizeParams() {\n    const generationSpeed = 20;\n    const jarCount = 0;\n    const jarWidth = 0.5 + Math.random() * 0.4;\n    const jarHeight = 0.5 + Math.random() * 0.2;\n    const beanRadius = 6 + Math.random() * 6;\n    const nBeans = Math.floor(4000 * (jarWidth * jarHeight) * (1 / beanRadius));\n    \n    return {nBeans, beanRadius, generationSpeed, jarWidth, jarHeight, jarCount};\n}\n\nfunction initializeWorld(element, canvas, width, height) {\n    let engine = Engine.create({\n        enableSleeping: true\n    }),\n    world = engine.world;\n    // create renderer\n    let render = Render.create({\n        element: document.getElementById(element),\n        canvas: document.getElementById(canvas),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n    \n    let runner = Runner.create();\n    Runner.run(runner, engine);\n\n    // Reset simulation on mousedown events\n    render.canvas.addEventListener(\"mousedown\", handleReset);\n\n    return {world, render};\n}\n\n\nfunction createBeanGenerator(params, x, colors) {\n    let total = params.nBeans;\n\n    return function generateBean() {\n        if (total-- > 0) {\n            const circle = Bodies.circle(x + (-0.5 + Math.random()) * 250, -20, params.beanRadius + Math.random() * 8, \n            getBeanProperties(colorPal)\n            );\n\n            Events.on(circle, \"sleepStart\", function () {\n                circle.isStatic = true;\n                circle.label = \"inJar\";\n            });\n\n            return circle;\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction addBeansToWorld(world, generatorFunction, speed) {\n    intervalId = setInterval(() => {\n        let bean = generatorFunction();\n        if (bean) {\n            Composite.add(world, bean);\n        } else {\n            clearInterval(intervalId);\n            intervalId = null;\n        }\n    }, speed);\n}\n\n\nconst existingBalls = () => {\n    return engine.world.bodies.filter((body) => body.label === \"circle\");\n};\n\nconst makeStaticInterval = setInterval(() => {\n    existingBalls().forEach((ball) => removeBall(engine, ball, height));\n}, 200);\n\nfunction removeBall(engine, ball, canvasHeight) {\n    let ballHeight = ball.position.y;\n    if (ballHeight > canvasHeight) {\n        console.log(\"gonner\");\n        Composite.remove(engine.world, ball);\n    }\n}\n\nfunction makeJar(params) {\n\n    const thickness = 10;\n    const properties = {\n        isStatic: true,\n        render: {\n            fillStyle: \"#000000\",\n            visible: true\n        },\n        chamfer: { radius: [5, 5, 5, 5]}\n    };\n\n    const leftWall = Bodies.rectangle(width * (1 - params.jarWidth) / 2, (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const rightWall = Bodies.rectangle(width * (1 - (1 - params.jarWidth) / 2), (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const bottom = Bodies.rectangle(width * 0.5, height - 5, width * params.jarWidth, thickness, properties);\n\n    return [leftWall, rightWall, bottom];\n}\n\nconst btn = document.getElementById(\"revealBtn\");\n\nfunction countBeansInJar(world) {\n    return world.bodies.filter((body) => body.label === \"inJar\").length;\n}\n\nbtn.addEventListener(\"click\", function(event) {\n    btn.innerHTML = countBeansInJar(engine.world);\n})\n\nfunction resetRevealButton(button) {\n    button.innerHTML = \"Reveal\";\n}\n\n\nfunction reset() {\n    const newParams = randomizeParams();\n    const newEngine = initializeWorld(\"board\", \"canvas\");\n    const newJar = makeJar(newParams);\n    const newBeans = createBeanGenerator(newParams, x0, colorPal);\n\n    return { newParams, newEngine, newBeans, newJar };\n}\n\nfunction handleReset() {\n    resetRevealButton(btn);\n    // Composite.clear(engine.world);\n    \n    if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n    }\n    \n    const { newParams, newEngine, newBeans, newJar } = reset();\n    params = newParams;\n    engine = newEngine;\n    Composite.add(engine.world, newJar)\n    generateBean = newBeans;\n    addBeansToWorld(engine.world, generateBean, generationSpeed);\n}\n\nscaleCanvas(\"container\", width, height);\nwindow.addEventListener(\"resize\", () => scaleCanvas(\"container\", width, height))\n\n}"
  },
  {
    "objectID": "games/jellybeans2.html",
    "href": "games/jellybeans2.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\n\n\njar = {\nconst renderVertices = body => {\n  ctx.beginPath();\n  body.vertices.forEach(({x, y}) => ctx.lineTo(x, y));\n  ctx.closePath();\n  ctx.fill();\n  ctx.stroke();\n};\n\n\nconst container = d3.select(\"#container\");\n\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst gradient = ctx.createLinearGradient(\n  0, 0, canvas.width, canvas.height\n);\ngradient.addColorStop(0, \"red\");\ngradient.addColorStop(1, \"blue\");\nctx.fillStyle = gradient;\nctx.strokeStyle = \"var(--bs-body-color)\";\nctx.lineWidth = 2;\n\nconst engine = Matter.Engine.create();  \nconst box = Matter.Bodies.circle(300, 0, 10, 10);\nconst ground = Matter.Bodies.rectangle(\n  200, 200, 400, 120, {isStatic: true}\n);\nconst mouseConstraint = Matter.MouseConstraint.create(\n  engine, {element: canvas}\n);\nMatter.Composite.add(\n  engine.world, [box, ground, mouseConstraint]\n);\n\n(function rerender() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  renderVertices(box);\n  renderVertices(ground);\n  Matter.Engine.update(engine);\n  requestAnimationFrame(rerender);\n})();\n\n}"
  },
  {
    "objectID": "games/triplett/triplett.html",
    "href": "games/triplett/triplett.html",
    "title": "Psych Stats",
    "section": "",
    "text": "practice\n\n\nrace alone\n\n\nrace together\n\n\nAbout\n\n\n\nCompetition Machine —\n\n\n\n\n┘\n\n\n🏁\n\n\n🚩\n\n\n\n\n┘\n\n\n🏁\n\n\n🚩\n\n\n\n\nYour time: 0.00\n\n\nReset\n\n\n\n\nClick the ‘handle’ to the left of the ‘track’ to start.\n\n\nKeep clicking as fast as you can until your flag reaches the end.\n\n\nClick Race Alone to do a timed race by yourself.\n\n\nClick Race Together to race against a competitor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n👑 Records 👑\n\n\nPrevious\n\n\nBest\n\n\n\n\n🚩 Alone\n\n\n-\n\n\n-\n\n\n\n\n🚩🚩Competition\n\n\n-\n\n\n-\n\n\n\n\n\n\ngame = {\n    var start, myTimer, myTurner;\nvar sec = d3.select(\"#seconds\")\nvar cli = d3.select(\"#clicks\")\nvar flag = d3.select(\"#flag\")\nvar flag2 = d3.select(\"#flag2\")\nvar clicks = 0;\nvar state;\nconst target_clicks = 50;\nvar mode = practice;\n\nvar records = [{prev: 0, best: 0},{prev: 0, best: 0}]\n\nvar handleState = 0;\nconst handle = d3.select(\"#handle-text\");\nconst handle2 = d3.select(\"#handle2-text\");\nconst handleText = [\"┘\",\"└\"]\n\nd3.select(\"#handle1\").on(\"click\", clicked);\nd3.select(\"#practice-button\").on(\"click\", practice);\nd3.select(\"#alone-button\").on(\"click\", alone);\nd3.select(\"#competition-button\").on(\"click\", competition);\nd3.select(\"#reset-button\").on(\"click\", reset);\n\nfunction handleClicked() {\n    handleState++;\n    handle.text(handleText[handleState % 2]);\n}\n\nfunction turnHandle2() {\n    var handle2State = 0;\n    myTurner = setInterval( function(){\n        handle2State++;\n        handle2.text(handleText[handle2State % 2]);\n        if (handle2State &gt; target_clicks) clearInterval(myTurner);\n    }, 7000 / target_clicks);\n}\n\nfunction clicked() {\n    handleClicked();\n    \n    if (clicks==0) {startTimer(); turnHandle2();}\n    if (clicks &lt; target_clicks) {\n        clicks++;\n    cli.text(clicks);\n    flag.transition().duration(300).style(\"left\", `${clicks*(100/target_clicks)*1.00}%`);\n    } \n    if (clicks == target_clicks) stopTimer();\n}\n\nfunction startTimer() {\n    start = Date.now();\n    myTimer= setInterval( function(){\n        var delta = Date.now() - start; // milliseconds elapsed since start\n        sec.html(delta / 1000);\n    }, 10);\n\n    flag2.transition().ease(d3.easeLinear).duration(7000).style(\"left\", \"100%\")\n}\n\nfunction stopTimer() {\n    clearInterval(myTimer);\n\n    var time = Number(sec.html());\n\n    if(state!=\"practice\") {\n        d3.select(\"#\" + state + \"-previous\").text(time);\n\n        var previousBest = Number(d3.select(\"#\" + state + \"-best\").text());\n        if(isNaN(previousBest)) d3.select(\"#\" + state + \"-best\").text(time);\n        else if (time &lt; previousBest) d3.select(\"#\" + state + \"-best\").text(time);\n    }\n}\n\n// function updateTable(time, cell) {\n//     d3.select(cell).text(time);\n// }\n\nfunction practice() {\n    state = \"practice\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#practice-button\").classed(\"selected\", true);\n    // d3.select(\"#practice\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#time\").style(\"display\", \"none\");\n}\n\nfunction alone() {\n    state = \"alone\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#alone-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction competition() {\n    state = \"competition\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#competition-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction reset() {\n    clearInterval(myTimer);\n    clearInterval(myTurner);\n    sec.text(\"0.00\");\n    cli.text(0);\n    flag.transition().duration(1000).style(\"left\", \"0%\");\n    flag2.transition().duration(1000).style(\"left\", \"0%\");\n    clicks = 0;\n}\n\npractice();\n}"
  },
  {
    "objectID": "visualizations/dice/dice.html",
    "href": "visualizations/dice/dice.html",
    "title": "Dice Roller",
    "section": "",
    "text": "Throw the dice\n\n\n+100\n\n\n+1,000\n\nNumber of dice:  1 2 3 4 5 10 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThrows:  Reset"
  },
  {
    "objectID": "games/correlation/guess-the-correlation.html",
    "href": "games/correlation/guess-the-correlation.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Guess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\ngame = {\nconst f = d3.format(\".2f\");\nconst res = d3.format(\"+.2f\");\nconst line = d3.line();\n\n\n// SVG\n\nconst w = 500;\nconst h = 350;\nconst margin = {top: 10, right: 10, bottom: 30, left: 10}\nconst radius = 4;\nvar r;\nvar p1error, p2error, winnerIndex;\nvar scores = [0,0];\n\n\nconst scoreValues = [d3.select(\"#p1-points\"), d3.select(\"#p2-points\")];\n\n\nconst svg = d3.select(\".svg-container\")\n.append(\"svg\")\n.attr(\"class\", \"svg-content\")\n.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n.attr(\"viewBox\", `0 0 ${w} ${h}`);\n\nconst axisLine = svg.append(\"path\")\n    .style(\"stroke\", \"black\").style(\"fill\", \"none\")\n    .style(\"stroke-linecap\", \"square\").style(\"stroke-width\", 2);\n    \naxisLine.attr(\"d\", line([[margin.left, margin.top],\n                        [margin.left, h - margin.bottom],\n                        [w - margin.right, h - margin.bottom]]));\n                              \n\nfunction makeChart() {\n    var data = makeData(100);\n\n    var x = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.xVal), d3.max(data, d =&gt; d.xVal)])\n        .range([margin.left + 2*radius, w - margin.right - 2*radius])\n    const y = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.yVal), d3.max(data, d =&gt; d.yVal)])\n        .range([h - margin.bottom - 2*radius, margin.top + 2*radius])\n\n    svg.selectAll(\"circle\").remove();\n    svg.selectAll(\"circle\").data(data).enter()\n        .append(\"circle\")\n        .attr(\"cx\", d =&gt; x(d.xVal))\n        .attr(\"cy\", d =&gt; y(d.yVal))\n        .attr(\"r\", radius)\n        .style(\"fill\", \"plum\")\n        .style(\"opacity\", 0)\n        .transition().delay((d,i) =&gt; i * 10).duration(0)\n            .style(\"opacity\" ,1)\n \n}\n\nfunction adjudicateGuesses() {\n    var p1guess = d3.select(\"#p1-guess\").property(\"value\");\n    var p2guess = d3.select(\"#p2-guess\").property(\"value\");\n    p1error = r - p1guess;\n    p2error = r - p2guess;\n\n    var errors = [Math.abs(p1error), Math.abs(p2error)]\n    winnerIndex = errors.indexOf(Math.min(...errors));\n    \n    showResults();\n    addPoint(winnerIndex);\n    d3.select(\"#refresh\").text(\"Next\").on(\"click\", reset);\n}\n\nfunction showResults() {\n    let winner = Array(2).fill(\"\");\n    winner[winnerIndex] = \"&lt;span style='font-size: 2em;'&gt;👑&lt;/span&gt;\";\n    d3.select(\"#p1-error\").html(res(p1error * -1) + \"&lt;br&gt;\" + winner[0]);\n    d3.select(\"#p2-error\").html(res(p2error * -1) + \"&lt;br&gt;\" + winner[1]);\n    d3.select(\"#true-r\").text(\"True r = \" + f(r));\n}\n\nd3.select(\"#p1-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"🪙\")\nd3.select(\"#p2-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"🪙\")\n\nfunction addPoint(i) {\n    scores[i]++;\n    if(scores[i] &gt; 2) {\n        // declareWinner(i);\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    } else {\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    }\n}\n\nfunction declareWinner(winnerIndex) {\n    // alert(\"Player \" + (winnerIndex + 1) + \" wins!!!\")\n    // window.location.reload();\n}\n\n\nfunction reset() {\n    d3.selectAll(\".resettable\").html(\"\")\n    d3.selectAll(\".guess\").property(\"value\", \"\");\n    \n    d3.select(\"#refresh\").text(\"Guess\").on(\"click\", adjudicateGuesses);\n    makeChart();\n}\n\n// d3.selectAll(\".points-label\").each(() =&gt; this.on(\"click\", this.select()));\n\nfunction makeData(n) {\n    let arr = [];\n    let arrX = [];\n    let arrY = [];\n\n    var target_r = Math.random();\n    console.log(\"target r = \" + target_r);\n\n    for (var i = 0; i &lt; n; i++) {\n        var A = jStat.normal.inv(Math.random(), 0, 1);\n        var B = jStat.normal.inv(Math.random(), 0, 1);\n        \n        var X = A;\n        var Y = A * target_r + B * Math.pow(1 - Math.pow(target_r, 2), 0.5);\n        \n        arr.push({xVal: X, yVal: Y});\n        arrX.push(X);\n        arrY.push(Y);\n    }\n    // var stats = new Statistics(arr, {xVal: 'metric', yVal: 'metric'});\n    // r = stats.correlationCoefficient('xVal', 'yVal').correlationCoefficient;\n    console.log(arrX);\n    r = jStat.corrcoeff(arrX, arrY);\n    console.log(\"Actual r = \" + r);\n    return arr;\n}\n\nd3.select(\"#refresh\").on(\"click\", adjudicateGuesses);\nmakeChart();\n\n}"
  },
  {
    "objectID": "games/guess-the-correlation.html",
    "href": "games/guess-the-correlation.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Guess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\ngame = {\nconst f = d3.format(\".2f\");\nconst res = d3.format(\"+.2f\");\nconst line = d3.line();\n\n\n// SVG\n\nconst w = 500;\nconst h = 350;\nconst margin = {top: 10, right: 10, bottom: 30, left: 10}\nconst radius = 4;\nvar r;\nvar p1error, p2error, winnerIndex;\nvar scores = [0,0];\n\n\nconst scoreValues = [d3.select(\"#p1-points\"), d3.select(\"#p2-points\")];\n\n\nconst svg = d3.select(\".svg-container\")\n.append(\"svg\")\n.attr(\"class\", \"svg-content\")\n.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n.attr(\"viewBox\", `0 0 ${w} ${h}`);\n\nconst axisLine = svg.append(\"path\")\n    .style(\"stroke\", \"black\").style(\"fill\", \"none\")\n    .style(\"stroke-linecap\", \"square\").style(\"stroke-width\", 2);\n    \naxisLine.attr(\"d\", line([[margin.left, margin.top],\n                        [margin.left, h - margin.bottom],\n                        [w - margin.right, h - margin.bottom]]));\n                              \n\nfunction makeChart() {\n    var data = makeData(100);\n\n    var x = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.xVal), d3.max(data, d =&gt; d.xVal)])\n        .range([margin.left + 2*radius, w - margin.right - 2*radius])\n    const y = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.yVal), d3.max(data, d =&gt; d.yVal)])\n        .range([h - margin.bottom - 2*radius, margin.top + 2*radius])\n\n    svg.selectAll(\"circle\").remove();\n    svg.selectAll(\"circle\").data(data).enter()\n        .append(\"circle\")\n        .attr(\"cx\", d =&gt; x(d.xVal))\n        .attr(\"cy\", d =&gt; y(d.yVal))\n        .attr(\"r\", radius)\n        .style(\"fill\", \"plum\")\n        .style(\"opacity\", 0)\n        .transition().delay((d,i) =&gt; i * 10).duration(0)\n            .style(\"opacity\" ,1)\n \n}\n\nfunction adjudicateGuesses() {\n    var p1guess = d3.select(\"#p1-guess\").property(\"value\");\n    var p2guess = d3.select(\"#p2-guess\").property(\"value\");\n    p1error = r - p1guess;\n    p2error = r - p2guess;\n\n    var errors = [Math.abs(p1error), Math.abs(p2error)]\n    winnerIndex = errors.indexOf(Math.min(...errors));\n    \n    showResults();\n    addPoint(winnerIndex);\n    d3.select(\"#refresh\").text(\"Next\").on(\"click\", reset);\n}\n\nfunction showResults() {\n    let winner = Array(2).fill(\"\");\n    winner[winnerIndex] = \"&lt;span style='font-size: 2em;'&gt;👑&lt;/span&gt;\";\n    d3.select(\"#p1-error\").html(res(p1error * -1) + \"&lt;br&gt;\" + winner[0]);\n    d3.select(\"#p2-error\").html(res(p2error * -1) + \"&lt;br&gt;\" + winner[1]);\n    d3.select(\"#true-r\").text(\"True r = \" + f(r));\n}\n\nd3.select(\"#p1-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"🪙\")\nd3.select(\"#p2-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"🪙\")\n\nfunction addPoint(i) {\n    scores[i]++;\n    if(scores[i] &gt; 2) {\n        // declareWinner(i);\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    } else {\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    }\n}\n\nfunction declareWinner(winnerIndex) {\n    // alert(\"Player \" + (winnerIndex + 1) + \" wins!!!\")\n    // window.location.reload();\n}\n\n\nfunction reset() {\n    d3.selectAll(\".resettable\").html(\"\")\n    d3.selectAll(\".guess\").property(\"value\", \"\");\n    \n    d3.select(\"#refresh\").text(\"Guess\").on(\"click\", adjudicateGuesses);\n    makeChart();\n}\n\n// d3.selectAll(\".points-label\").each(() =&gt; this.on(\"click\", this.select()));\n\nfunction makeData(n) {\n    let arr = [];\n    let arrX = [];\n    let arrY = [];\n\n    var target_r = Math.random();\n    console.log(\"target r = \" + target_r);\n\n    for (var i = 0; i &lt; n; i++) {\n        var A = jStat.normal.inv(Math.random(), 0, 1);\n        var B = jStat.normal.inv(Math.random(), 0, 1);\n        \n        var X = A;\n        var Y = A * target_r + B * Math.pow(1 - Math.pow(target_r, 2), 0.5);\n        \n        arr.push({xVal: X, yVal: Y});\n        arrX.push(X);\n        arrY.push(Y);\n    }\n    // var stats = new Statistics(arr, {xVal: 'metric', yVal: 'metric'});\n    // r = stats.correlationCoefficient('xVal', 'yVal').correlationCoefficient;\n    console.log(arrX);\n    r = jStat.corrcoeff(arrX, arrY);\n    console.log(\"Actual r = \" + r);\n    return arr;\n}\n\nd3.select(\"#refresh\").on(\"click\", adjudicateGuesses);\nmakeChart();\n\n}"
  },
  {
    "objectID": "visualizations/mean-balance-beam.html",
    "href": "visualizations/mean-balance-beam.html",
    "title": "Central Tendency",
    "section": "",
    "text": "Central Tendency: The Mean as the Balance Point\n\n\nShow/hide deviations\n\n\nShow/hide squared deviations\n\n\n\n\n\n\nwidth = 600\nheight = 600\nn_boxes = 5\nscale_width = 11\nbox_size = width / scale_width\nbeam_height = box_size / 4\nradius = box_size\n\n// multiply the deviations lined up at the bottom to fit on the screen\nmultiplier = 6/n_boxes\n\nbox_data_ = make_box_data(n_boxes)\n\n\nchart = {\n\n  let deviations_hidden = false;\n  let squared_deviations_hidden = false;\n  \n  &lt;!-- const controls = d3.select(\"#controls\") --&gt;\n  &lt;!-- const button = controls --&gt;\n  &lt;!--     .append(\"input\") --&gt;\n  &lt;!--     .attr(\"type\", \"button\") --&gt;\n  &lt;!--     .attr(\"name\", \"showDevs\") --&gt;\n  &lt;!--     .attr(\"value\", \"Toggle\") --&gt;\n  &lt;!--     .attr(\"onclick\", noDevs) --&gt;\n\n  function round_position(x) {\n    let interval = width / scale_width\n    return Math.round(x / interval)*interval\n  }\n\n  function rounded_position_index(x) {\n    let interval = width / scale_width\n    let x0 = Math.round(x / interval)*interval\n    return Math.round(x0/(width/scale_width))  \n  }\n  \n  let positions = d3.range(scale_width).map(i =&gt; (0))\n\n  function stack_boxes() {\n    for (let i = 0; i &lt; box_data.length; i++) {\n      box_data[i].level = positions[box_data[i].x0]\n      positions[box_data[i].x0]++\n    }\n  }\n\n  let starting_boxes = [1, 2, 6, 6, 10]\n  \n  // let box_data = d3.range(n_boxes).map(i =&gt; ({\n  //     // x: (Math.random() * (width - box_size * 2) + box_size),\n  //     x0: Math.floor(Math.random() *   scale_width),\n  //     y: -box_size, // height/2 - beam_height/2 - radius,\n  //     color: d3.schemeCategory10[i % 10],\n  //     level: 0\n  //     }))\n      \n  let box_data = box_data_;\n\n  for (let i = 0; i &lt; box_data.length; i++) box_data[i].x = box_data[i].x0 * box_size\n  \n  \n  let mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n  let pivot = mean\n  \n  box_data = box_data.sort(function(a, b) { return Math.abs(a.x - pivot) - Math.abs(b.x - pivot); })\n  for (let i = 0; i &lt; box_data.length; i++) {\n    box_data[i].id = i\n  }\n    \n    stack_boxes()\n    \n    \n  const svg = d3.select(\"#chart\").append(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"stroke-width\", 2)\n\n  const x_ = d3.scaleLinear()\n    .range([0, width])\n    .domain([0, 10])\n    \n  // draw the ground\n  svg.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\", 50)\n    .attr(\"fill\", \"#f0f0f0\")\n    .attr(\"stroke\", \"none\")\n    .attr(\"transform\", `translate(0, ${height - 51})`)\n\n  const beam_and_boxes = svg.append(\"g\")\n    .attr(\"transform\", `translate(0, ${height - 50 - radius - beam_height})`)\n  \n  // draw the beam\n  beam_and_boxes.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\",  beam_height)\n    .attr(\"rx\", 3)\n    .attr(\"fill\", \"black\")\n    // .attr(\"transform\", `translate(0, ${height/2 - beam_height / 2})`)\n\n  const boxes = beam_and_boxes.append(\"g\")\n  const deviations = beam_and_boxes.append(\"g\")\n  const deviations_vertical = deviations.append(\"g\")\n  const deviations_horizontal = deviations.append(\"g\")\n  const deviations_sum = svg.append(\"g\").attr(\"transform\", `translate(0, ${height - 25})`)\n  const deviations_sum_negative = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, -10)`)\n  const deviations_sum_positive = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, 10)`)\n  \n  // draw the boxes\n  boxes.selectAll(\"rect\")\n    .data(box_data)\n    .join(\"rect\")\n      .attr(\"x\", d =&gt; d.x)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n      .attr(\"width\", box_size)\n      .attr(\"height\", box_size)\n      .attr(\"rx\", 1)\n      .attr(\"fill\", d =&gt; d.color)\n      .attr(\"stroke\", null)\n      .call(d3.drag().on(\"start\", start_dragging_box)\n                     .on(\"drag\", dragging_box)\n                     .on(\"end\", stop_dragging_box));\n  \n  // draw a circle at the true mean point\n  const circle = beam_and_boxes.append(\"circle\")\n    .attr(\"cx\", mean)\n    .attr(\"cy\", beam_height/2)\n    .attr(\"r\", 5)\n    .attr(\"fill\", \"#777777\")\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n  // draw a triangle at the pivot point\n  const triangle = svg.append(\"polygon\")\n    .attr(\"points\", [[0, -radius/2], [radius/2, radius/2], [-radius/2, radius/2]])\n    .attr(\"fill\", \"red\")\n    .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n    \n  draw_deviations()\n  \n\n  function start_dragging_mean(event, d) {triangle.attr(\"fill\", \"dodgerblue\")}\n  \n  function stop_dragging_mean(event, d) {triangle.attr(\"fill\", \"red\")}\n  \n  function dragging_mean(event, d) {\n      pivot = event.x\n      tip_scale()\n  }\n  \n  function tip_scale() {\n  \n    let angle = Math.abs((mean - pivot)*0.5);\n    let hypotenuse, direction;\n    \n    if (pivot &lt; mean) {\n      hypotenuse = width - pivot;\n      direction = 1;\n    } else {\n      hypotenuse = pivot;\n      direction = -1;\n    }\n    \n    let tri_angle = 90 - (Math.acos(radius / hypotenuse) * 180/Math.PI)\n    angle = direction * (Math.min(angle, tri_angle))\n    \n      triangle\n        .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n      beam_and_boxes\n        .attr(\"transform\", `translate(0, ${height-50-radius-beam_height}) rotate(${angle}, ${pivot}, ${0})`)\n      draw_deviations()\n  }\n\n  \n  function start_dragging_box(event, d) {\n    d3.select(this).raise().attr(\"stroke\", \"black\")\n    // console.log(\"x:\" + d.x + \" x0:\" + d.x0 + \" level:\" + d.level)\n  }\n\n  function dragging_box(event, d) {\n    box_data[d.id].x = event.x\n    // box_data[d.id].x0 = round_position(box_data[d.id].x) + box_size/2\n    \n    let current_position = box_data[d.id].x0\n    let current_level = box_data[d.id].level\n    let new_position = rounded_position_index(event.x)\n    \n    if(new_position != current_position) {\n      console.log(\"moved! from \" + current_position + \" to \" + new_position)\n      \n      // update the box's position\n      box_data[d.id].x0 = new_position\n      \n      // now this box should go on top of the stack for new_position\n      box_data[d.id].level = positions[new_position]\n      \n      // and update the total number of boxes in that position\n      positions[new_position]++\n      \n      // for the old position, reduce the number of boxes by one, and\n      // bump down any boxes that had a higher level that this box\n      positions[current_position]--\n      for (let i = 0; i &lt; box_data.length; i++) {\n        if (d.id==i) continue\n        if (box_data[i].x0==current_position && box_data[i].level &gt; current_level) {\n            box_data[i].level--\n            console.log(\"movin on down\")\n        } \n      }\n    }\n    \n    tip_scale()\n    // draw_deviations()\n  }\n\n  function stop_dragging_box(event, d) {\n    d3.select(this).attr(\"stroke\", null)\n  }\n  \n  \n\n\n  function draw_deviations() {\n    \n    mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n    \n    boxes.selectAll(\"rect\")\n      .attr(\"x\", d =&gt; d.x0 * box_size)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n    \n    circle.attr(\"cx\", mean)\n    \n    // calculate deviations\n    for (let i = 0; i &lt; box_data.length; i++) box_data[i].dev = (box_data[i].x0*box_size + (box_size/2)) - pivot\n    \n    let deviations_negative = box_data.filter(function(d){ return d.dev &lt; 0})\n    for (let i = 0; i &lt; deviations_negative.length; i++) {\n      if (i==0) deviations_negative[i].dev_start = 0\n      else deviations_negative[i].dev_start = deviations_negative[i-1].dev_end\n      deviations_negative[i].dev_end = deviations_negative[i].dev_start + Math.abs(deviations_negative[i].dev)\n    }\n    \n    let deviations_positive = box_data.filter(function(d){ return d.dev &gt; 0})\n    for (let i = 0; i &lt; deviations_positive.length; i++) {\n      if (i==0) deviations_positive[i].dev_start = 0\n      else deviations_positive[i].dev_start = deviations_positive[i-1].dev_end\n      deviations_positive[i].dev_end = deviations_positive[i].dev_start + Math.abs(deviations_positive[i].dev)\n    }\n    \n    deviations_vertical.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"y1\", d =&gt; d.y - d.level * box_size)\n        .attr(\"y2\", d =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        \n    deviations_vertical\n      .append(\"line\")\n      .attr(\"x1\", pivot).attr(\"x2\", pivot)\n      .attr(\"y1\", 0).attr(\"y2\", -height)\n      .attr(\"stroke\", \"red\").attr(\"stroke-dasharray\", [10, 10])\n\n    deviations_horizontal.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", pivot)\n        .attr(\"y1\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"y2\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 3)\n        \n    if (!squared_deviations_hidden) update_squared_deviations();\n    \n\n    deviations_sum_negative.selectAll(\"line\")\n      .data(deviations_negative)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n        \n    deviations_sum_positive.selectAll(\"line\")\n      .data(deviations_positive)\n      .join(\"line\")\n      .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n  };\n  \n  \n  function update_squared_deviations() {\n      deviations_horizontal.selectAll(\"rect\")\n      .data(box_data)\n      .join(\"rect\")\n        .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n        .attr(\"width\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", function(d){if(squared_deviations_hidden){return 0} else{return Math.abs(d.dev)}})\n        .attr(\"fill\", d =&gt; d.color)\n        .attr(\"opacity\", 0.5)\n        .attr(\"stroke\", \"none\")\n  }\n  \n  \n\n  function noDevs() {\n    deviations_hidden = !deviations_hidden\n    deviations.attr(\"opacity\", Number(!deviations_hidden))\n  }\n  \n  function noDevsSq() {\n    squared_deviations_hidden = !squared_deviations_hidden\n  \n    if (squared_deviations_hidden) {\n      deviations_horizontal\n        .selectAll(\"rect\")\n        .data(box_data)\n        .transition().duration(1000)\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"height\", 0)\n    } else {\n        deviations_horizontal\n          .selectAll(\"rect\")\n          .data(box_data)\n          .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n          .attr(\"width\", d =&gt; Math.abs(d.dev))\n          .transition().duration(1000)\n          .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n          .attr(\"height\", d =&gt; Math.abs(d.dev))\n    }\n    \n  }\n\n  noDevs()\n  noDevsSq()\n  d3.select(\"#showDevs\").on(\"click\", noDevs)\n  d3.select(\"#showDevsSq\").on(\"click\", noDevsSq)\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction make_box_data(n) {\n    return d3.range(n).map(i =&gt; ({\n      // x: (Math.random() * (width - box_size * 2) + box_size),\n      x0: Math.floor(Math.random() *   scale_width),\n      y: -box_size, // height/2 - beam_height/2 - radius,\n      color: d3.schemeCategory10[i % 10],\n      level: 0\n      }))\n  }"
  },
  {
    "objectID": "visualizations/least-squared-error.html",
    "href": "visualizations/least-squared-error.html",
    "title": "Least Squared Error",
    "section": "",
    "text": "Regression: The Least Squared Error Solution\nIntercept (\\(a\\)): hi \nSlope (\\(b\\)): hi \n\n\n\n\nchangable_chart = {\n\n  const w = 600;\n  const h = 500;\n  \n  const margin = {top: 20, right: 20, left: 110, bottom: 75}\n\n  const x_values = [4,5,7,8,11]\n  const y_values = [5,8,8,10,9]\n  const yhat_values = [0,0,0,0,0]\n  \n  const data = [{xVal: 4, yVal: 5},\n                {xVal: 5, yVal: 8},\n                {xVal: 7, yVal: 8},\n                {xVal: 8, yVal: 10},\n                {xVal: 11, yVal: 9}]\n                \n  const aInput = d3.select(\"#a-control\")\n  const bInput = d3.select(\"#b-control\")\n  \n  aInput.on(\"input\", drawFitLine);\n  bInput.on(\"input\", drawFitLine);\n  \n  const x = d3.scaleLinear()\n    .range([margin.left, w - margin.right])\n    .domain([0, 12])\n  const y = d3.scaleLinear()\n    .range([h - margin.bottom, margin.top])\n    .domain([0, 10])\n  \n  const xAxis = d3.axisBottom(x);\n  const yAxis = d3.axisLeft(y);\n  \n  \n  const svg = d3.select(\"#error-plot-container\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n    \n  const axes = svg.append(\"g\")\n  const axisFontSize = \"0.7em\"\n  axes.append(\"g\").attr(\"transform\", `translate(0, ${h - margin.bottom})`).call(xAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  axes.append(\"g\").attr(\"transform\", `translate(${margin.left}, 0)`).call(yAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  \n  const axisTitles = svg.append(\"g\")\n    .style(\"font-size\", \"0.8em\")\n    .style(\"font-family\", \"Times New Roman\")\n    .style(\"fill\", \"var(--text-color)\")\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(${margin.left + (w - margin.left - margin.right) / 2}, ${h - 10})`).text(\"Sleep duration\")\n    .attr(\"text-anchor\", \"middle\");\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(0, ${margin.top + (h - margin.top - margin.bottom) / 2})`)\n    .text(\"Score\")\n    \n  \n  const residuals = svg.append(\"g\")\n  residuals.selectAll(\"line\").data(data).enter()\n      .append(\"line\")\n        .attr(\"x1\", d =&gt; x(d.xVal))\n        .attr(\"x2\", d =&gt; x(d.xVal))\n        .attr(\"y1\", d =&gt; y(d.yVal))\n        &lt;!-- .attr(\"y2\", d =&gt; y(d.yVal)) --&gt;\n        .style(\"stroke\", \"red\")\n        .style(\"stroke-width\", 2)\n        .attr(\"stroke-dasharray\", [5, 3])\n        \n  const fitLine = svg.append(\"line\")\n    .style(\"stroke\", \"dodgerblue\")\n    .style(\"stroke-width\", 3)\n    \n  const dots = svg.append(\"g\")\n  const squares = svg.append(\"g\")\n  const ssResidualSquare = svg.append(\"g\").append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.5)\n    \n  dots.selectAll(\"circle\").data(data).enter().append(\"circle\")\n    .attr(\"cx\", d =&gt; x(d.xVal))\n    .attr(\"cy\", d =&gt; y(d.yVal))\n    .attr(\"r\", 5)\n    .style(\"fill\", \"var(--text-color)\")\n    \n  squares.selectAll(\"polygon\").data(data).enter()\n    .append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.5)\n    \n  function drawFitLine() {\n    var a = Number(aInput.property(\"value\"));\n    d3.select(\"#a-output\").text(a);\n    var b = Number(bInput.property(\"value\"));\n    d3.select(\"#b-output\").text(b);\n    \n    var yhat1 = a\n    var yhat2 = b * 12 + a\n    \n    fitLine\n      .attr(\"x1\", x(0))\n      .attr(\"x2\", x(12))\n      .attr(\"y1\", y(yhat1))\n      .attr(\"y2\", y(yhat2))\n      \n    var ssResidual = 0;\n    \n    for(var i = 0; i &lt; data.length; i++) {\n      var yHat = b * data[i].xVal + a;\n      var residual = data[i].yVal - yHat\n      data[i].yHat = yHat;\n      data[i].res = residual;\n      \n      ssResidual += Math.pow(residual, 2);\n    }\n    \n    residuals.selectAll(\"line\")\n        .attr(\"y2\", d =&gt; y(d.yHat))\n        \n    squares.selectAll(\"polygon\")\n      .attr(\"points\", d =&gt; [[x(d.xVal), y(d.yVal)],\n                            [x(d.xVal), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yVal)]])\n                            \n    ssResidualSquare\n    .attr(\"points\", [[x(9), y(3)],\n                     [x(9), y(3 - Math.sqrt(ssResidual))],\n                     [x(9 + Math.sqrt(ssResidual)), y(3 - Math.sqrt(ssResidual))],\n                     [x(9 + Math.sqrt(ssResidual)), y(3)]])\n  }\n  \n  drawFitLine();\n  \n  svg.append(\"polygon\")\n    .attr(\"points\", [[x(9), y(3)],\n                     [x(9), y(3 - Math.sqrt(6.5))],\n                     [x(9 + Math.sqrt(6.5)), y(3 - Math.sqrt(6.5))],\n                     [x(9 + Math.sqrt(6.5)), y(3)]])\n    .style(\"fill\", \"none\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-dasharray\", [5, 3])\n    \n\n  \n\n}\n\n\n\n\n\n\n\n\nAbout\nExplanation goes here."
  },
  {
    "objectID": "visualizations/least-squared-error.html#about",
    "href": "visualizations/least-squared-error.html#about",
    "title": "Least Squared Error",
    "section": "",
    "text": "Explanation goes here."
  },
  {
    "objectID": "visualizations/confidence-intervals.html",
    "href": "visualizations/confidence-intervals.html",
    "title": "Confidence Intervals",
    "section": "",
    "text": "CI = 80%\n\n\nDraw cards\n\n\n\n\n\n\n\n\n\nM = \n\n\n\n\n\n\n\n#% of # samples contain mu\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\nchart = {\n\n  const sampleSize = 10;\n  let sampling = false;\n  let sample = [];\n\n  const w = 1050\n  const h = 600\n  const margin = {left: 50, right: 50, top: 50, bottom: 50}\n  \n  let x = d3.scaleLinear()\n    .domain([0, 30])\n    .range([margin.left, w - margin.right])\n  const y = d3.scaleLinear()\n    .domain([2, 12])\n    .range([h - margin.bottom, margin.top])\n    \n  const yAxis = d3.axisLeft(y)\n    .ticks(11)\n\n  const f = d3.format(\".2f\")\n\n  var sampleArr = []\n  var meansArr = []\n  var ciArr = []\n  \n  const ciInput = document.getElementById('ci-input')\n  const buttonRandom = document.getElementById('addRandom');\n  \n  var ciWidth = Number(ciInput.value)\n\n  function makeCards(n, divId) {\n    for (let i = 0; i &lt; n; i++) {\n\n      d3.select(\"#\" + divId).append(\"div\")\n        .attr(\"id\", \"card\" + (i + 1))\n        .attr(\"class\", \"playing-card-container\")\n        .classed(\"playing-card-blank\", true)\n    }\n  }\n\n  makeCards(sampleSize, \"cards\");\n  \n  \n  function addSampleToPlot(values) {\n  \n    let mean = getM(values)\n    let sd = getSD(values)\n    let ci = getCI(values, ciWidth)\n    let containsMu = ciContainsMu(mean, ci)\n    let n = sampleArr.length + 1\n    \n    sampleArr.push({sample: values, mean: mean, ci: ci, containsMu: containsMu, id: n})\n    \n    // addCI(sampleArr.length, mean, ci)\n    drawCIs(sampleArr);\n\n    d3.select(\"#proportion\").text(Math.round(proportionOfCIs(sampleArr) * 100));\n    d3.select(\"#count\").text(sampleArr.length);\n    d3.select(\"#mean\").text(f(mean) + \" [\" + f(mean - ci) + \", \" + f(mean + ci) + \"]\");\n  }\n  \n  buttonRandom.onclick = () =&gt; newSample(false);\n  d3.select(\"#drawContinuously\").on(\"click\", sampleContinuously);\n\n  function newSample(quick = true) {\n\n    sample = [];\n    for (let i = 1; i &lt; sampleSize + 1; i++) {\n      const value = Math.floor(Math.random() * 12 + 1);\n      sample.push(value);\n      d3.select(\"#card\" + i).html(randomCard(value - 1))\n    }\n\n    addSampleToPlot(sample);\n\n    if (!quick) {\n    d3.selectAll(\".playing-card-container\")\n      .data(sample)\n      .classed(\"playing-card-blank\", true)\n      .transition().duration(0).delay((d,i) =&gt; 100 + i * 100)\n      .attr(\"class\", \"playing-card-container\")\n    }\n\n  }\n  \n  function randomCard(value) {\n\n    const suits = [\"\\u2660\",\"\\u2665\",\"\\u2666\",\"\\u2663\"];\n    const colors = [\"black\", \"red\", \"red\", \"black\"];\n    const cards = [\"A\",2,3,4,5,6,7,8,9,10,\"J\",\"Q\",\"K\"];\n    \n    const suitIndex = Math.floor(Math.random() * suits.length);\n    const cardIndex = value;\n\n    return \"&lt;div class='playing-card-value'&gt;\" + cards[cardIndex] + \"&lt;/div&gt;\" + \"&lt;div class='playing-card playing-card-\" + colors[suitIndex] + \"'&gt;\" + suits[suitIndex] + \"&lt;/div&gt;\";\n  }\n  \n  ciInput.oninput = function() {\n    ciWidth = ciInput.value\n    d3.select(\"#ci-width\").text(ciWidth);\n    updateCIs(ciWidth)\n\n    const newCI = getCI(sample, ciWidth);\n    const m = getM(sample);\n    d3.select(\"#mean\").text(f(m) + \" [\" + f(m - newCI) + \", \" + f(m + newCI) + \"]\");\n  }\n\nlet samplingInterval;\nconst sampleContinuouslyBtn = d3.select(\"#drawContinuously\");\n\n  function sampleContinuously() {\n\n    if (!sampling) {\n      sampling = true;\n      d3.selectAll(\".playing-card-container\")\n      .classed(\"playing-card-blank\", false);\n\n      samplingInterval = setInterval(() =&gt; {\n        newSample();\n    }, 200);\n\n    sampleContinuouslyBtn.html(\"&lt;i class='bi bi-stop'&gt;&lt;/i&gt;\").attr(\"class\", \"btn btn-danger\")\n\n    } else {\n      sampleContinuouslyBtn.html(\"&lt;i class='bi bi-play'&gt;&lt;/i&gt;\").attr(\"class\", \"btn btn-outline-success\")\n      clearInterval(samplingInterval);\n      sampling = false;\n    }\n  }\n\n  \n  \n  const svg = d3.select(\"#plot-container\").append(\"svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + w + \" \" + h)\n    \n  const gridY = svg.append(\"g\")\n  \n  // population mean line\n  gridY.append(\"line\")\n    .attr(\"x1\", x(0))\n    .attr(\"x2\", x(30))\n    .attr(\"y1\", y(7))\n    .attr(\"y2\", y(7))\n    .style(\"stroke\", \"grey\")\n    .attr(\"stroke-width\", 2)\n  gridY.append(\"text\")\n    .attr(\"x\", x(0.2))\n    .attr(\"y\", y(7.05))\n    .text(\"true population mean\")\n    \n  const lines = svg.append(\"g\")\n  const dots = svg.append(\"g\")\n  \n  const axisY = svg.append(\"g\")\n  axisY.append(\"rect\").attr(\"x\", -margin.left).attr(\"width\", margin.left).attr(\"height\", h)\n    .attr(\"fill\", \"var(--mermaid-bg-color)\");\n  axisY.call(yAxis)\n    .attr(\"transform\", `translate(${x(0)},0)`)\n\n  \n  function drawCIs(arr) {\n\n    const n = arr.length;\n\n    if (n &gt; 30) {\n      x.domain([n - 30, n]);\n    }\n  \n  &lt;!-- dot for the point estimate --&gt;\n  dots.selectAll(\"circle\").remove();\n\n    dots.selectAll(\"circle\").data(arr).enter().append(\"circle\")\n      .attr(\"r\", 4)\n      .attr(\"cx\", d =&gt; x(d.id))\n      .attr(\"cy\", d =&gt; y(d.mean))\n  \n  // lines.selectAll(\"line\")\n  //   .attr(\"x1\", x(n))\n  //   .attr(\"x2\", x(n))\n  \n  &lt;!-- lines for CI --&gt;\n  lines.selectAll(\"line\").remove();\n  \n  lines.selectAll(\"line\").data(arr).enter().append(\"line\")\n      .attr(\"x1\", d =&gt; x(d.id))\n      .attr(\"x2\", d =&gt; x(d.id))\n      .attr(\"y1\", d =&gt; y(d.mean + d.ci))\n      .attr(\"y2\", d =&gt; y(d.mean - d.ci))\n      .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", d =&gt; d.containsMu)\n      .classed(\"newest-line\", d =&gt; (d.id == n) ? true : false)\n\n    // lines.selectAll(\".newest-line\")\n    // .transition().duration(0)\n    //   .attr(\"y1\", y(arr[n-1].mean)).attr(\"y2\", y(arr[n-1].mean))\n    // .transition().duration(250)\n    //   .attr(\"y1\", y(arr[n-1].mean + arr[n-1].ci)).attr(\"y2\", y(arr[n-1].mean - arr[n-1].ci))\n\n    if (n &gt; 30) {\n      dots.selectAll(\"circle\")\n      .transition().duration(200).ease(d3.easeLinear)\n      .attr(\"cx\", d =&gt; x(d.id - 1))\n\n      lines.selectAll(\"line\")\n      .transition().duration(200).ease(d3.easeLinear)\n      .attr(\"x1\", d =&gt; x(d.id - 1))\n      .attr(\"x2\", d =&gt; x(d.id - 1))\n    }\n\n      \n  }\n\n\n\n\n\n  function updateCIs (confidence) {\n  \n  &lt;!-- take the array and recalculate all CIs --&gt;\n  const n = sampleArr.length;\n  for (var i = 0; i &lt; sampleArr.length; i++) {\n    sampleArr[i].ci = getCI(sampleArr[i].sample, confidence);\n    sampleArr[i].containsMu = ciContainsMu(sampleArr[i].mean, sampleArr[i].ci);\n  }\n  \n  &lt;!-- then redraw all CIs on the svg --&gt;\n  lines.selectAll(\"line\").remove()\n  \n  lines.selectAll(\"line\")\n  .data(sampleArr)\n  .enter()\n    .append(\"line\")\n      .attr(\"x1\", d =&gt; (n &gt; 30) ? x(d.id - 1) : x(d.id))\n      .attr(\"x2\", d =&gt; (n &gt; 30) ? x(d.id - 1) : x(d.id))\n      .attr(\"y1\", d =&gt; y(d.mean + d.ci))\n      .attr(\"y2\", d =&gt; y(d.mean - d.ci))\n      .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", d =&gt; ciContainsMu(d.mean, d.ci))\n    \n    d3.select(\"#proportion\").text(Math.round(proportionOfCIs(sampleArr) * 100));\n  }\n  \n  \n  \n}\n\n\nfunction getM (array) {\n  const n = array.length\n  const mean = array.reduce((a, b) =&gt; a + b) / n\n  return mean\n}\n\nfunction getSD (array) {\n  const n = array.length\n  const df = n - 1\n  const mean = getM(array)\n  return Math.sqrt(array.map(x =&gt; Math.pow(x - mean, 2)).reduce((a, b) =&gt; a + b) / df)\n}\n\nfunction getCI (array, confidence) {\n  const pt = 1 - (100 - confidence)/100 * 0.5\n  const n = array.length\n  // const sd = getSD(array)\n  const sd = 3.778162;\n  // const t = jStat.studentt.inv(pt, n - 1)\n  const t = jStat.normal.inv(pt, 0, 1);\n  console.log(sd);\n  return t * (sd / Math.sqrt(n))\n\n}\n\n\nfunction ciContainsMu (point, ci) {\n  return (point + ci &gt; 7 && point - ci &lt; 7);\n}\n\nfunction proportionOfCIs(arr) {\n    const x = arr.map(a =&gt; a.containsMu);\n    const prop = x.reduce((acc, curr) =&gt; {\n  return acc + (curr ? curr : 0);\n}, 0);\n\n    return prop / arr.length;\n}"
  }
]