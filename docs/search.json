[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nRegression: The Least Squared Error Method\nConfidence Intervals"
  },
  {
    "objectID": "index.html#visualizations",
    "href": "index.html#visualizations",
    "title": "PSYCH STATS",
    "section": "Visualizations",
    "text": "Visualizations\nInteractive visualizations of fundamental statistical concepts.\nCentral Tendency and the Mean\nSampling\n(Un)Biased Estimates\nRegression: The Least Squared Error Method\nConfidence Intervals"
  },
  {
    "objectID": "index.html#games",
    "href": "index.html#games",
    "title": "PSYCH STATS",
    "section": "Games",
    "text": "Games\nSome â€˜gamesâ€™ (Iâ€™m using the term loosely!) that I use to illustrate statistical concepts or generate data for analysis.\nGuess the Correlation\nTriplett\nJellybeans\nQuincunx\nDice Roller\n\nbannerImage = {\n\n    const svg = d3.select(\".quarto-title\").append(\"svg\")\n        .attr(\"id\", \"title-svg\")\n        .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n        .attr(\"viewBox\", \"0 0 \" + 50 + \" \" + 20)\n\n    svg.selectAll(\"circle\").data(data).enter().append(\"circle\")\n        .attr(\"cx\", d => d.x)\n        .attr(\"cy\", d => 20 - d.y)\n        .attr(\"r\", 0)\n        .attr(\"stroke\", \"none\")\n        .attr(\"fill\", (d, i) => d3.schemeCategory10[i % 10])\n        .transition().duration(300)\n        .delay(d => d.y * 100)\n        .attr(\"r\", radius/2)\n\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website was made by Rob Brotherton. Iâ€™m an academic psychologist and writer. I teach statistics and political psychology at Barnard College in New York City.\n\n\nThis site collects together some of the visualizations and games Iâ€™ve made as part of my statistics course. Statistics, at its core, is about understanding the patterns and principles that govern our world, and itâ€™s much more than just a set of abstract equations. To help bring this vision to life, I created an array of interactive visualizations and games. Rather than just learning about a statistical concept like the Central Limit Theorem, these help you to experience it in action, to see the narratives that numbers can create. My hope is to bridge the gap between abstract equations and hypothetical distributions on one hand, and on the other hand, the real, messy processes that somehow produce those predictable patterns. Seeing these basic processes in action goes a long way towards understanding how statistical stories play out in our day-to-day lives.\nThe design philosophy is grounded in the notion that statistics is a tactile, organic, and sometimes messy process. I consciously avoid the conventional abstract approach to teaching statistics. The visualizations I use show statistical populations not as abstract curves, but as hundreds of individual dots piled up into a normal (or not-so-normal) distribution. When you draw a sample from these populations, you can see and interact with the specific dots that have been selected. This is designed to instill a sense of the concrete nature of statistics, reinforcing that behind every data point, there is a story, a reality.\nThis approach to bringing statistics to life is embodied in my choice of visual design. The website is crafted in bright colors and a â€˜sketchyâ€™ bootstrap theme that harks back to a time of hand-drawn graphs and chalkboard equations. The intention is to remind users that what they are interacting with is not a dry, abstract mathematical concept, but a dynamic process that reflects the vibrant, sometimes chaotic reality of our world. Itâ€™s about more than numbers â€“ itâ€™s about people, processes, and the fascinating patterns that tie it all together."
  },
  {
    "objectID": "visualizations/unbiased-estimates.html",
    "href": "visualizations/unbiased-estimates.html",
    "title": "(Un)Biased estimates",
    "section": "",
    "text": "Show: \\(M\\) \\(SD_{n}\\) \\(SD_{n - 1}\\)"
  },
  {
    "objectID": "visualizations/sampling/sampling.html",
    "href": "visualizations/sampling/sampling.html",
    "title": "Sampling",
    "section": "",
    "text": "Distribution:  Normal Positive skew Negative skew Uniform Custom  Sample size:  Reset\n\n\n\n\n\n\nTake a sample\n\n\nStart\n\n\nStop\n\n\n1,000\n\n\n10,000\n\n\n100,000\n\n\nclear\n\n\n\n\n\n\nimport {sampling} from \"./sampling-backend.qmd\""
  },
  {
    "objectID": "visualizations/sampling/sampling-backend.html",
    "href": "visualizations/sampling/sampling-backend.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsampling = {\n    // https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n// https://onlinestatbook.com/stat_sim/sampling_dist/\n\nlet width = 700;\nlet height = 700;\nlet x0 = width / 2;\n\nlet populationHeight = height * 0.4;\nlet sampleHeight = 50;\nlet samplingDistributionHeight = height - (populationHeight + sampleHeight);\n\n// ball properties\nconst ballRadius = 5;\nlet generationSpeed = 1;\nlet nBalls = 500;\n\nlet sampleSize = d3.select(\"#sampleSize\").property(\"value\");\nlet distributionFunction = d3.select(\"#dist\").value\n\nlet balls = [], means = [], currentMean;\n\n\n\nlet showSleeping = false;\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet engine, render, runner, world;\n\nvar pos, mouseX, mouseY;\n\nlet populationMean = x0;\nlet populationSd = width * 0.12;\nlet updatePopulationInterval;\nlet creationIntervalId;\n\nlet y = d3.scaleLinear()\n    .domain([0, jStat.normal.pdf(x0, x0, 80 / Math.sqrt(sampleSize))])\n    .range([samplingDistributionHeight, 0])\n\n\n\n    \n// ========================================================================== //\n// Buttons and listeners\n// ========================================================================== //\n\nd3.select( \"#singleSampleBtn\").on(\"click\", logBalls)\nd3.select(\"#startSamplingBtn\").on(\"click\", takeSamples)\nd3.select( \"#stopSamplingBtn\").on(\"click\", stopSamples)\nd3.select(  \"#samples1000Btn\").on(\"click\", e =&gt; takeNSamples(1000))\nd3.select( \"#samples10000Btn\").on(\"click\", e =&gt; takeNSamples(10000))\nd3.select( \"#samples100000Btn\").on(\"click\", e =&gt; takeNSamples(100000))\nd3.select( \"#clearSamplesBtn\").on(\"click\", resetMeans)\n\nconst sampleSizeInput = d3.select(\"#sampleSize\")\n    .on(\"change\", function () {\n        resetMeans();\n        sampleSize = d3.select(\"#sampleSize\").property(\"value\");\n        updateSamplingDistributionParams();\n        updateSamplingDistributionDescriptives(true);\n        updateSampleDescriptives();\n        drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    });\n\nconst distributionInput = d3.select(\"#dist\")\n    .on(\"change\", function () {\n        reset();\n    });\n\nfunction scaleCanvas() {\n    console.log(document.getElementById(\"quarto-document-content\").offsetWidth)\n    // var availableWidth = window.visualViewport.width;\n    // var availableWidth = d3.select(\"#container\").attr(\"width\")\n\n    var availableWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = Math.min(1, availableWidth / (width * 1));\n    d3.select(\"#container\")\n        .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    d3.select(\"#flex-container\")\n        .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    d3.select(\"#container\")\n        .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n\n// ========================================================================== //\n// Physics\n// ========================================================================== //\n\n// physics properties\nconst populationDotParams = {\n    label: \"circle\",\n    restitution: 0,\n    friction: 0.1,\n    frictionAir: 0.045,\n    frictionStatic: 1,\n    slop: 0,\n    mass: 0.1,\n    density: 100,\n    sleepThreshold: 15,\n    collisionFilter: { group: 1 }\n}\n\nfunction populationDotColor() {\n    return d3.schemeCategory10[Math.floor(Math.random() * 10)]\n}\n\n// let restitution = 0; // bounciness\nlet friction = Infinity;\n// let frictionAir = 0.05;\nlet frictionStatic = Infinity;\n// let slop = 0;\n// let mass = 0.1;\n// let density = 100;\n\n\n\n\nfunction initialize() {\n\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n\n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"container\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: showSleeping\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    engine.positionIterations = 6;\n    engine.velocityIterations = 8;\n\n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.position = \"absolute\";\n\n    drawDots();\n}\n\nfunction drawDots() {\n    var isDrawing = false;\n    function startDrawing(x, y) {\n        isDrawing = true;\n        resetMeans();\n        Composite.add(world, makePopulationDot(x, y, ballRadius));\n        creationIntervalId = setInterval(function () {\n            if (pos.y &gt; (populationHeight - 5)) {\n                stopDrawing;\n                return null;\n            }\n            Composite.add(world, makePopulationDot(pos.x, pos.y, ballRadius));\n        }, generationSpeed);\n        updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n    }\n    function stopDrawing() {\n        isDrawing = false;\n        clearInterval(creationIntervalId);\n    }\n\n    // Add an event listener to the canvas to detect mouse clicks\n    render.canvas.addEventListener('mousedown', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    render.canvas.addEventListener('touchstart', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    // Update the mouse position if it's moved\n    render.canvas.addEventListener('mousemove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n    render.canvas.addEventListener('touchmove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n\n\n    // Stop generating balls when the mouse button is released\n    render.canvas.addEventListener('mouseup', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('mouseout', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('touchend', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n}\n\nconst getRelativeMousePosition = (event, target) =&gt; {\n    const bounds = target.getBoundingClientRect();\n    const scaleX = target.width / bounds.width;\n    const scaleY = target.height / bounds.height;\n    const clientX = event.clientX || event.touches[0].clientX;\n    const clientY = event.clientY || event.touches[0].clientY;\n    return {\n        x: (clientX - bounds.left) * scaleX,\n        y: (clientY - bounds.top) * scaleY,\n    };\n};\n\n// ========================================================================== //\n//      Make the world\nvar panelRadius = [10, 10, 10, 10];\nfunction makeGround() {\n    // background of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight * 0.5, width, populationHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"dodgerblue\", opacity: 0.3 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + 4, width * 2, 10, {\n            isStatic: true,\n            density: Infinity,\n            collisionFilter: { group: 1, category: 1, mask: 0 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight * 0.5, width, sampleHeight - 10, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d3d8a9\" },\n            chamfer: { radius: panelRadius }\n        })\n    );\n    // floor of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight, width, 10, {\n            friction, frictionStatic,\n            density: Infinity, mass: Infinity,\n            isStatic: true,\n            collisionFilter: { group: 2, category: 4, mask: 2 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height - samplingDistributionHeight * 0.5, width, samplingDistributionHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d49fd4\", opacity: 0.7 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height + 9, width, 20, {\n            friction, frictionStatic,\n            isStatic: true,\n            collisionFilter: { group: 3, category: 8, mask: 6 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n}\n\n\n\n// ========================================================================== //\n//      Generate population\n\nlet intervalId;\n\nfunction makePopulation(distributionFunction) {\n\n    clearInterval(intervalId);\n    let total = nBalls;\n\n    if (distributionFunction == \"custom\") { total = 0 };\n\n    intervalId = setInterval(() =&gt; {\n\n        if (total-- &gt; 0) {\n\n            let x = distributionFunction();\n            let y = -500 + Math.random() * 500;\n\n            let circle = makePopulationDot(x, y, ballRadius);\n            Matter.Composite.add(world, circle);\n\n        }\n    }, generationSpeed);\n}\n\n\nfunction makePopulationDot(x, y, radius) {\n    \n    let dot = Matter.Bodies.circle(x, y, radius, populationDotParams);\n    dot.render.fillStyle = populationDotColor();\n    \n    Events.on(dot, \"sleepStart\", function () {\n        dot.isStatic = true;\n        balls.push(dot);\n        updateDescriptives();\n    });\n\n    return dot;\n}\n\n\n// ========================================================================== //\n//      Update population\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"circle\" && !body.isStatic));\n};\n\nlet populationInterval;\n\nfunction checkStatic(body) {\n    return body.isStatic;\n}\n\nlet popChecks = 0;\nfunction updatePopulation() {\n    console.log(\"checking pop\");\n    popChecks++;\n    let allBalls = world.bodies.filter((body) =&gt; (body.label === \"circle\"));\n\n    // compute the population mean\n    let total = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        total += allBalls[i].position.x;\n    }\n    populationMean = total / allBalls.length;\n\n    let ss = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        ss += Math.pow(allBalls[i].position.x - populationMean, 2);\n    }\n    populationSd = Math.sqrt(ss / allBalls.length);\n    // console.log(populationSd);\n    drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    updateSamplingDistributionParams();\n    if (allBalls.every(checkStatic) || popChecks &gt; 1000) {\n        popChecks = 0;\n        clearInterval(updatePopulationInterval);\n    }\n}\n\nlet existingMeans = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"mean\"));\n};\n\nconst makeStaticMeanInterval = setInterval(() =&gt; {\n    existingMeans().forEach(function (mean) {\n        let meanHeight = mean.position.y;\n        let meanSpeed = mean.speed;\n        // let minHeight = 10; // height - (floorHeight + wallHeight);\n        let minHeight = populationHeight + sampleHeight + 50;\n        if (meanHeight &gt; minHeight && meanSpeed &lt; 0.5) {\n            // mean.render.fillStyle = \"black\";\n            mean.isStatic = true;\n            // mean.density = Infinity;\n            //balls.push({ position: ball.position, fill: ball.render.fillStyle });\n            //Body.setStatic(mean, true);\n        }\n    });\n}, 10);\n\n\n// ========================================================================== //\n// Sampling\nfunction logBalls() {\n    let s = sample(sampleSize);\n    // console.log(balls);\n    // console.log(s);\n\n    d3.select(\"#mean\").html(currentMean);\n}\n\n\n// ========================================================================== //\n//      Single sample\n\nfunction sample(sampleSize, fast = false) {\n    let arr = [];\n    let sampleCircles = [];\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"sample\")));\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"meanGhost\")));\n\n    for (let i = 0; i &lt; sampleSize; i++) {\n        let index = Math.floor(Math.random() * balls.length);\n        let pos = balls[index].position;\n        arr.push(pos.x);\n\n        let yPos = pos.y;\n\n        if (fast) yPos = populationHeight + sampleHeight - ballRadius;\n\n\n        sampleCircles.push(Bodies.circle(pos.x, yPos, ballRadius, {\n            label: \"sample\",\n            restitution: 0.4, friction, frictionStatic,\n            density: 1, mass: 1, slop: 0.05,\n            sleepThreshold: Infinity,\n            collisionFilter: { group: -1, category: 2, mask: 4 },\n            render: { fillStyle: balls[index].render.fillStyle }\n        }));\n    };\n\n    currentMean = mean(arr);\n    means.push(currentMean);\n\n\n    let binnedMean = Math.round(currentMean / (ballRadius * 2)) * (ballRadius * 2);\n\n    const meanSquareBack = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2, ballRadius * 2, ballRadius * 2, {\n        label: \"meanGhost\",\n        isStatic: true,\n        isSensor: true,\n        render: { fillStyle: \"white\" }\n    });\n    Composite.add(world, meanSquareBack);\n\n    const meanSquare = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2 - 1, ballRadius * 2, ballRadius * 2, {\n        label: \"mean\",\n        restitution: 0,\n        friction,\n        frictionStatic,\n        frictionAir: 0.03,\n        density: Infinity,\n        mass: 0.000000000000001,\n        slop: 0,\n        collisionFilter: { group: 4, category: 6, mask: 8 },\n        render: { fillStyle: \"#d3d8a9\", strokeStyle: \"black\", lineWidth: 1 }\n    });\n    Composite.add(world, meanSquare);\n\n    Composite.add(world, sampleCircles);\n\n    updateSampleDescriptives(sampleSize, f(currentMean), f(sd(arr, false)), false);\n    updateSamplingDistributionDescriptives();\n}\n\nlet sampleInterval;\n\nfunction takeSamples() {\n    sampleInterval = setInterval(() =&gt; {\n        sample(sampleSize, true);\n    }, 100);\n}\n\n\nfunction stopSamples() {\n    clearInterval(sampleInterval);\n}\n\n\n// ========================================================================== //\n//      Multiple samples\nlet meanCounts = {};\nfunction takeNSamples(nSamples) {\n\n\n    for (let i = 0; i &lt; nSamples; i++) {\n\n        let thisSample = [];\n\n        for (let j = 0; j &lt; sampleSize; j++) {\n            let index = Math.floor(Math.random() * balls.length);\n            thisSample.push(balls[index].position.x);\n        }\n\n        let thisSampleMean = mean(thisSample);\n        means.push(thisSampleMean);\n\n        let thisSampleMeanBinned = bin(thisSampleMean, ballRadius);\n\n        if (meanCounts.hasOwnProperty(thisSampleMeanBinned)) {\n            meanCounts[thisSampleMeanBinned]++;\n        } else {\n            meanCounts[thisSampleMeanBinned] = 1;\n        }\n    }\n\n    updateSamplingDistributionDescriptives();\n    let meanProportions = transformCountsToProportions(meanCounts, means.length);\n    drawProportions(meanProportions);\n}\n\n\n// ========================================================================== //\n//      Reset\nfunction reset() {\n\n    balls = [];\n    means = [];\n\n    clearInterval(updatePopulationInterval);\n    clearInterval(intervalId);\n    histogram.selectAll(\"rect\").remove();\n    curve.selectAll(\"path\").remove();\n\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    // console.log('reset clicked');\n\n    initialize();\n    makeGround();\n    makePopulation(eval(d3.select(\"#dist\").node().value));\n    updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n\n    updateSampleDescriptives(0, 0, 0, true);\n    updateSamplingDistributionDescriptives(true);\n}\n\n\nfunction resetMeans() {\n    means = [];\n    meanCounts = {};\n    histogram.selectAll(\"rect\").remove();\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\" || body.label === \"sample\" || body.label === \"meanGhost\")));\n    d3.select(\"#samplingDistStats\").classed(\"hide\", true);\n    d3.select(\"#sampleStats\").classed(\"hide\", true);\n}\n\n\n\n\n// ========================================================================== //\n// Overlay and panel labels\n// ========================================================================== //\n\n// ==================\n//      Labels\nvar labels = [{ label: \"Population\", top: 0 },\n{ label: \"Sample\", top: populationHeight + 5 },\n{ label: \"Distribution of sample means\", top: populationHeight + sampleHeight }];\n\nd3.select(\"#container\").selectAll(\"span\")\n    .data(labels).enter().append(\"span\")\n    .classed(\"panel-label\", true)\n    .classed(\"labels\", true)\n    .style(\"position\", \"absolute\").style(\"left\", \"0.1em\")\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .text(d =&gt; d.label)\n\nvar labels2 = [{\n    label: `&lt;i&gt;N&lt;/i&gt; = &lt;span id=\"n\"&gt;0&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;Î¼&lt;/i&gt; = &lt;span id=\"mu\"&gt;&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;Ïƒ&lt;/i&gt; = &lt;span id=\"sigma\"&gt;&lt;/span&gt;`,\n    top: 0\n},\n{\n    label: `&lt;div id=\"sampleStats\"&gt;&lt;i&gt;n&lt;/i&gt; = &lt;span id=\"sampleN\"&gt;&lt;/span&gt;;\n              &lt;i&gt;M&lt;/i&gt; = &lt;span id=\"sampleM\"&gt;&lt;/span&gt;;\n              &lt;i&gt;SD&lt;/i&gt; = &lt;span id=\"sampleSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + 5\n},\n{\n    label: `&lt;div id=\"samplingDistParams\"&gt;Predicted:&lt;br&gt;\n              &lt;i&gt;Î¼&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;Î¼&lt;/i&gt; = &lt;span id=\"muM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Ïƒ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;Ïƒ&lt;/i&gt;/âˆš&lt;i&gt;n&lt;/i&gt;  = &lt;span id=\"sigmaM\"&gt;&lt;/span&gt;&lt;/div&gt;\n              &lt;div id=\"samplingDistStats\"&gt;Observed:&lt;br&gt;&lt;i&gt;N&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distN\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Î¼&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Ïƒ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + sampleHeight\n}];\n\nconst overlay2 = d3.select(\"#container\").append(\"div\")\n    .style(\"position\", \"absolute\")\n    .style(\"z-index\", 13)\n    .style(\"text-align\", \"right\")\n\noverlay2.selectAll(\"span\")\n    .data(labels2).enter().append(\"span\")\n    .style(\"width\", width - 5 + \"px\")\n    .style(\"z-index\", 0)\n    // .style(\"margin-right\", \"1em\")\n    .classed(\"panel-label\", true)\n    .classed(\"numbers\", true)\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .html(d =&gt; d.label)\n\nconst f = d3.format(\".1f\");\nconst fComma = d3.format(\",\");\n\nfunction updateDescriptives() {\n    d3.select(\"#n\").text(fComma(balls.length))\n    d3.select(\"#mu\").text(f(populationMean))\n    d3.select(\"#sigma\").text(f(populationSd))\n}\n\nfunction updateSampleDescriptives(n, m, sd, hidden = true) {\n    d3.select(\"#sampleStats\").classed(\"hide\", hidden)\n    d3.select(\"#sampleN\").text(n)\n    d3.select(\"#sampleM\").text(f(m))\n    d3.select(\"#sampleSd\").text(f(sd));\n}\nfunction updateSamplingDistributionParams() {\n    d3.select(\"#muM\").text(f(populationMean))\n    d3.select(\"#sigmaM\").text(f(populationSd / Math.sqrt(sampleSize)));\n}\n\nfunction updateSamplingDistributionDescriptives(hidden = false) {\n    d3.select(\"#samplingDistStats\").classed(\"hide\", hidden)\n    d3.select(\"#distN\").text(fComma(means.length));\n    d3.select(\"#distM\").text(f(mean(means)));\n    d3.select(\"#distSd\").text(f(sd(means)));\n}\n\n\n\n// ========================================================================== //\n//      Normal distribution\n\n// create svg overlay\nconst svg = d3.select(\"#container\")\n    .append(\"svg\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .style(\"transform\", `translateY(${height - samplingDistributionHeight}px)`)\n    // .append(\"div\")\n    .style(\"z-index\", 0)\n    .attr(\"id\", \"samplingDistCanvas\")\n    // .style(\"left\", 0)\n    .attr(\"height\", samplingDistributionHeight)\n    .attr(\"width\", width);\n\nconst histogram = svg.append(\"g\");\nconst curve = svg.append(\"g\");\n\n\nfunction drawNormalDistribution(mean, sd) {\n\n    // remove the old path\n    curve.selectAll(\"path\").remove();\n\n    // reset the y-axis according to new population parameters\n    y.domain([0, 1.1 * jStat.normal.pdf(populationMean, populationMean, populationSd / Math.sqrt(sampleSize))]);\n\n    var values = jStat(0, width, 210)[0];\n\n    let data = [];\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, mean, sd);\n        data.push({ value: value, density: density });\n    }\n\n    const line = d3.line()\n        .x(d =&gt; d.value)\n        .y(d =&gt; y(d.density));\n\n    // draw the new path\n    curve.append(\"path\")\n        .attr(\"d\", line(data))\n        .attr(\"stroke\", \"grey\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        .attr(\"stroke-width\", 2)\n        .attr(\"fill\", \"none\");\n}\n\n// ========================================================================== //\n//      Histogram\nfunction drawProportions(proportions) {\n\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\")));\n    histogram.selectAll(\"rect\").remove();\n\n    Object.entries(proportions).forEach(([key, value]) =&gt; {\n        histogram.append(\"rect\")\n            .attr(\"fill\", \"#d3d8a9\")\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5)\n            .attr(\"x\", key - ballRadius * 0.5)\n            // .attr(\"y\", 0)\n            .attr(\"y\", y(value * 0.2))\n            .attr(\"width\", 5)\n            // .attr(\"height\", samplingDistributionHeight * 2)\n            .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n        // .transition().duration(value * 15000)\n        //     .attr(\"y\", y(value * 0.2))\n        //     .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n    });\n}\n\n\n\n\n// ========================================================================== //\n// Helper functions\n// ========================================================================== //\n\n\n// ========================================================================== //\n//      Distribution functions\n\n// functions to make skewed distribution\n// see https://spin.atomicobject.com/2019/09/30/skew-normal-prng-javascript/\nconst randomNormals = (rng) =&gt; {\n    let u1 = 0, u2 = 0;\n    //Convert [0,1) to (0,1)\n    while (u1 === 0) u1 = rng();\n    while (u2 === 0) u2 = rng();\n    const R = Math.sqrt(-2.0 * Math.log(u1));\n    const Î˜ = 2.0 * Math.PI * u2;\n    return [R * Math.cos(Î˜), R * Math.sin(Î˜)];\n};\n\n\nconst randomSkewNormal = (rng, Î¾ = 0, Ï‰ = 1, Î± = 0) =&gt; {\n    const [u0, v] = randomNormals(rng);\n    if (Î± === 0) {\n        return Î¾ + Ï‰ * u0;\n    }\n    const ğ›¿ = Î± / Math.sqrt(1 + Î± * Î±);\n    const u1 = ğ›¿ * u0 + Math.sqrt(1 - ğ›¿ * ğ›¿) * v;\n    const z = u0 &gt;= 0 ? u1 : -u1;\n    return Î¾ + Ï‰ * z;\n};\n\n// functions to generate single observations from those distributions\nfunction normal() {\n    return randomSkewNormal(Math.random, x0, width * 0.12, 0);\n}\nfunction negative() {\n    return randomSkewNormal(Math.random, width * 0.9, width * 0.25, -10);\n}\nfunction positive() {\n    return randomSkewNormal(Math.random, width * 0.1, width * 0.25, 10);\n}\nfunction uniform() {\n    return ((width * 0.05) + width * 0.9 * Math.random());\n}\n\n// ============================================================\n//      Other low-level helper functions\n\nfunction sleep(milliseconds) {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date &lt; milliseconds);\n}\n\n\nfunction bin(x, binWidth) {\n    return Math.round(x / binWidth) * binWidth;\n}\n\n\nArray.prototype.max = function () {\n    return Math.max.apply(null, this);\n};\n\n\nfunction transformCountsToProportions(counts, totalCount) {\n    // let totalCount = Object.values(counts).reduce((a, b) =&gt; a + b, 0);\n    let proportions = {};\n\n    for (let mean in counts) {\n        if (counts.hasOwnProperty(mean)) {\n            proportions[mean] = counts[mean] / totalCount;\n        }\n    }\n\n    return proportions;\n}\n\nfunction mean(arr) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    return total / n;\n}\n\nfunction sd(arr, population = true) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    let mean = total / n;\n\n    let ss = 0;\n\n    for (let i = 0; i &lt; arr.length; i++) {\n        ss += Math.pow(arr[i] - mean, 2);\n    }\n\n    let denominator = arr.length;\n\n    if (!population) { denominator--; }\n\n    return Math.sqrt(ss / denominator);\n}\n\n\nscaleCanvas();\ninitialize();\nreset();\n}"
  },
  {
    "objectID": "visualizations/quincunx.html",
    "href": "visualizations/quincunx.html",
    "title": "Quincunx",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\nboard = {\n\n\n// https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n\n\nlet width = 700;\nlet height = 600;\nlet x0 = width / 2;\n\n// ball properties\nconst ballRadius = 4;\nlet y_start = 0;\n\nlet generation_speed = 20;\nlet nBalls = 650;\nlet mass = 100;\nlet density = 1;\n\n// peg board properties\nlet rows = 20;\nlet y_peg_start = 20;\nlet pegGap = 6.5 * ballRadius;\nlet pegRadius = 0.5 * ballRadius;\nlet xGap = pegGap;\nlet yGap = 0.6 * xGap;\nlet pegAngle = 0; // Math.PI / 4;\nlet gap_between_pegs_and_buckets = 0;\n\n// funnel properties\nconst funnelTostartGap = yGap;\nconst funnelWallLength = 600;\nconst funnelAngle = Math.PI / 3;\nconst funnelOpening = 5 * ballRadius;\n\n// physics properties\nlet restitution = 0.5; // bounciness\nlet friction = 0.01;\nlet frictionAir = 0.045;\nlet frictionStatic = 0;\n\n\nlet intervalId;\n\n\nvar {Engine, Render, Runner, \n    Composite, Composites, Common, \n    MouseConstraint, Mouse, Events, \n    World, Bodies, Body} = Matter;\n\nlet engine, render, runner, world;\n\n\n\nfunction initialize() {\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n    \n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"board\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    \n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.addEventListener(\"mousedown\", reset);\n    render.canvas.position = \"absolute\";\n}\n\n\n\n// Create top funnel\nlet leftBumper_x =  x0 - (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet rightBumper_x = x0 + (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet bumper_y = y_peg_start - ((funnelWallLength * Math.sin(funnelAngle)) / 2 - funnelTostartGap);\nconsole.log(bumper_y)\n\nlet createFunnel = () =&gt; {\n\n        let leftBumper = Bodies.rectangle(leftBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(leftBumper, funnelAngle);\n\n        let rightBumper = Bodies.rectangle(rightBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution: 0.6,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(rightBumper, -funnelAngle);\n\n        Matter.Composite.add(world, [leftBumper, rightBumper]);\n}\n\n\nfunction make_balls() {\n\n    let total = nBalls;\n    clearInterval(intervalId);\n\n    intervalId = setInterval(() =&gt; {\n        let balls = [];\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x0 + (-0.5 + Math.random()) * 1, -20, ballRadius, {\n                label: \"circle\",\n                friction: 0.001,\n                restitution,\n                mass,\n                slop: 0.05,\n                density,\n                frictionAir,\n                sleepThreshold: Infinity,\n                render: {\n                    fillStyle: d3.schemeCategory10[total % 10]\n                }\n            });\n            // Matter.Events.on(circle, \"sleepStart\", () =&gt; {\n            //     Matter.Body.setStatic(circle, true);\n            // });\n            \n            Matter.Composite.add(world, circle);\n        }\n    }, generation_speed);\n}\n\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; body.label === \"circle\");\n  };\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach(function(ball) {\n      let ballHeight = ball.position.y;\n      let ballSpeed = ball.speed;\n      let minHeight = 350; // height - (floorHeight + wallHeight);\n      if (ballHeight &gt; minHeight && ballSpeed &lt; 0.02) {\n        // ball.render.opacity = 0.5;\n        Body.setStatic(ball, true);\n      }\n    });\n  }, 200);\n\n\nfunction make_pegs() {\n    const pegs = [];\n    const spacingY = ballRadius*4;\n    const spacingX = ballRadius*4;\n    var i, j, lastI;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 1; j &lt; i; j++) {\n            pegs.push(\n                // Bodies.rectangle(\n                Bodies.circle(\n                    x0 + (j * xGap - i * (xGap / 2)),\n                    y_peg_start + i * yGap,\n                    pegRadius,\n                    // ballRadius * 1.2,\n                    // 2,\n                    {\n                        angle: pegAngle,\n                        isStatic: true,\n                        friction: 0,\n                        frictionStatic: 0,\n                        render: {\n                            fillStyle: \"black\"\n                        },\n                    chamfer: {\n                        radius: [ballRadius * 0.2, ballRadius * 0.2, 0, 0]\n                    }\n        })\n            );\n        }\n        lastI = i;\n    }\n    // bins\n    for (i = 0; i &lt; rows; i++) {\n        Matter.Composite.add(\n            world,\n            Bodies.rectangle(\n\n                x0 - (rows - 1) * (xGap / 2) + i * xGap,\n                y_peg_start + rows * yGap + gap_between_pegs_and_buckets + (height-(y_peg_start + rows * yGap))/2,\n                4,\n                (height-(y_peg_start + rows * yGap)),\n                {\n                    isStatic: true,\n                    density: 1000,\n                    mass: 1000,\n                    slop: 0,\n                    render: {\n                        fillStyle: \"#000000\",\n                        visible: true\n                    },\n                    chamfer: {\n                        radius: [ballRadius * 0.4, ballRadius * 0.4, 0, 0]\n                    }\n                }\n            )\n        );\n    }\n    // ground\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(400, height, 1000, 10, {\n            isStatic: true,\n            render: {\n                fillStyle: \"#000000\",\n                visible: true\n            }\n        })\n    );\n\n\n    World.add(world, pegs);\n}\n\nconst canvas = d3.select(\"#overlay\")\n.append(\"canvas\")\n.attr(\"id\", \"overlay\")\n.attr(\"position\", \"absolute\")\n.attr(\"width\", width)\n.attr(\"height\", height);\n\nconst ctx = canvas.node().getContext('2d');\ncanvas.on(\"mousedown\", reset);\n\nfunction drawNormalDistribution() {\n\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(0, height - 5);\n\n    let yMultiplier = (height-(y_peg_start + rows * yGap));\n    var values = jStat(-4, 4, 210)[0]\n\n\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, 0, 0.8);\n        ctx.lineTo((value + 4)*(width/8), height-(density*1.95*yMultiplier) - 5);\n        ctx.stroke();\n    }\n}\n\nfunction reset() {\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    console.log('reset clicked');\n    \n    initialize();\n    scaleCanvas();\n    make_pegs();\n    make_balls();\n    createFunnel();\n    drawNormalDistribution();\n}\n\n\nfunction scaleCanvas() {\n    \n    var containerWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = containerWidth / (width * 1);\n    d3.select(\"canvas\")\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n    canvas\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    // d3.select(\"#flex-container\")\n    //     .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    // d3.select(\"#container\")\n    //     .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n//\n\ninitialize();\nscaleCanvas();\nmake_pegs();\nmake_balls();\ncreateFunnel();\ndrawNormalDistribution();\n  \n}"
  },
  {
    "objectID": "games/jellybeans.html",
    "href": "games/jellybeans.html",
    "title": "Psych Stats",
    "section": "",
    "text": "How many jellybeans in the jar?\n    \n    \n        \n    \n\n\n    Reveal\n\n\nimport { scaleCanvas } from '../utils/utils.js';\n\njar = {\n    let width = 500;\nlet height = 600;\nlet x0 = width / 2;\n\nlet colorPal = [\n    '#ff8aa6', // Pastel Pink\n    '#ff9b48', // Pastel Orange\n    '#fff067', // Pastel Yellow\n    '#9EE09E', // Pastel Green\n    '#71c4e6', // Pastel Blue\n    '#edceff', // Pastel Purple\n    '#fc5c30', // Pastel Brown\n    '#CAF7E2'  // Pastel Mint\n];\n\n\nfunction randomColor(colorPal) {\n    return colorPal[Math.floor(Math.random() * colorPal.length)];\n}\n\nfunction getBeanProperties(colorPal) {\n    return {\n        label: \"circle\",\n        mass: 100,\n        restitution: 0.5,\n        friction: 0.01,\n        frictionAir: 0.025,\n        frictionStatic: 0,\n        density: 1,\n        slop: 0.05,\n        sleepThreshold: 15,\n        render: { fillStyle: randomColor(colorPal) }\n    };\n}\n\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet intervalId = null;\nconst generationSpeed = 20;\n\nlet params = randomizeParams();\nlet engine = initializeWorld(\"board\", \"canvas\", width, height);\n\nComposite.add(engine.world, makeJar(params));\n\nlet generateBean = createBeanGenerator(params, x0, colorPal);\naddBeansToWorld(engine.world, generateBean, generationSpeed);\n\nengine;\n\nfunction randomizeParams() {\n    const generationSpeed = 20;\n    const jarCount = 0;\n    const jarWidth = 0.5 + Math.random() * 0.4;\n    const jarHeight = 0.5 + Math.random() * 0.2;\n    const beanRadius = 6 + Math.random() * 6;\n    const nBeans = Math.floor(4000 * (jarWidth * jarHeight) * (1 / beanRadius));\n    \n    return {nBeans, beanRadius, generationSpeed, jarWidth, jarHeight, jarCount};\n}\n\nfunction initializeWorld(element, canvas, width, height) {\n    let engine = Engine.create({\n        enableSleeping: true\n    }),\n    world = engine.world;\n    // create renderer\n    let render = Render.create({\n        element: document.getElementById(element),\n        canvas: document.getElementById(canvas),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n    \n    let runner = Runner.create();\n    Runner.run(runner, engine);\n\n    // Reset simulation on mousedown events\n    render.canvas.addEventListener(\"mousedown\", handleReset);\n\n    return {world, render};\n}\n\n\nfunction createBeanGenerator(params, x, colors) {\n    let total = params.nBeans;\n\n    return function generateBean() {\n        if (total-- > 0) {\n            const circle = Bodies.circle(x + (-0.5 + Math.random()) * 250, -20, params.beanRadius + Math.random() * 8, \n            getBeanProperties(colorPal)\n            );\n\n            Events.on(circle, \"sleepStart\", function () {\n                circle.isStatic = true;\n                circle.label = \"inJar\";\n            });\n\n            return circle;\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction addBeansToWorld(world, generatorFunction, speed) {\n    intervalId = setInterval(() => {\n        let bean = generatorFunction();\n        if (bean) {\n            Composite.add(world, bean);\n        } else {\n            clearInterval(intervalId);\n            intervalId = null;\n        }\n    }, speed);\n}\n\n\nconst existingBalls = () => {\n    return engine.world.bodies.filter((body) => body.label === \"circle\");\n};\n\nconst makeStaticInterval = setInterval(() => {\n    existingBalls().forEach((ball) => removeBall(engine, ball, height));\n}, 200);\n\nfunction removeBall(engine, ball, canvasHeight) {\n    let ballHeight = ball.position.y;\n    if (ballHeight > canvasHeight) {\n        console.log(\"gonner\");\n        Composite.remove(engine.world, ball);\n    }\n}\n\nfunction makeJar(params) {\n\n    const thickness = 10;\n    const properties = {\n        isStatic: true,\n        render: {\n            fillStyle: \"#000000\",\n            visible: true\n        },\n        chamfer: { radius: [5, 5, 5, 5]}\n    };\n\n    const leftWall = Bodies.rectangle(width * (1 - params.jarWidth) / 2, (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const rightWall = Bodies.rectangle(width * (1 - (1 - params.jarWidth) / 2), (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const bottom = Bodies.rectangle(width * 0.5, height - 5, width * params.jarWidth, thickness, properties);\n\n    return [leftWall, rightWall, bottom];\n}\n\nconst btn = document.getElementById(\"revealBtn\");\n\nfunction countBeansInJar(world) {\n    return world.bodies.filter((body) => body.label === \"inJar\").length;\n}\n\nbtn.addEventListener(\"click\", function(event) {\n    btn.innerHTML = countBeansInJar(engine.world);\n})\n\nfunction resetRevealButton(button) {\n    button.innerHTML = \"Reveal\";\n}\n\n\nfunction reset() {\n    const newParams = randomizeParams();\n    const newEngine = initializeWorld(\"board\", \"canvas\");\n    const newJar = makeJar(newParams);\n    const newBeans = createBeanGenerator(newParams, x0, colorPal);\n\n    return { newParams, newEngine, newBeans, newJar };\n}\n\nfunction handleReset() {\n    resetRevealButton(btn);\n    // Composite.clear(engine.world);\n    \n    if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n    }\n    \n    const { newParams, newEngine, newBeans, newJar } = reset();\n    params = newParams;\n    engine = newEngine;\n    Composite.add(engine.world, newJar)\n    generateBean = newBeans;\n    addBeansToWorld(engine.world, generateBean, generationSpeed);\n}\n\nscaleCanvas(\"container\", width, height);\nwindow.addEventListener(\"resize\", () => scaleCanvas(\"container\", width, height))\n\n}"
  },
  {
    "objectID": "games/jellybeans2.html",
    "href": "games/jellybeans2.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\n\n\njar = {\nconst renderVertices = body => {\n  ctx.beginPath();\n  body.vertices.forEach(({x, y}) => ctx.lineTo(x, y));\n  ctx.closePath();\n  ctx.fill();\n  ctx.stroke();\n};\n\n\nconst container = d3.select(\"#container\");\n\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst gradient = ctx.createLinearGradient(\n  0, 0, canvas.width, canvas.height\n);\ngradient.addColorStop(0, \"red\");\ngradient.addColorStop(1, \"blue\");\nctx.fillStyle = gradient;\nctx.strokeStyle = \"var(--bs-body-color)\";\nctx.lineWidth = 2;\n\nconst engine = Matter.Engine.create();  \nconst box = Matter.Bodies.circle(300, 0, 10, 10);\nconst ground = Matter.Bodies.rectangle(\n  200, 200, 400, 120, {isStatic: true}\n);\nconst mouseConstraint = Matter.MouseConstraint.create(\n  engine, {element: canvas}\n);\nMatter.Composite.add(\n  engine.world, [box, ground, mouseConstraint]\n);\n\n(function rerender() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  renderVertices(box);\n  renderVertices(ground);\n  Matter.Engine.update(engine);\n  requestAnimationFrame(rerender);\n})();\n\n}"
  },
  {
    "objectID": "games/triplett/triplett.html",
    "href": "games/triplett/triplett.html",
    "title": "Psych Stats",
    "section": "",
    "text": "practice\n\n\nrace alone\n\n\nrace together\n\n\nAbout\n\n\n\nCompetition Machine â€”\n\n\n\n\nâ”˜\n\n\nğŸ\n\n\nğŸš©\n\n\n\n\nâ”˜\n\n\nğŸ\n\n\nğŸš©\n\n\n\n\nYour time: 0.00\n\n\nReset\n\n\n\n\nClick the â€˜handleâ€™ to the left of the â€˜trackâ€™ to start.\n\n\nKeep clicking as fast as you can until your flag reaches the end.\n\n\nClick Race Alone to do a timed race by yourself.\n\n\nClick Race Together to race against a competitor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nğŸ‘‘ Records ğŸ‘‘\n\n\nPrevious\n\n\nBest\n\n\n\n\nğŸš© Alone\n\n\n-\n\n\n-\n\n\n\n\nğŸš©ğŸš©Competition\n\n\n-\n\n\n-\n\n\n\n\n\n\ngame = {\n    var start, myTimer, myTurner;\nvar sec = d3.select(\"#seconds\")\nvar cli = d3.select(\"#clicks\")\nvar flag = d3.select(\"#flag\")\nvar flag2 = d3.select(\"#flag2\")\nvar clicks = 0;\nvar state;\nconst target_clicks = 50;\nvar mode = practice;\n\nvar records = [{prev: 0, best: 0},{prev: 0, best: 0}]\n\nvar handleState = 0;\nconst handle = d3.select(\"#handle-text\");\nconst handle2 = d3.select(\"#handle2-text\");\nconst handleText = [\"â”˜\",\"â””\"]\n\nd3.select(\"#handle1\").on(\"click\", clicked);\nd3.select(\"#practice-button\").on(\"click\", practice);\nd3.select(\"#alone-button\").on(\"click\", alone);\nd3.select(\"#competition-button\").on(\"click\", competition);\nd3.select(\"#reset-button\").on(\"click\", reset);\n\nfunction handleClicked() {\n    handleState++;\n    handle.text(handleText[handleState % 2]);\n}\n\nfunction turnHandle2() {\n    var handle2State = 0;\n    myTurner = setInterval( function(){\n        handle2State++;\n        handle2.text(handleText[handle2State % 2]);\n        if (handle2State &gt; target_clicks) clearInterval(myTurner);\n    }, 7000 / target_clicks);\n}\n\nfunction clicked() {\n    handleClicked();\n    \n    if (clicks==0) {startTimer(); turnHandle2();}\n    if (clicks &lt; target_clicks) {\n        clicks++;\n    cli.text(clicks);\n    flag.transition().duration(300).style(\"left\", `${clicks*(100/target_clicks)*1.00}%`);\n    } \n    if (clicks == target_clicks) stopTimer();\n}\n\nfunction startTimer() {\n    start = Date.now();\n    myTimer= setInterval( function(){\n        var delta = Date.now() - start; // milliseconds elapsed since start\n        sec.html(delta / 1000);\n    }, 10);\n\n    flag2.transition().ease(d3.easeLinear).duration(7000).style(\"left\", \"100%\")\n}\n\nfunction stopTimer() {\n    clearInterval(myTimer);\n\n    var time = Number(sec.html());\n\n    if(state!=\"practice\") {\n        d3.select(\"#\" + state + \"-previous\").text(time);\n\n        var previousBest = Number(d3.select(\"#\" + state + \"-best\").text());\n        if(isNaN(previousBest)) d3.select(\"#\" + state + \"-best\").text(time);\n        else if (time &lt; previousBest) d3.select(\"#\" + state + \"-best\").text(time);\n    }\n}\n\n// function updateTable(time, cell) {\n//     d3.select(cell).text(time);\n// }\n\nfunction practice() {\n    state = \"practice\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#practice-button\").classed(\"selected\", true);\n    // d3.select(\"#practice\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#time\").style(\"display\", \"none\");\n}\n\nfunction alone() {\n    state = \"alone\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#alone-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction competition() {\n    state = \"competition\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#competition-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction reset() {\n    clearInterval(myTimer);\n    clearInterval(myTurner);\n    sec.text(\"0.00\");\n    cli.text(0);\n    flag.transition().duration(1000).style(\"left\", \"0%\");\n    flag2.transition().duration(1000).style(\"left\", \"0%\");\n    clicks = 0;\n}\n\npractice();\n}"
  },
  {
    "objectID": "visualizations/dice/dice.html",
    "href": "visualizations/dice/dice.html",
    "title": "Dice Roller",
    "section": "",
    "text": "Throw the dice\n\n\n+100\n\n\n+1,000\n\nNumber of dice:  1 2 3 4 5 10 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThrows:  Reset"
  },
  {
    "objectID": "games/correlation/guess-the-correlation.html",
    "href": "games/correlation/guess-the-correlation.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Guess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\ngame = {\nconst f = d3.format(\".2f\");\nconst res = d3.format(\"+.2f\");\nconst line = d3.line();\n\n\n// SVG\n\nconst w = 500;\nconst h = 350;\nconst margin = {top: 10, right: 10, bottom: 30, left: 10}\nconst radius = 4;\nvar r;\nvar p1error, p2error, winnerIndex;\nvar scores = [0,0];\n\n\nconst scoreValues = [d3.select(\"#p1-points\"), d3.select(\"#p2-points\")];\n\n\nconst svg = d3.select(\".svg-container\")\n.append(\"svg\")\n.attr(\"class\", \"svg-content\")\n.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n.attr(\"viewBox\", `0 0 ${w} ${h}`);\n\nconst axisLine = svg.append(\"path\")\n    .style(\"stroke\", \"black\").style(\"fill\", \"none\")\n    .style(\"stroke-linecap\", \"square\").style(\"stroke-width\", 2);\n    \naxisLine.attr(\"d\", line([[margin.left, margin.top],\n                        [margin.left, h - margin.bottom],\n                        [w - margin.right, h - margin.bottom]]));\n                              \n\nfunction makeChart() {\n    var data = makeData(100);\n\n    var x = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.xVal), d3.max(data, d =&gt; d.xVal)])\n        .range([margin.left + 2*radius, w - margin.right - 2*radius])\n    const y = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.yVal), d3.max(data, d =&gt; d.yVal)])\n        .range([h - margin.bottom - 2*radius, margin.top + 2*radius])\n\n    svg.selectAll(\"circle\").remove();\n    svg.selectAll(\"circle\").data(data).enter()\n        .append(\"circle\")\n        .attr(\"cx\", d =&gt; x(d.xVal))\n        .attr(\"cy\", d =&gt; y(d.yVal))\n        .attr(\"r\", radius)\n        .style(\"fill\", \"plum\")\n        .style(\"opacity\", 0)\n        .transition().delay((d,i) =&gt; i * 10).duration(0)\n            .style(\"opacity\" ,1)\n \n}\n\nfunction adjudicateGuesses() {\n    var p1guess = d3.select(\"#p1-guess\").property(\"value\");\n    var p2guess = d3.select(\"#p2-guess\").property(\"value\");\n    p1error = r - p1guess;\n    p2error = r - p2guess;\n\n    var errors = [Math.abs(p1error), Math.abs(p2error)]\n    winnerIndex = errors.indexOf(Math.min(...errors));\n    \n    showResults();\n    addPoint(winnerIndex);\n    d3.select(\"#refresh\").text(\"Next\").on(\"click\", reset);\n}\n\nfunction showResults() {\n    let winner = Array(2).fill(\"\");\n    winner[winnerIndex] = \"&lt;span style='font-size: 2em;'&gt;ğŸ‘‘&lt;/span&gt;\";\n    d3.select(\"#p1-error\").html(res(p1error * -1) + \"&lt;br&gt;\" + winner[0]);\n    d3.select(\"#p2-error\").html(res(p2error * -1) + \"&lt;br&gt;\" + winner[1]);\n    d3.select(\"#true-r\").text(\"True r = \" + f(r));\n}\n\nd3.select(\"#p1-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ğŸª™\")\nd3.select(\"#p2-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ğŸª™\")\n\nfunction addPoint(i) {\n    scores[i]++;\n    if(scores[i] &gt; 2) {\n        // declareWinner(i);\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    } else {\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    }\n}\n\nfunction declareWinner(winnerIndex) {\n    // alert(\"Player \" + (winnerIndex + 1) + \" wins!!!\")\n    // window.location.reload();\n}\n\n\nfunction reset() {\n    d3.selectAll(\".resettable\").html(\"\")\n    d3.selectAll(\".guess\").property(\"value\", \"\");\n    \n    d3.select(\"#refresh\").text(\"Guess\").on(\"click\", adjudicateGuesses);\n    makeChart();\n}\n\n// d3.selectAll(\".points-label\").each(() =&gt; this.on(\"click\", this.select()));\n\nfunction makeData(n) {\n    let arr = [];\n    let arrX = [];\n    let arrY = [];\n\n    var target_r = Math.random();\n    console.log(\"target r = \" + target_r);\n\n    for (var i = 0; i &lt; n; i++) {\n        var A = jStat.normal.inv(Math.random(), 0, 1);\n        var B = jStat.normal.inv(Math.random(), 0, 1);\n        \n        var X = A;\n        var Y = A * target_r + B * Math.pow(1 - Math.pow(target_r, 2), 0.5);\n        \n        arr.push({xVal: X, yVal: Y});\n        arrX.push(X);\n        arrY.push(Y);\n    }\n    // var stats = new Statistics(arr, {xVal: 'metric', yVal: 'metric'});\n    // r = stats.correlationCoefficient('xVal', 'yVal').correlationCoefficient;\n    console.log(arrX);\n    r = jStat.corrcoeff(arrX, arrY);\n    console.log(\"Actual r = \" + r);\n    return arr;\n}\n\nd3.select(\"#refresh\").on(\"click\", adjudicateGuesses);\nmakeChart();\n\n}"
  },
  {
    "objectID": "games/guess-the-correlation.html",
    "href": "games/guess-the-correlation.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Guess\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\ngame = {\nconst f = d3.format(\".2f\");\nconst res = d3.format(\"+.2f\");\nconst line = d3.line();\n\n\n// SVG\n\nconst w = 500;\nconst h = 350;\nconst margin = {top: 10, right: 10, bottom: 30, left: 10}\nconst radius = 4;\nvar r;\nvar p1error, p2error, winnerIndex;\nvar scores = [0,0];\n\n\nconst scoreValues = [d3.select(\"#p1-points\"), d3.select(\"#p2-points\")];\n\n\nconst svg = d3.select(\".svg-container\")\n.append(\"svg\")\n.attr(\"class\", \"svg-content\")\n.attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n.attr(\"viewBox\", `0 0 ${w} ${h}`);\n\nconst axisLine = svg.append(\"path\")\n    .style(\"stroke\", \"black\").style(\"fill\", \"none\")\n    .style(\"stroke-linecap\", \"square\").style(\"stroke-width\", 2);\n    \naxisLine.attr(\"d\", line([[margin.left, margin.top],\n                        [margin.left, h - margin.bottom],\n                        [w - margin.right, h - margin.bottom]]));\n                              \n\nfunction makeChart() {\n    var data = makeData(100);\n\n    var x = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.xVal), d3.max(data, d =&gt; d.xVal)])\n        .range([margin.left + 2*radius, w - margin.right - 2*radius])\n    const y = d3.scaleLinear()\n        .domain([d3.min(data, d =&gt; d.yVal), d3.max(data, d =&gt; d.yVal)])\n        .range([h - margin.bottom - 2*radius, margin.top + 2*radius])\n\n    svg.selectAll(\"circle\").remove();\n    svg.selectAll(\"circle\").data(data).enter()\n        .append(\"circle\")\n        .attr(\"cx\", d =&gt; x(d.xVal))\n        .attr(\"cy\", d =&gt; y(d.yVal))\n        .attr(\"r\", radius)\n        .style(\"fill\", \"plum\")\n        .style(\"opacity\", 0)\n        .transition().delay((d,i) =&gt; i * 10).duration(0)\n            .style(\"opacity\" ,1)\n \n}\n\nfunction adjudicateGuesses() {\n    var p1guess = d3.select(\"#p1-guess\").property(\"value\");\n    var p2guess = d3.select(\"#p2-guess\").property(\"value\");\n    p1error = r - p1guess;\n    p2error = r - p2guess;\n\n    var errors = [Math.abs(p1error), Math.abs(p2error)]\n    winnerIndex = errors.indexOf(Math.min(...errors));\n    \n    showResults();\n    addPoint(winnerIndex);\n    d3.select(\"#refresh\").text(\"Next\").on(\"click\", reset);\n}\n\nfunction showResults() {\n    let winner = Array(2).fill(\"\");\n    winner[winnerIndex] = \"&lt;span style='font-size: 2em;'&gt;ğŸ‘‘&lt;/span&gt;\";\n    d3.select(\"#p1-error\").html(res(p1error * -1) + \"&lt;br&gt;\" + winner[0]);\n    d3.select(\"#p2-error\").html(res(p2error * -1) + \"&lt;br&gt;\" + winner[1]);\n    d3.select(\"#true-r\").text(\"True r = \" + f(r));\n}\n\nd3.select(\"#p1-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ğŸª™\")\nd3.select(\"#p2-points\").selectAll(\"div\").data([0,1,2]).enter().append(\"span\").classed(\"placeholder-coin\", true).text(\"ğŸª™\")\n\nfunction addPoint(i) {\n    scores[i]++;\n    if(scores[i] &gt; 2) {\n        // declareWinner(i);\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    } else {\n        scoreValues[i].selectAll(\"span\").filter(d =&gt; d &lt; scores[i]).classed(\"placeholder-coin\", false);\n    }\n}\n\nfunction declareWinner(winnerIndex) {\n    // alert(\"Player \" + (winnerIndex + 1) + \" wins!!!\")\n    // window.location.reload();\n}\n\n\nfunction reset() {\n    d3.selectAll(\".resettable\").html(\"\")\n    d3.selectAll(\".guess\").property(\"value\", \"\");\n    \n    d3.select(\"#refresh\").text(\"Guess\").on(\"click\", adjudicateGuesses);\n    makeChart();\n}\n\n// d3.selectAll(\".points-label\").each(() =&gt; this.on(\"click\", this.select()));\n\nfunction makeData(n) {\n    let arr = [];\n    let arrX = [];\n    let arrY = [];\n\n    var target_r = Math.random();\n    console.log(\"target r = \" + target_r);\n\n    for (var i = 0; i &lt; n; i++) {\n        var A = jStat.normal.inv(Math.random(), 0, 1);\n        var B = jStat.normal.inv(Math.random(), 0, 1);\n        \n        var X = A;\n        var Y = A * target_r + B * Math.pow(1 - Math.pow(target_r, 2), 0.5);\n        \n        arr.push({xVal: X, yVal: Y});\n        arrX.push(X);\n        arrY.push(Y);\n    }\n    // var stats = new Statistics(arr, {xVal: 'metric', yVal: 'metric'});\n    // r = stats.correlationCoefficient('xVal', 'yVal').correlationCoefficient;\n    console.log(arrX);\n    r = jStat.corrcoeff(arrX, arrY);\n    console.log(\"Actual r = \" + r);\n    return arr;\n}\n\nd3.select(\"#refresh\").on(\"click\", adjudicateGuesses);\nmakeChart();\n\n}"
  },
  {
    "objectID": "visualizations/mean-balance-beam.html",
    "href": "visualizations/mean-balance-beam.html",
    "title": "Central Tendency",
    "section": "",
    "text": "Central Tendency: The Mean as the Balance Point\n\n\nShow/hide deviations\n\n\nShow/hide squared deviations\n\n\n\n\n\n\nwidth = 600\nheight = 600\nn_boxes = 5\nscale_width = 11\nbox_size = width / scale_width\nbeam_height = box_size / 4\nradius = box_size\n\n// multiply the deviations lined up at the bottom to fit on the screen\nmultiplier = 6/n_boxes\n\nbox_data_ = make_box_data(n_boxes)\n\n\nchart = {\n\n  let deviations_hidden = false;\n  let squared_deviations_hidden = false;\n  \n  &lt;!-- const controls = d3.select(\"#controls\") --&gt;\n  &lt;!-- const button = controls --&gt;\n  &lt;!--     .append(\"input\") --&gt;\n  &lt;!--     .attr(\"type\", \"button\") --&gt;\n  &lt;!--     .attr(\"name\", \"showDevs\") --&gt;\n  &lt;!--     .attr(\"value\", \"Toggle\") --&gt;\n  &lt;!--     .attr(\"onclick\", noDevs) --&gt;\n\n  function round_position(x) {\n    let interval = width / scale_width\n    return Math.round(x / interval)*interval\n  }\n\n  function rounded_position_index(x) {\n    let interval = width / scale_width\n    let x0 = Math.round(x / interval)*interval\n    return Math.round(x0/(width/scale_width))  \n  }\n  \n  let positions = d3.range(scale_width).map(i =&gt; (0))\n\n  function stack_boxes() {\n    for (let i = 0; i &lt; box_data.length; i++) {\n      box_data[i].level = positions[box_data[i].x0]\n      positions[box_data[i].x0]++\n    }\n  }\n\n  let starting_boxes = [1, 2, 6, 6, 10]\n  \n  // let box_data = d3.range(n_boxes).map(i =&gt; ({\n  //     // x: (Math.random() * (width - box_size * 2) + box_size),\n  //     x0: Math.floor(Math.random() *   scale_width),\n  //     y: -box_size, // height/2 - beam_height/2 - radius,\n  //     color: d3.schemeCategory10[i % 10],\n  //     level: 0\n  //     }))\n      \n  let box_data = box_data_;\n\n  for (let i = 0; i &lt; box_data.length; i++) box_data[i].x = box_data[i].x0 * box_size\n  \n  \n  let mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n  let pivot = mean\n  \n  box_data = box_data.sort(function(a, b) { return Math.abs(a.x - pivot) - Math.abs(b.x - pivot); })\n  for (let i = 0; i &lt; box_data.length; i++) {\n    box_data[i].id = i\n  }\n    \n    stack_boxes()\n    \n    \n  const svg = d3.select(\"#chart\").append(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"stroke-width\", 2)\n\n  const x_ = d3.scaleLinear()\n    .range([0, width])\n    .domain([0, 10])\n    \n  // draw the ground\n  svg.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\", 50)\n    .attr(\"fill\", \"#f0f0f0\")\n    .attr(\"stroke\", \"none\")\n    .attr(\"transform\", `translate(0, ${height - 51})`)\n\n  const beam_and_boxes = svg.append(\"g\")\n    .attr(\"transform\", `translate(0, ${height - 50 - radius - beam_height})`)\n  \n  // draw the beam\n  beam_and_boxes.append(\"rect\")\n    .attr(\"width\", width)\n    .attr(\"height\",  beam_height)\n    .attr(\"rx\", 3)\n    .attr(\"fill\", \"black\")\n    // .attr(\"transform\", `translate(0, ${height/2 - beam_height / 2})`)\n\n  const boxes = beam_and_boxes.append(\"g\")\n  const deviations = beam_and_boxes.append(\"g\")\n  const deviations_vertical = deviations.append(\"g\")\n  const deviations_horizontal = deviations.append(\"g\")\n  const deviations_sum = svg.append(\"g\").attr(\"transform\", `translate(0, ${height - 25})`)\n  const deviations_sum_negative = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, -10)`)\n  const deviations_sum_positive = deviations_sum.append(\"g\").attr(\"transform\", `translate(0, 10)`)\n  \n  // draw the boxes\n  boxes.selectAll(\"rect\")\n    .data(box_data)\n    .join(\"rect\")\n      .attr(\"x\", d =&gt; d.x)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n      .attr(\"width\", box_size)\n      .attr(\"height\", box_size)\n      .attr(\"rx\", 1)\n      .attr(\"fill\", d =&gt; d.color)\n      .attr(\"stroke\", null)\n      .call(d3.drag().on(\"start\", start_dragging_box)\n                     .on(\"drag\", dragging_box)\n                     .on(\"end\", stop_dragging_box));\n  \n  // draw a circle at the true mean point\n  const circle = beam_and_boxes.append(\"circle\")\n    .attr(\"cx\", mean)\n    .attr(\"cy\", beam_height/2)\n    .attr(\"r\", 5)\n    .attr(\"fill\", \"#777777\")\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n  // draw a triangle at the pivot point\n  const triangle = svg.append(\"polygon\")\n    .attr(\"points\", [[0, -radius/2], [radius/2, radius/2], [-radius/2, radius/2]])\n    .attr(\"fill\", \"red\")\n    .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n    .call(d3.drag()\n             .on(\"start\", start_dragging_mean)\n             .on(\"drag\", dragging_mean)\n             .on(\"end\", stop_dragging_mean))\n  \n    \n  draw_deviations()\n  \n\n  function start_dragging_mean(event, d) {triangle.attr(\"fill\", \"dodgerblue\")}\n  \n  function stop_dragging_mean(event, d) {triangle.attr(\"fill\", \"red\")}\n  \n  function dragging_mean(event, d) {\n      pivot = event.x\n      tip_scale()\n  }\n  \n  function tip_scale() {\n  \n    let angle = Math.abs((mean - pivot)*0.5);\n    let hypotenuse, direction;\n    \n    if (pivot &lt; mean) {\n      hypotenuse = width - pivot;\n      direction = 1;\n    } else {\n      hypotenuse = pivot;\n      direction = -1;\n    }\n    \n    let tri_angle = 90 - (Math.acos(radius / hypotenuse) * 180/Math.PI)\n    angle = direction * (Math.min(angle, tri_angle))\n    \n      triangle\n        .attr(\"transform\", `translate(${pivot}, ${height-50-radius/2})`)\n      beam_and_boxes\n        .attr(\"transform\", `translate(0, ${height-50-radius-beam_height}) rotate(${angle}, ${pivot}, ${0})`)\n      draw_deviations()\n  }\n\n  \n  function start_dragging_box(event, d) {\n    d3.select(this).raise().attr(\"stroke\", \"black\")\n    // console.log(\"x:\" + d.x + \" x0:\" + d.x0 + \" level:\" + d.level)\n  }\n\n  function dragging_box(event, d) {\n    box_data[d.id].x = event.x\n    // box_data[d.id].x0 = round_position(box_data[d.id].x) + box_size/2\n    \n    let current_position = box_data[d.id].x0\n    let current_level = box_data[d.id].level\n    let new_position = rounded_position_index(event.x)\n    \n    if(new_position != current_position) {\n      console.log(\"moved! from \" + current_position + \" to \" + new_position)\n      \n      // update the box's position\n      box_data[d.id].x0 = new_position\n      \n      // now this box should go on top of the stack for new_position\n      box_data[d.id].level = positions[new_position]\n      \n      // and update the total number of boxes in that position\n      positions[new_position]++\n      \n      // for the old position, reduce the number of boxes by one, and\n      // bump down any boxes that had a higher level that this box\n      positions[current_position]--\n      for (let i = 0; i &lt; box_data.length; i++) {\n        if (d.id==i) continue\n        if (box_data[i].x0==current_position && box_data[i].level &gt; current_level) {\n            box_data[i].level--\n            console.log(\"movin on down\")\n        } \n      }\n    }\n    \n    tip_scale()\n    // draw_deviations()\n  }\n\n  function stop_dragging_box(event, d) {\n    d3.select(this).attr(\"stroke\", null)\n  }\n  \n  \n\n\n  function draw_deviations() {\n    \n    mean = box_data.reduce((total, next) =&gt; total + next.x + box_size/2, 0) / box_data.length\n    \n    boxes.selectAll(\"rect\")\n      .attr(\"x\", d =&gt; d.x0 * box_size)\n      .attr(\"y\", d =&gt; d.y - d.level*box_size)\n    \n    circle.attr(\"cx\", mean)\n    \n    // calculate deviations\n    for (let i = 0; i &lt; box_data.length; i++) box_data[i].dev = (box_data[i].x0*box_size + (box_size/2)) - pivot\n    \n    let deviations_negative = box_data.filter(function(d){ return d.dev &lt; 0})\n    for (let i = 0; i &lt; deviations_negative.length; i++) {\n      if (i==0) deviations_negative[i].dev_start = 0\n      else deviations_negative[i].dev_start = deviations_negative[i-1].dev_end\n      deviations_negative[i].dev_end = deviations_negative[i].dev_start + Math.abs(deviations_negative[i].dev)\n    }\n    \n    let deviations_positive = box_data.filter(function(d){ return d.dev &gt; 0})\n    for (let i = 0; i &lt; deviations_positive.length; i++) {\n      if (i==0) deviations_positive[i].dev_start = 0\n      else deviations_positive[i].dev_start = deviations_positive[i-1].dev_end\n      deviations_positive[i].dev_end = deviations_positive[i].dev_start + Math.abs(deviations_positive[i].dev)\n    }\n    \n    deviations_vertical.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"y1\", d =&gt; d.y - d.level * box_size)\n        .attr(\"y2\", d =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        \n    deviations_vertical\n      .append(\"line\")\n      .attr(\"x1\", pivot).attr(\"x2\", pivot)\n      .attr(\"y1\", 0).attr(\"y2\", -height)\n      .attr(\"stroke\", \"red\").attr(\"stroke-dasharray\", [10, 10])\n\n    deviations_horizontal.selectAll(\"line\")\n      .data(box_data)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; box_size * d.x0 + box_size/2)\n        .attr(\"x2\", pivot)\n        .attr(\"y1\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"y2\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 3)\n        \n    if (!squared_deviations_hidden) update_squared_deviations();\n    \n\n    deviations_sum_negative.selectAll(\"line\")\n      .data(deviations_negative)\n      .join(\"line\")\n        .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n        \n    deviations_sum_positive.selectAll(\"line\")\n      .data(deviations_positive)\n      .join(\"line\")\n      .attr(\"x1\", d =&gt; d.dev_start * multiplier)\n        .attr(\"x2\", d =&gt; d.dev_end * multiplier)\n        .attr(\"stroke\", d =&gt; d.color)\n        .attr(\"stroke-width\", 8)\n  };\n  \n  \n  function update_squared_deviations() {\n      deviations_horizontal.selectAll(\"rect\")\n      .data(box_data)\n      .join(\"rect\")\n        .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n        .attr(\"width\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", d =&gt; Math.abs(d.dev))\n        .attr(\"height\", function(d){if(squared_deviations_hidden){return 0} else{return Math.abs(d.dev)}})\n        .attr(\"fill\", d =&gt; d.color)\n        .attr(\"opacity\", 0.5)\n        .attr(\"stroke\", \"none\")\n  }\n  \n  \n\n  function noDevs() {\n    deviations_hidden = !deviations_hidden\n    deviations.attr(\"opacity\", Number(!deviations_hidden))\n  }\n  \n  function noDevsSq() {\n    squared_deviations_hidden = !squared_deviations_hidden\n  \n    if (squared_deviations_hidden) {\n      deviations_horizontal\n        .selectAll(\"rect\")\n        .data(box_data)\n        .transition().duration(1000)\n        .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25)\n        .attr(\"height\", 0)\n    } else {\n        deviations_horizontal\n          .selectAll(\"rect\")\n          .data(box_data)\n          .attr(\"x\", function(d) {if(d.dev &lt; 0) {return box_size * d.x0 + box_size/2} else {return pivot} })\n          .attr(\"width\", d =&gt; Math.abs(d.dev))\n          .transition().duration(1000)\n          .attr(\"y\", (d, i) =&gt; d.y - box_size/2 - d.level * box_size - d.id * 25 - Math.abs(d.dev))\n          .attr(\"height\", d =&gt; Math.abs(d.dev))\n    }\n    \n  }\n\n  noDevs()\n  noDevsSq()\n  d3.select(\"#showDevs\").on(\"click\", noDevs)\n  d3.select(\"#showDevsSq\").on(\"click\", noDevsSq)\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction make_box_data(n) {\n    return d3.range(n).map(i =&gt; ({\n      // x: (Math.random() * (width - box_size * 2) + box_size),\n      x0: Math.floor(Math.random() *   scale_width),\n      y: -box_size, // height/2 - beam_height/2 - radius,\n      color: d3.schemeCategory10[i % 10],\n      level: 0\n      }))\n  }"
  },
  {
    "objectID": "visualizations/least-squared-error.html",
    "href": "visualizations/least-squared-error.html",
    "title": "Least Squared Error",
    "section": "",
    "text": "Regression: The Least Squared Error Solution\nIntercept (\\(a\\)): hi \nSlope (\\(b\\)): hi \n\n\n\n\nchangable_chart = {\n\n  const w = 600;\n  const h = 500;\n  \n  const margin = {top: 20, right: 20, left: 110, bottom: 75}\n\n  const x_values = [4,5,7,8,11]\n  const y_values = [5,8,8,10,9]\n  const yhat_values = [0,0,0,0,0]\n  \n  const data = [{xVal: 4, yVal: 5},\n                {xVal: 5, yVal: 8},\n                {xVal: 7, yVal: 8},\n                {xVal: 8, yVal: 10},\n                {xVal: 11, yVal: 9}]\n                \n  const aInput = d3.select(\"#a-control\")\n  const bInput = d3.select(\"#b-control\")\n  \n  aInput.on(\"input\", drawFitLine);\n  bInput.on(\"input\", drawFitLine);\n  \n  const x = d3.scaleLinear()\n    .range([margin.left, w - margin.right])\n    .domain([0, 12])\n  const y = d3.scaleLinear()\n    .range([h - margin.bottom, margin.top])\n    .domain([0, 10])\n  \n  const xAxis = d3.axisBottom(x);\n  const yAxis = d3.axisLeft(y);\n  \n  \n  const svg = d3.select(\"#error-plot-container\").append(\"svg\")\n    .attr(\"width\", w)\n    .attr(\"height\", h)\n    \n  const axes = svg.append(\"g\")\n  const axisFontSize = \"0.7em\"\n  axes.append(\"g\").attr(\"transform\", `translate(0, ${h - margin.bottom})`).call(xAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  axes.append(\"g\").attr(\"transform\", `translate(${margin.left}, 0)`).call(yAxis).style(\"font-size\", axisFontSize).attr(\"font-family\", \"Times New Roman\");\n  \n  const axisTitles = svg.append(\"g\")\n    .style(\"font-size\", \"0.8em\")\n    .style(\"font-family\", \"Times New Roman\")\n    .style(\"fill\", \"var(--text-color)\")\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(${margin.left + (w - margin.left - margin.right) / 2}, ${h - 10})`).text(\"Sleep duration\")\n    .attr(\"text-anchor\", \"middle\");\n  \n  axisTitles.append(\"text\")\n    .attr(\"transform\", `translate(0, ${margin.top + (h - margin.top - margin.bottom) / 2})`)\n    .text(\"Score\")\n    \n  \n  const residuals = svg.append(\"g\")\n  residuals.selectAll(\"line\").data(data).enter()\n      .append(\"line\")\n        .attr(\"x1\", d =&gt; x(d.xVal))\n        .attr(\"x2\", d =&gt; x(d.xVal))\n        .attr(\"y1\", d =&gt; y(d.yVal))\n        &lt;!-- .attr(\"y2\", d =&gt; y(d.yVal)) --&gt;\n        .style(\"stroke\", \"red\")\n        .style(\"stroke-width\", 2)\n        .attr(\"stroke-dasharray\", [5, 3])\n        \n  const fitLine = svg.append(\"line\")\n    .style(\"stroke\", \"dodgerblue\")\n    .style(\"stroke-width\", 3)\n    \n  const dots = svg.append(\"g\")\n  const squares = svg.append(\"g\")\n  const ssResidualSquare = svg.append(\"g\").append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.5)\n    \n  dots.selectAll(\"circle\").data(data).enter().append(\"circle\")\n    .attr(\"cx\", d =&gt; x(d.xVal))\n    .attr(\"cy\", d =&gt; y(d.yVal))\n    .attr(\"r\", 5)\n    .style(\"fill\", \"var(--text-color)\")\n    \n  squares.selectAll(\"polygon\").data(data).enter()\n    .append(\"polygon\")\n    .style(\"fill\", \"plum\")\n    .style(\"opacity\", 0.5)\n    \n  function drawFitLine() {\n    var a = Number(aInput.property(\"value\"));\n    d3.select(\"#a-output\").text(a);\n    var b = Number(bInput.property(\"value\"));\n    d3.select(\"#b-output\").text(b);\n    \n    var yhat1 = a\n    var yhat2 = b * 12 + a\n    \n    fitLine\n      .attr(\"x1\", x(0))\n      .attr(\"x2\", x(12))\n      .attr(\"y1\", y(yhat1))\n      .attr(\"y2\", y(yhat2))\n      \n    var ssResidual = 0;\n    \n    for(var i = 0; i &lt; data.length; i++) {\n      var yHat = b * data[i].xVal + a;\n      var residual = data[i].yVal - yHat\n      data[i].yHat = yHat;\n      data[i].res = residual;\n      \n      ssResidual += Math.pow(residual, 2);\n    }\n    \n    residuals.selectAll(\"line\")\n        .attr(\"y2\", d =&gt; y(d.yHat))\n        \n    squares.selectAll(\"polygon\")\n      .attr(\"points\", d =&gt; [[x(d.xVal), y(d.yVal)],\n                            [x(d.xVal), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yHat)],\n                            [x(d.xVal + Math.abs(d.res)), y(d.yVal)]])\n                            \n    ssResidualSquare\n    .attr(\"points\", [[x(9), y(3)],\n                     [x(9), y(3 - Math.sqrt(ssResidual))],\n                     [x(9 + Math.sqrt(ssResidual)), y(3 - Math.sqrt(ssResidual))],\n                     [x(9 + Math.sqrt(ssResidual)), y(3)]])\n  }\n  \n  drawFitLine();\n  \n  svg.append(\"polygon\")\n    .attr(\"points\", [[x(9), y(3)],\n                     [x(9), y(3 - Math.sqrt(6.5))],\n                     [x(9 + Math.sqrt(6.5)), y(3 - Math.sqrt(6.5))],\n                     [x(9 + Math.sqrt(6.5)), y(3)]])\n    .style(\"fill\", \"none\")\n    .style(\"stroke\", \"black\")\n    .style(\"stroke-dasharray\", [5, 3])\n    \n\n  \n\n}\n\n\n\n\n\n\n\n\nAbout\nExplanation goes here."
  },
  {
    "objectID": "visualizations/least-squared-error.html#about",
    "href": "visualizations/least-squared-error.html#about",
    "title": "Least Squared Error",
    "section": "",
    "text": "Explanation goes here."
  },
  {
    "objectID": "visualizations/confidence-intervals.html",
    "href": "visualizations/confidence-intervals.html",
    "title": "Confidence Intervals",
    "section": "",
    "text": "CI =Â 80%\n\nNumber of cards:  3 5 10 30  Draw cards \n\n\n\n\n\nM ="
  },
  {
    "objectID": "visualizations/confidence-intervals.html#about",
    "href": "visualizations/confidence-intervals.html#about",
    "title": "Confidence Intervals",
    "section": "About",
    "text": "About\nA deck of playing cards is a known population consisting of the numbers 1 through 13 repeated 4 times, once for each suit. The average of this population (\\(\\mu\\)) is 7.00, and the standard deviation (\\(\\sigma\\)) is 3.78.\nIn the visualization above, you can take samples from this population repeatedly. Each sample produces an estimate of the population parameter with a margin of uncertainty: this is the confidence interval for the sample.\nThe interpretation of the confidence interval, however, is subtle. The confidence interval is a statement about repeated, long-run probabilities. If we sample from a population repeatedly, the proportion of confidence intervals which include the true population mean will be equal to the specified level of confidence. For example, if we compute an 80% CI for each sample, around 80% of those CIs will include the population mean.\nSo what does the confidence interval for a single sample tell us? The width of the CI reflects the variability in our sample, but it doesnâ€™t allow us to put a probabilistic value on the population parameter. A common mistake is to think that the confidence interval tells us, with the given degree of confidence, that the true population parameter is a value somewhere within the stated range. This sounds intuitive but itâ€™s not quite true. Under the frequentist approach, the population parameter is a fixed constant, and we canâ€™t make probabilistic statements about constants. So strictly speaking, the CI for a single sample reflects the uncertainty in that sampleâ€™s estimate of the parameter rather than uncertainty about the true value of the parameter.\nMaybe that sounds a bit disappointing. Surely the whole point of taking a sample is to be able to say something about the population it came from? Well, yes. This is where confidence intervals connect to Null Hypothesis Significance Testing. Rather than saying how confident we are that the population parameter is within a certain range, the sample (and its CI) can help us make an inference about whether the parameter is (or isnâ€™t) some specific hypothetical value.\nLetâ€™s say we suspect that someone has removed some cards from our deck and so its population mean is not, in fact, 7. Our â€œalternative hypothesisâ€ would be that \\(\\mu \\ne 7\\). The null hypothesis, that our deck hasnâ€™t been tampered with, would be that \\(\\mu = 7\\). We will reject the null hypothesis if the sample looks sufficiently unlikely to have been produced by the hypotheical null hypothesis population. To quantify â€œsufficiently unlikelyâ€ we choose an â€œalphaâ€ (\\(\\alpha\\)) value, some low probability. Weâ€™re willing to accept the risk that weâ€™re making a mistake.\nThe visualization about really is sampling from a fair deck with a mean of 7. But as youâ€™ll see, some of the confidence intervals in the visualization above donâ€™t include the true population mean. They would cause us to reject the null hypothesis (\\(\\mu = 7\\)) and lead us to believe that someone has indeed tampered with the cards. Weâ€™d be making a mistake; it just so happened that we obtained a sample for which the confidence interval didnâ€™t contain the true population meanâ€“which is what we can expect to happen with a probability equal to the specified confidence. So in this sense, the interpretation of any single confidence interval is most closely related to the binary decision about the null hypothesis; if the null value lies outside our confidence interval, we reject the null hypothesis; if itâ€™s inside, we donâ€™t reject it.\nThe deck cards is a convenient example of a known population, but generally speaking we donâ€™t know the true population parameterâ€“thatâ€™s the whole reason for taking sample and applying statistics!\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\nchart = {\n\n  let sampleSize = Number(d3.select(\"#sampleSize\").property(\"value\"));\n  let sampling = false;\n  let sample = [];\n\n  const w = 1050\n  const h = 600\n  const margin = {left: 50, right: 50, top: 50, bottom: 50}\n  \n  let x = d3.scaleLinear()\n    .domain([0, 30])\n    .range([margin.left, w - margin.right])\n  const y = d3.scaleLinear()\n    .domain([1, 13])\n    .range([h - margin.bottom, margin.top])\n    \n  const yAxis = d3.axisLeft(y)\n    .ticks(11)\n\n  const f = d3.format(\".2f\")\n  const f1 = d3.format(\".1f\")\n\n  var sampleArr = []\n  var meansArr = []\n  var ciArr = []\n  \n  const ciInput = document.getElementById('ci-input');\n  const sampleSizeInput = d3.select('#sampleSize');\n  const buttonRandom = document.getElementById('addRandom');\n  \n\n  sampleSizeInput.on(\"change\", () => setup()); \n\n  var ciWidth = Number(ciInput.value)\n\n  function makeCards(n, divId) {\n\n    d3.select(\"#\" + divId).selectAll(\"div\").remove();\n    for (let i = 0; i < n; i++) {\n\n      d3.select(\"#\" + divId).append(\"div\")\n        .attr(\"id\", \"card\" + (i + 1))\n        .attr(\"class\", \"playing-card-container\")\n        .classed(\"playing-card-blank\", true)\n    }\n  }\n\n  function setup() {\n    sampleSize = Number(d3.select(\"#sampleSize\").property(\"value\"));\n    reset();\n    makeCards(sampleSize, \"cards\");\n  }\n\n  function reset() {\n    sample = [];\n    sampleArr = [];\n\n    dots.selectAll(\"circle\").remove();\n    lines.selectAll(\"line\").remove();\n\n    d3.select(\"#proportion\").text(\"#\");\n    d3.select(\"#count\").text(\"#\");\n    d3.select(\"#mean\").text(\"\");\n\n    x.domain([0, 30]);\n  }\n\n  makeCards(sampleSize, \"cards\");\n  \n  \n  function addSampleToPlot(values) {\n  \n    let mean = getM(values)\n    // let sd = getSD(values)\n    let sd = jStat.stdev(values, true);\n    let ci = getCI(values, ciWidth)\n    let containsMu = ciContainsMu(mean, ci)\n    let n = sampleArr.length + 1\n    \n    sampleArr.push({sample: values, mean: mean, ci: ci, containsMu: containsMu, id: n})\n    \n    // addCI(sampleArr.length, mean, ci)\n    drawCIs(sampleArr);\n\n    d3.select(\"#proportion\").text(f1(proportionOfCIs(sampleArr) * 100));\n    d3.select(\"#count\").text(sampleArr.length);\n    d3.select(\"#mean\").text(f(mean) + \" [\" + f(mean - ci) + \", \" + f(mean + ci) + \"]\");\n  }\n  \n  buttonRandom.onclick = () => newSample(sampleSize, false);\n  d3.select(\"#drawContinuously\").on(\"click\", sampleContinuously);\n\n  function newSample(sampleSize, quick = true) {\n\n    sample = [];\n    for (let i = 1; i < sampleSize + 1; i++) {\n      const value = Math.floor(Math.random() * 13 + 1);\n      sample.push(value);\n      d3.select(\"#card\" + i).html(randomCard(value - 1))\n    }\n\n    console.log(sample);\n\n    addSampleToPlot(sample);\n\n    if (!quick) {\n    d3.selectAll(\".playing-card-container\")\n      .data(sample)\n      .classed(\"playing-card-blank\", true)\n      .transition().duration(0).delay((d,i) => 100 + i * 100)\n      .attr(\"class\", \"playing-card-container\")\n    }\n\n  }\n  \n  function randomCard(value) {\n\n    const suits = [\"\\u2660\",\"\\u2665\",\"\\u2666\",\"\\u2663\"];\n    const colors = [\"black\", \"red\", \"red\", \"black\"];\n    const cards = [\"A\",2,3,4,5,6,7,8,9,10,\"J\",\"Q\",\"K\"];\n    \n    const suitIndex = Math.floor(Math.random() * suits.length);\n    const cardIndex = value;\n\n    return \"<div class='playing-card-value'>\" + cards[cardIndex] + \"</div>\" + \"<div class='playing-card playing-card-\" + colors[suitIndex] + \"'>\" + suits[suitIndex] + \"</div>\";\n  }\n  \n  ciInput.oninput = function() {\n    ciWidth = ciInput.value\n    d3.select(\"#ci-width\").text(ciWidth);\n    updateCIs(ciWidth)\n\n    const newCI = getCI(sample, ciWidth);\n    const m = getM(sample);\n    d3.select(\"#mean\").text(f(m) + \" [\" + f(m - newCI) + \", \" + f(m + newCI) + \"]\");\n  }\n\nlet samplingInterval;\nconst sampleContinuouslyBtn = d3.select(\"#drawContinuously\");\n\n  function sampleContinuously() {\n\n    if (!sampling) {\n      sampling = true;\n      d3.selectAll(\".playing-card-container\")\n      .classed(\"playing-card-blank\", false);\n\n      samplingInterval = setInterval(() => {\n        newSample(sampleSize);\n    }, 10);\n\n    sampleContinuouslyBtn.html(\"<i class='bi bi-stop'></i>\").attr(\"class\", \"btn btn-danger\")\n\n    } else {\n      sampleContinuouslyBtn.html(\"<i class='bi bi-play'></i>\").attr(\"class\", \"btn btn-outline-success\")\n      clearInterval(samplingInterval);\n      sampling = false;\n    }\n  }\n\n  \n  \n  const svg = d3.select(\"#plot-container\").append(\"svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + w + \" \" + h)\n    \n  const gridY = svg.append(\"g\")\n  \n  // population mean line\n  gridY.append(\"line\")\n    .attr(\"x1\", x(0))\n    .attr(\"x2\", x(30))\n    .attr(\"y1\", y(7))\n    .attr(\"y2\", y(7))\n    .style(\"stroke\", \"grey\")\n    .attr(\"stroke-width\", 2)\n  gridY.append(\"text\")\n    .attr(\"x\", x(0.2))\n    .attr(\"y\", y(7.05))\n    .text(\"true population mean\")\n    \n  const lines = svg.append(\"g\")\n  const dots = svg.append(\"g\")\n  \n  const axisY = svg.append(\"g\")\n  axisY.append(\"rect\").attr(\"x\", -margin.left).attr(\"width\", margin.left).attr(\"height\", h)\n    .attr(\"fill\", \"var(--mermaid-bg-color)\");\n  axisY.call(yAxis)\n    .attr(\"transform\", `translate(${x(0)},0)`)\n\n  \n  function drawCIs(arr) {\n\n    const n = arr.length;\n\n    if (n > 30) {\n      x.domain([n - 30, n]);\n    }\n  \n  <!-- dot for the point estimate -->\n  dots.selectAll(\"circle\").remove();\n\n    dots.selectAll(\"circle\").data(arr).enter().append(\"circle\")\n      .attr(\"r\", 4)\n      .attr(\"cx\", d => x(d.id))\n      .attr(\"cy\", d => y(d.mean))\n  \n  // lines.selectAll(\"line\")\n  //   .attr(\"x1\", x(n))\n  //   .attr(\"x2\", x(n))\n  \n  <!-- lines for CI -->\n  lines.selectAll(\"line\").remove();\n  \n  lines.selectAll(\"line\").data(arr).enter().append(\"line\")\n      .attr(\"x1\", d => x(d.id))\n      .attr(\"x2\", d => x(d.id))\n      .attr(\"y1\", d => y(d.mean + d.ci))\n      .attr(\"y2\", d => y(d.mean - d.ci))\n      .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", d => d.containsMu)\n      .classed(\"newest-line\", d => (d.id == n) ? true : false)\n\n    // lines.selectAll(\".newest-line\")\n    // .transition().duration(0)\n    //   .attr(\"y1\", y(arr[n-1].mean)).attr(\"y2\", y(arr[n-1].mean))\n    // .transition().duration(250)\n    //   .attr(\"y1\", y(arr[n-1].mean + arr[n-1].ci)).attr(\"y2\", y(arr[n-1].mean - arr[n-1].ci))\n\n    if (n > 30) {\n      dots.selectAll(\"circle\")\n      .transition().duration(200).ease(d3.easeLinear)\n      .attr(\"cx\", d => x(d.id - 1))\n\n      lines.selectAll(\"line\")\n      .transition().duration(200).ease(d3.easeLinear)\n      .attr(\"x1\", d => x(d.id - 1))\n      .attr(\"x2\", d => x(d.id - 1))\n    }\n\n      \n  }\n\n\n\n\n\n  function updateCIs (confidence) {\n  \n  <!-- take the array and recalculate all CIs -->\n  const n = sampleArr.length;\n  for (var i = 0; i < sampleArr.length; i++) {\n    sampleArr[i].ci = getCI(sampleArr[i].sample, confidence);\n    sampleArr[i].containsMu = ciContainsMu(sampleArr[i].mean, sampleArr[i].ci);\n  }\n  \n  <!-- then redraw all CIs on the svg -->\n  lines.selectAll(\"line\").remove()\n  \n  lines.selectAll(\"line\")\n  .data(sampleArr)\n  .enter()\n    .append(\"line\")\n      .attr(\"x1\", d => (n > 30) ? x(d.id - 1) : x(d.id))\n      .attr(\"x2\", d => (n > 30) ? x(d.id - 1) : x(d.id))\n      .attr(\"y1\", d => y(d.mean + d.ci))\n      .attr(\"y2\", d => y(d.mean - d.ci))\n      .attr(\"class\", \"ci-line\")\n      .classed(\"ci-contains-mu\", d => ciContainsMu(d.mean, d.ci))\n    \n    d3.select(\"#proportion\").text(f1(proportionOfCIs(sampleArr) * 100));\n  }\n  \n  \n  \n}\n\n\nfunction getM (array) {\n  const n = array.length\n  const mean = array.reduce((a, b) => a + b) / n\n  return mean\n}\n\nfunction getSD (array) {\n  const n = array.length\n  const df = n - 1\n  const mean = getM(array)\n  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / df)\n}\n\nfunction getCI (array, confidence) {\n  const mean = jStat.mean(array);\n  const alpha = 1 - confidence / 100;\n  return mean - jStat.tci(mean, alpha, array )[0];\n\n}\n\n\nfunction ciContainsMu (point, ci) {\n  return (point + ci > 7 && point - ci < 7);\n}\n\nfunction proportionOfCIs(arr) {\n    const x = arr.map(a => a.containsMu);\n    const prop = x.reduce((acc, curr) => {\n  return acc + (curr ? curr : 0);\n}, 0);\n\n    return prop / arr.length;\n}"
  },
  {
    "objectID": "visualizations/unbiased-estimates.html#about",
    "href": "visualizations/unbiased-estimates.html#about",
    "title": "(Un)Biased estimates",
    "section": "About",
    "text": "About\nTo say a statistic is unbiased is to say that, on average, its value is equal to the parameter it is estimating. Sampling error, the inherent randomness which determines which observations appear in the sample, ensures that each individual sample will produce a different estimate; any given sampleâ€™s statistic wonâ€™t be exactly equal to the parameter. But if many samples are taken, the average of all those statistics will converge on the true population parameterâ€™s value.\nThe arithmetic average is an unbiased statistic. Each sampleâ€™s mean will be different, some above the true population mean and some below. Because the discrepancy is random, however, with many samples the overestimates and underestimates balance out. The average of all the differences between each sample average and the true population average will be close to zero. Thatâ€™s what makes the mean unbiased.\nStandard deviation is more complicated. There are two different equations for standard deviation. In both cases, you first calculate the mean, then the sum of squared deviations from the mean. If the data represents a complete population, you then divide the sum of squared deviations by N, the total number of observations in the entire population. With data from a sample, however, you divide by n - 1, the number of scores in the sample minus 1. This is because if you use the first approach with data from a sample, dividing by N, the statistic will be biased.\nMore specifically, using the population standard deviation equation with sample data has the effect of systematically underestimating the population parameter. As with the mean, each sample produces a slightly different estimate, but unlike the mean, the difference between estimate and parameter is not completely random. More samples will underestimate the population variability than overestimate it. As a result, the average of all sample estimates of standard deviation would be lower than the true population value.\nDividing by n - 1 when calculating a sampleâ€™s standard deviation corrects for that bias, producing an unbiased estimate. Why? It has to do with the fact that the standard deviation is a measure of variability, a measure of how spread out the data is. When you estimate the population standard deviation from a sample, youâ€™re trying to use a small subset of the population to estimate the variability in the entire population.\nBut, thereâ€™s an inherent problem here. When we calculate the standard deviation of a sample, weâ€™re using the sample mean, not the population mean, because the population mean is usually unknown. The sample mean, being calculated from the data in the sample, is more likely to be closer to the individual data points in the sample than the population mean would be. This means the squared deviations from the sample mean are likely to be smaller, on average, than the squared deviations from the population mean. This is what leads to the underestimate of the variance, and hence the standard deviation, when we divide by Nâ€™ instead of n - 1.\nNow, why n - 1 instead of, say, n - 2 or n - 3? This has to do with something in statistics known as â€˜degrees of freedomâ€™. Degrees of freedom are, in a way, the number of values that are free to vary given the constraints in the problem.\nIn the case of variance and standard deviation, the constraint is the sample mean. Once weâ€™ve calculated the sample mean, the sum of the deviations from the mean must equal zero. This means that once we know the deviations of n - 1 values, the deviation of the nth value is completely determined. So, we say we have n - 1 degrees of freedom.\nWhen you divide by n - 1 instead of â€˜nâ€™, you are effectively adjusting the sample variance and sample standard deviation upwards to account for the fact that youâ€™ve underestimated the squared deviations because you used the sample mean instead of the population mean. This adjustment gives a larger value for the sample variance and sample standard deviation, which on average gives a better (i.e., unbiased) estimate of the population variance and population standard deviation.\nThis visualization can demonstrate this effect: if you take many samples and calculate the sample standard deviation using n and n - 1 in the denominator, youâ€™ll see that the average of the sample standard deviations calculated with n - 1 in the denominator will be closer to the true population standard deviation, while those calculated with â€˜nâ€™ in the denominator will tend to underestimate it. This shows how the n - 1 adjustment corrects for the bias in estimating the population standard deviation from a sample."
  }
]