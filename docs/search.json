[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "games/jellybeans.html",
    "href": "games/jellybeans.html",
    "title": "Psych Stats",
    "section": "",
    "text": "How many jellybeans in the jar?\n    \n    \n        \n    \n\n\n    Reveal\n\n\njar = {\n    let width = 500;\nlet height = 600;\nlet x0 = width / 2;\n\nlet colorPal = [\n    '#ff8aa6', // Pastel Pink\n    '#ff9b48', // Pastel Orange\n    '#fff067', // Pastel Yellow\n    '#9EE09E', // Pastel Green\n    '#71c4e6', // Pastel Blue\n    '#edceff', // Pastel Purple\n    '#fc5c30', // Pastel Brown\n    '#CAF7E2'  // Pastel Mint\n];\n\n\nfunction randomColor(colorPal) {\n    return colorPal[Math.floor(Math.random() * colorPal.length)];\n}\n\nfunction getBeanProperties(colorPal) {\n    return {\n        label: \"circle\",\n        mass: 100,\n        restitution: 0.5,\n        friction: 0.01,\n        frictionAir: 0.025,\n        frictionStatic: 0,\n        density: 1,\n        slop: 0.05,\n        sleepThreshold: 15,\n        render: { fillStyle: randomColor(colorPal) }\n    };\n}\n\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet intervalId = null;\nconst generationSpeed = 20;\n\nlet params = randomizeParams();\nlet engine = initializeWorld(\"board\", \"canvas\", width, height);\n\nComposite.add(engine.world, makeJar(params));\n\nlet generateBean = createBeanGenerator(params, x0, colorPal);\naddBeansToWorld(engine.world, generateBean, generationSpeed);\n\nengine;\n\nfunction randomizeParams() {\n    const generationSpeed = 20;\n    const jarCount = 0;\n    const jarWidth = 0.5 + Math.random() * 0.4;\n    const jarHeight = 0.5 + Math.random() * 0.2;\n    const beanRadius = 6 + Math.random() * 6;\n    const nBeans = Math.floor(4000 * (jarWidth * jarHeight) * (1 / beanRadius));\n    \n    return {nBeans, beanRadius, generationSpeed, jarWidth, jarHeight, jarCount};\n}\n\nfunction initializeWorld(element, canvas, width, height) {\n    let engine = Engine.create({\n        enableSleeping: true\n    }),\n    world = engine.world;\n    // create renderer\n    let render = Render.create({\n        element: document.getElementById(element),\n        canvas: document.getElementById(canvas),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n    \n    let runner = Runner.create();\n    Runner.run(runner, engine);\n\n    // Reset simulation on mousedown events\n    render.canvas.addEventListener(\"mousedown\", handleReset);\n\n    return {world, render};\n}\n\n\nfunction createBeanGenerator(params, x, colors) {\n    let total = params.nBeans;\n\n    return function generateBean() {\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x + (-0.5 + Math.random()) * 250, -20, params.beanRadius + Math.random() * 8, \n            getBeanProperties(colorPal)\n            );\n\n            Events.on(circle, \"sleepStart\", function () {\n                circle.isStatic = true;\n                circle.label = \"inJar\";\n            });\n\n            return circle;\n        } else {\n            return null;\n        }\n    }\n}\n\nfunction addBeansToWorld(world, generatorFunction, speed) {\n    intervalId = setInterval(() =&gt; {\n        let bean = generatorFunction();\n        if (bean) {\n            Composite.add(world, bean);\n        } else {\n            clearInterval(intervalId);\n            intervalId = null;\n        }\n    }, speed);\n}\n\n\nconst existingBalls = () =&gt; {\n    return engine.world.bodies.filter((body) =&gt; body.label === \"circle\");\n};\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach((ball) =&gt; removeBall(engine, ball, height));\n}, 200);\n\nfunction removeBall(engine, ball, canvasHeight) {\n    let ballHeight = ball.position.y;\n    if (ballHeight &gt; canvasHeight) {\n        console.log(\"gonner\");\n        Composite.remove(engine.world, ball);\n    }\n}\n\nfunction makeJar(params) {\n\n    const thickness = 10;\n    const properties = {\n        isStatic: true,\n        render: {\n            fillStyle: \"#000000\",\n            visible: true\n        },\n        chamfer: { radius: [5, 5, 5, 5]}\n    };\n\n    const leftWall = Bodies.rectangle(width * (1 - params.jarWidth) / 2, (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const rightWall = Bodies.rectangle(width * (1 - (1 - params.jarWidth) / 2), (height) - (height * params.jarHeight/2), thickness, height * params.jarHeight, properties);\n    const bottom = Bodies.rectangle(width * 0.5, height - 5, width * params.jarWidth, thickness, properties);\n\n    return [leftWall, rightWall, bottom];\n}\n\nconst btn = document.getElementById(\"revealBtn\");\n\nfunction countBeansInJar(world) {\n    return world.bodies.filter((body) =&gt; body.label === \"inJar\").length;\n}\n\nbtn.addEventListener(\"click\", function(event) {\n    btn.innerHTML = countBeansInJar(engine.world);\n})\n\nfunction resetRevealButton(button) {\n    button.innerHTML = \"Reveal\";\n}\n\n\nfunction reset() {\n    const newParams = randomizeParams();\n    const newEngine = initializeWorld(\"board\", \"canvas\");\n    const newJar = makeJar(newParams);\n    const newBeans = createBeanGenerator(newParams, x0, colorPal);\n\n    return { newParams, newEngine, newBeans, newJar };\n}\n\nfunction handleReset() {\n    resetRevealButton(btn);\n    // Composite.clear(engine.world);\n    \n    if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n    }\n    \n    const { newParams, newEngine, newBeans, newJar } = reset();\n    params = newParams;\n    engine = newEngine;\n    Composite.add(engine.world, newJar)\n    generateBean = newBeans;\n    addBeansToWorld(engine.world, generateBean, generationSpeed);\n}\n\n}"
  },
  {
    "objectID": "games/triplett/triplett.html",
    "href": "games/triplett/triplett.html",
    "title": "Psych Stats",
    "section": "",
    "text": "practice\n\n\nrace alone\n\n\nrace together\n\n\nAbout\n\n\n\nCompetition Machine ‚Äî\n\n\n\n\n‚îò\n\n\nüèÅ\n\n\nüö©\n\n\n\n\n‚îò\n\n\nüèÅ\n\n\nüö©\n\n\n\n\nYour time: 0.00\n\n\nReset\n\n\n\n\nClick the ‚Äòhandle‚Äô to the left of the ‚Äòtrack‚Äô to start.\n\n\nKeep clicking as fast as you can until your flag reaches the end.\n\n\nClick Race Alone to do a timed race by yourself.\n\n\nClick Race Together to race against a competitor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nüëë Records üëë\n\n\nPrevious\n\n\nBest\n\n\n\n\nüö© Alone\n\n\n-\n\n\n-\n\n\n\n\nüö©üö©Competition\n\n\n-\n\n\n-\n\n\n\n\n\n\ngame = {\n    var start, myTimer, myTurner;\nvar sec = d3.select(\"#seconds\")\nvar cli = d3.select(\"#clicks\")\nvar flag = d3.select(\"#flag\")\nvar flag2 = d3.select(\"#flag2\")\nvar clicks = 0;\nvar state;\nconst target_clicks = 50;\nvar mode = practice;\n\nvar records = [{prev: 0, best: 0},{prev: 0, best: 0}]\n\nvar handleState = 0;\nconst handle = d3.select(\"#handle-text\");\nconst handle2 = d3.select(\"#handle2-text\");\nconst handleText = [\"‚îò\",\"‚îî\"]\n\nd3.select(\"#handle1\").on(\"click\", clicked);\nd3.select(\"#practice-button\").on(\"click\", practice);\nd3.select(\"#alone-button\").on(\"click\", alone);\nd3.select(\"#competition-button\").on(\"click\", competition);\nd3.select(\"#reset-button\").on(\"click\", reset);\n\nfunction handleClicked() {\n    handleState++;\n    handle.text(handleText[handleState % 2]);\n}\n\nfunction turnHandle2() {\n    var handle2State = 0;\n    myTurner = setInterval( function(){\n        handle2State++;\n        handle2.text(handleText[handle2State % 2]);\n        if (handle2State &gt; target_clicks) clearInterval(myTurner);\n    }, 7000 / target_clicks);\n}\n\nfunction clicked() {\n    handleClicked();\n    \n    if (clicks==0) {startTimer(); turnHandle2();}\n    if (clicks &lt; target_clicks) {\n        clicks++;\n    cli.text(clicks);\n    flag.transition().duration(300).style(\"left\", `${clicks*(100/target_clicks)*1.00}%`);\n    } \n    if (clicks == target_clicks) stopTimer();\n}\n\nfunction startTimer() {\n    start = Date.now();\n    myTimer= setInterval( function(){\n        var delta = Date.now() - start; // milliseconds elapsed since start\n        sec.html(delta / 1000);\n    }, 10);\n\n    flag2.transition().ease(d3.easeLinear).duration(7000).style(\"left\", \"100%\")\n}\n\nfunction stopTimer() {\n    clearInterval(myTimer);\n\n    var time = Number(sec.html());\n\n    if(state!=\"practice\") {\n        d3.select(\"#\" + state + \"-previous\").text(time);\n\n        var previousBest = Number(d3.select(\"#\" + state + \"-best\").text());\n        if(isNaN(previousBest)) d3.select(\"#\" + state + \"-best\").text(time);\n        else if (time &lt; previousBest) d3.select(\"#\" + state + \"-best\").text(time);\n    }\n}\n\n// function updateTable(time, cell) {\n//     d3.select(cell).text(time);\n// }\n\nfunction practice() {\n    state = \"practice\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#practice-button\").classed(\"selected\", true);\n    // d3.select(\"#practice\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#time\").style(\"display\", \"none\");\n}\n\nfunction alone() {\n    state = \"alone\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#alone-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"none\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction competition() {\n    state = \"competition\";\n    reset();\n    d3.selectAll(\".nav\").classed(\"selected\", false);\n    d3.select(\"#competition-button\").classed(\"selected\", true);\n    d3.select(\"#time\").style(\"display\", \"block\");\n    d3.select(\"#track2\").style(\"display\", \"block\");\n    d3.select(\"#instructions\").style(\"display\", \"none\");\n}\n\nfunction reset() {\n    clearInterval(myTimer);\n    clearInterval(myTurner);\n    sec.text(\"0.00\");\n    cli.text(0);\n    flag.transition().duration(1000).style(\"left\", \"0%\");\n    flag2.transition().duration(1000).style(\"left\", \"0%\");\n    clicks = 0;\n}\n\npractice();\n}"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualization of fundamental statistical concepts.\nSampling\n(Un)Biased Estimates\nQuincunx"
  },
  {
    "objectID": "index.html#games",
    "href": "index.html#games",
    "title": "PSYCH STATS",
    "section": "Games",
    "text": "Games\nSome ‚Äògames‚Äô (I‚Äôm using the term loosely!) that I use to illustrate statistical concepts or generate data for analysis.\nTriplett\nJellybeans\n\nbannerImage = {\n\n    const svg = d3.select(\".quarto-title\").append(\"svg\")\n        .attr(\"id\", \"title-svg\")\n        .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n        .attr(\"viewBox\", \"0 0 \" + 50 + \" \" + 20)\n\n    svg.selectAll(\"circle\").data(data).enter().append(\"circle\")\n        .attr(\"cx\", d =&gt; d.x)\n        .attr(\"cy\", d =&gt; 20 - d.y)\n        .attr(\"r\", radius / 2)\n        .attr(\"stroke\", \"none\")\n        .attr(\"fill\", (d, i) =&gt; d3.schemeCategory10[i % 10])\n\n}"
  },
  {
    "objectID": "visualizations/quincunx.html",
    "href": "visualizations/quincunx.html",
    "title": "Quincunx",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\nboard = {\n\n\n// https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n\n\nlet width = 700;\nlet height = 600;\nlet x0 = width / 2;\n\n// ball properties\nconst ballRadius = 4;\nlet y_start = 0;\n\nlet generation_speed = 20;\nlet nBalls = 650;\nlet mass = 100;\nlet density = 1;\n\n// peg board properties\nlet rows = 20;\nlet y_peg_start = 20;\nlet pegGap = 6.5 * ballRadius;\nlet pegRadius = 0.5 * ballRadius;\nlet xGap = pegGap;\nlet yGap = 0.6 * xGap;\nlet pegAngle = 0; // Math.PI / 4;\nlet gap_between_pegs_and_buckets = 0;\n\n// funnel properties\nconst funnelTostartGap = yGap;\nconst funnelWallLength = 600;\nconst funnelAngle = Math.PI / 3;\nconst funnelOpening = 5 * ballRadius;\n\n// physics properties\nlet restitution = 0.5; // bounciness\nlet friction = 0.01;\nlet frictionAir = 0.045;\nlet frictionStatic = 0;\n\n\nlet intervalId;\n\n\nvar {Engine, Render, Runner, \n    Composite, Composites, Common, \n    MouseConstraint, Mouse, Events, \n    World, Bodies, Body} = Matter;\n\nlet engine, render, runner, world;\n\n\n\nfunction initialize() {\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n    \n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"board\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: false\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    \n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.addEventListener(\"mousedown\", reset);\n    render.canvas.position = \"absolute\";\n}\n\n\n\n// Create top funnel\nlet leftBumper_x =  x0 - (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet rightBumper_x = x0 + (funnelWallLength * Math.cos(funnelAngle) + funnelOpening) / 2;\nlet bumper_y = y_peg_start - ((funnelWallLength * Math.sin(funnelAngle)) / 2 - funnelTostartGap);\nconsole.log(bumper_y)\n\nlet createFunnel = () =&gt; {\n\n        let leftBumper = Bodies.rectangle(leftBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(leftBumper, funnelAngle);\n\n        let rightBumper = Bodies.rectangle(rightBumper_x, bumper_y, funnelWallLength, 3, {\n            restitution: 0.6,\n            friction: 0,\n            frictionStatic: 0,\n            isStatic: true\n        });\n        Matter.Body.rotate(rightBumper, -funnelAngle);\n\n        Matter.Composite.add(world, [leftBumper, rightBumper]);\n}\n\n\nfunction make_balls() {\n\n    let total = nBalls;\n    clearInterval(intervalId);\n\n    intervalId = setInterval(() =&gt; {\n        let balls = [];\n        if (total-- &gt; 0) {\n            const circle = Bodies.circle(x0 + (-0.5 + Math.random()) * 1, -20, ballRadius, {\n                label: \"circle\",\n                friction: 0.001,\n                restitution,\n                mass,\n                slop: 0.05,\n                density,\n                frictionAir,\n                sleepThreshold: Infinity,\n                render: {\n                    fillStyle: d3.schemeCategory10[total % 10]\n                }\n            });\n            // Matter.Events.on(circle, \"sleepStart\", () =&gt; {\n            //     Matter.Body.setStatic(circle, true);\n            // });\n            \n            Matter.Composite.add(world, circle);\n        }\n    }, generation_speed);\n}\n\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; body.label === \"circle\");\n  };\n\nconst makeStaticInterval = setInterval(() =&gt; {\n    existingBalls().forEach(function(ball) {\n      let ballHeight = ball.position.y;\n      let ballSpeed = ball.speed;\n      let minHeight = 350; // height - (floorHeight + wallHeight);\n      if (ballHeight &gt; minHeight && ballSpeed &lt; 0.02) {\n        // ball.render.opacity = 0.5;\n        Body.setStatic(ball, true);\n      }\n    });\n  }, 200);\n\n\nfunction make_pegs() {\n    const pegs = [];\n    const spacingY = ballRadius*4;\n    const spacingX = ballRadius*4;\n    var i, j, lastI;\n    for (i = 0; i &lt; rows; i++) {\n        for (j = 1; j &lt; i; j++) {\n            pegs.push(\n                // Bodies.rectangle(\n                Bodies.circle(\n                    x0 + (j * xGap - i * (xGap / 2)),\n                    y_peg_start + i * yGap,\n                    pegRadius,\n                    // ballRadius * 1.2,\n                    // 2,\n                    {\n                        angle: pegAngle,\n                        isStatic: true,\n                        friction: 0,\n                        frictionStatic: 0,\n                        render: {\n                            fillStyle: \"black\"\n                        },\n                    chamfer: {\n                        radius: [ballRadius * 0.2, ballRadius * 0.2, 0, 0]\n                    }\n        })\n            );\n        }\n        lastI = i;\n    }\n    // bins\n    for (i = 0; i &lt; rows; i++) {\n        Matter.Composite.add(\n            world,\n            Bodies.rectangle(\n\n                x0 - (rows - 1) * (xGap / 2) + i * xGap,\n                y_peg_start + rows * yGap + gap_between_pegs_and_buckets + (height-(y_peg_start + rows * yGap))/2,\n                4,\n                (height-(y_peg_start + rows * yGap)),\n                {\n                    isStatic: true,\n                    density: 1000,\n                    mass: 1000,\n                    slop: 0,\n                    render: {\n                        fillStyle: \"#000000\",\n                        visible: true\n                    },\n                    chamfer: {\n                        radius: [ballRadius * 0.4, ballRadius * 0.4, 0, 0]\n                    }\n                }\n            )\n        );\n    }\n    // ground\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(400, height, 1000, 10, {\n            isStatic: true,\n            render: {\n                fillStyle: \"#000000\",\n                visible: true\n            }\n        })\n    );\n\n\n    World.add(world, pegs);\n}\n\nconst canvas = d3.select(\"#overlay\")\n.append(\"canvas\")\n.attr(\"id\", \"overlay\")\n.attr(\"position\", \"absolute\")\n.attr(\"width\", width)\n.attr(\"height\", height);\n\nconst ctx = canvas.node().getContext('2d');\ncanvas.on(\"mousedown\", reset);\n\nfunction drawNormalDistribution() {\n\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 3;\n    ctx.beginPath();\n    ctx.moveTo(0, height - 5);\n\n    let yMultiplier = (height-(y_peg_start + rows * yGap));\n    var values = jStat(-4, 4, 210)[0]\n\n\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, 0, 0.8);\n        ctx.lineTo((value + 4)*(width/8), height-(density*1.95*yMultiplier) - 5);\n        ctx.stroke();\n    }\n}\n\nfunction reset() {\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    console.log('reset clicked');\n    \n    initialize();\n    scaleCanvas();\n    make_pegs();\n    make_balls();\n    createFunnel();\n    drawNormalDistribution();\n}\n\n\nfunction scaleCanvas() {\n    \n    var containerWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = containerWidth / (width * 1);\n    d3.select(\"canvas\")\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n    canvas\n        // .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    // d3.select(\"#flex-container\")\n    //     .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    // d3.select(\"#container\")\n    //     .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n//\n\ninitialize();\nscaleCanvas();\nmake_pegs();\nmake_balls();\ncreateFunnel();\ndrawNormalDistribution();\n  \n}"
  },
  {
    "objectID": "visualizations/unbiased-estimates.html",
    "href": "visualizations/unbiased-estimates.html",
    "title": "(Un)Biased estimates",
    "section": "",
    "text": "Show: \\(M\\) \\(SD_{n}\\) \\(SD_{n - 1}\\)\n\n\n\n\n\n\n\n\n\n\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\nw = 800\nh = 400\n\nmaxWidth = 900;\nmaxHeight = 550;\n\ntimeseriesVertical = false;\n\npanelSpacing = 5;\n\npopulationPanelWidth = maxWidth * 0.6;\npopulationPanelHeight = maxHeight;\n\npopulationSubPanelProportion = 0.4;\nsampleSubPanelProportion = 0.05;\n\nestimatesSubPanelProportion = 0.55;\n\nestimatesPanelWidth = maxWidth - populationPanelWidth;\nestimatesPanelHeight = populationPanelHeight;\n\ntimeSeriesPanelWidth = maxWidth - populationPanelWidth;\n\n\n\nradius = 4; //1.4\nsampleSize = 5;\n\n    \nxScalePopulation = d3.scaleLinear()\n    .domain([-4, 4])\n    .range([0 + radius, (populationPanelWidth) - radius])\nyScalePopulation = d3.scaleLinear()\n    .domain([0, 300])\n    .range([populationPanelHeight * populationSubPanelProportion, 0])\n\nxScaleEstimates = d3.scaleLinear()\n    .domain([-1.25, 1.25])\n    .range([0, estimatesPanelWidth])\n    \nyScaleEstimates = d3.scaleLinear()\n    .domain([20, 0])\n    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])\n\nxAxisEstimatesValues = [-2, -1, 0, 1, 2];\nxAxisEstimates = d3.axisBottom(xScalePopulation)\n  .tickValues(xAxisEstimatesValues)\n  .tickFormat(d =&gt; d)\n  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nupdate_svg = {\n\n  var sample = [];\n  var sampleData = [];\n  var sample_estimates = [];\n  var running_averages = [{param: \"population\", value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n  \n  var nSamplesDrawn = 0;\n  \n  var legendSelected = [\"sample\", \"population\"]\n  \n  var timeX, timeY, biasLine, timeXAxis, timeYAxis;\n  var timeSvg, \n  timeScaleBias, \n  timeScaleId, \n  timeBiasAxis, \n  timeIdAxis, \n  timeseriesDataLayer,\n  timeseriesBiasAxisLayer,\n  timeseriesIdAxisLayer;\n\n  let isLargeScreen;\n\n  function newSample() {\n    \n    nSamplesDrawn++\n    \n    // pick random observations from the population by their index\n    for (var i = 0; i &lt; sampleSize; i++) {\n      let randomIndex = Math.floor(Math.random() * popData.length);\n      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);\n      sampleData[i] = popData[randomIndex];\n    }\n    \n    var estimates = getSampleEstimates(sample)\n    estimates.map(d =&gt; d.id = nSamplesDrawn);\n    sample_estimates.push(estimates)\n    \n    updateRunningAverages(estimates);\n    updateBiasChart();\n    updateSampleCircles();\n    animateEstimates(sampleData, estimates);\n    updatePath();\n    updateVisibility();\n  }\n  \n  function updateBiasChart() {\n      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])\n      \n      biasDots.selectAll(\"path\").remove()\n      biasDots.selectAll(\"path\")\n          .data(sample_estimates.flat())\n          .enter()\n          .append(\"path\")\n            .attr(\"id\", d =&gt; d.param + \"-estimate\")\n            .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)\n            .attr(\"opacity\", d =&gt; (d.id === nSamplesDrawn ? 0 : 1))\n            .transition()\n            .attr(\"transform\", d =&gt; `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)\n            \n  }\n  \n\n  \n  function updateSampleCircles() {\n  \n  let durationMultiplier = 5;\n  if (playing) durationMultiplier = 1;\n  \n    sampleCircles.selectAll('circle').remove()\n    sampleCircles.selectAll('circle')\n      .data(sampleData)\n      .enter().append(\"circle\")\n      .attr(\"class\", \"sample\")\n      .attr(\"r\", radius)\n      .attr(\"cx\", d =&gt; d.cx)\n      .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n      .attr(\"fill\", d =&gt; d.fill)\n      .transition()\n      .duration(d =&gt; d.cy * durationMultiplier)\n      .ease(d3.easeBounceOut)\n      .attr(\"cy\", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)\n  }\n  \n  \n  \n  function animateEstimates(sampleData, estimates) {\n  \n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    \n    var wait = Math.max(...sampleData.map(z =&gt; z.cy));\n    \n    for (let i = 0; i &lt; estimates.length; i++) {\n\n    var p = estimates[i].param;\n    var endPosition = estimates[i].value;\n    var dur = (playing ? 0 : 1000);\n    var convergeWait = (playing ? 0 : wait * 5);\n    var moveDownWait = (playing ? 250 : 0);\n    \n    sampleData.forEach((s) =&gt; {\n    \n    // first, place estimate symbols where each sample dot lands\n      sampleEstimatesTemp\n      .append(\"path\")\n      .attr(\"id\", p + \"-estimate\")\n      .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n        .attr(\"transform\", d =&gt; `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        .attr(\"opacity\", 0)\n        \n    // then move them all to the estimate\n        .transition().duration(dur * 0.67).delay(convergeWait)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", d =&gt; `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        \n    // then move them down to the estimates tracker\n    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)\n      .ease(d3.easeCubicOut)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)\n    })\n\n    }\n  }\n  \n  const sleep = (milliseconds) =&gt; {\n    return new Promise(resolve =&gt; setTimeout(resolve, milliseconds))\n  }\n  var playing = false;\n  function playButtonClicked() {\n    \n    playing = !playing; \n  \n  play_button.text(function(){\n    if(playing) {\n      return \"‚óº\"\n  } else {\n    return \"‚ñ∂\"\n  }\n  })\n  \n  if (playing) {\n    continuouslyDrawSamples();\n  }\n  }\n  \n  function continuouslyDrawSamples() {\n    if (playing) {\n      newSample();\n      sleep(200).then(continuouslyDrawSamples);\n    }\n  }\n  \n    \n  var popData = [];\n  const color = d3.scaleOrdinal(d3.schemeCategory10);\n  for (let i = 0; i &lt; population.length; ++i) {\n    const cx = xScalePopulation(population[i]);\n    const cy = 10 + (dodge(cx) - radius - 1);\n    &lt;!-- const cy = yScalePopulation(dodge(cx)); --&gt;\n    const fill = color(i % 10);\n    popData.push({cx, cy, fill})\n  }\n  \n  \n  \n  const populationLabels = [{label: \"Population\", top: 0},\n                            {label: \"Sample\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion) * 100},\n                            {label: \"Under/over-&lt;/br&gt;estimation of&lt;/br&gt;parameter\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion + sampleSubPanelProportion) * 100}]\n  \n  const populationContainer = d3.select(\"#population-container\")\n    .style(\"position\", \"relative\")\n    &lt;!-- .style(\"height\", maxHeight) --&gt;\n    \n    // panel labels\n  populationContainer.selectAll(\"text\").data(populationLabels).enter()\n    .append(\"text\")\n    .style(\"position\", \"absolute\")\n    .html(d =&gt; d.label)\n    .style(\"top\", d =&gt; d.top + \"%\")\n    .style(\"line-height\", \"1em\")\n\n  const populationAndSampleSvg = d3.select(\"#population-container\")\n    .append(\"svg\").attr(\"id\", \"populationAndSample-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + (populationPanelWidth) + \" \" + populationPanelHeight)\n    \n    // panel backgrounds\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight * populationSubPanelProportion)\n    .attr(\"fill\", \"var(--population-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * populationSubPanelProportion)\n    .attr(\"height\", populationPanelHeight * sampleSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--sample-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * (1 - estimatesSubPanelProportion))\n    .attr(\"height\", populationPanelHeight * estimatesSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n    \n\n    \n  const pop = populationAndSampleSvg.append(\"g\")\n  const parameters = populationAndSampleSvg.append(\"g\")\n  const sampleEstimates = populationAndSampleSvg.append(\"g\")\n  const sampleEstimatesTemp = populationAndSampleSvg.append(\"g\")\n  const sampleCircles = populationAndSampleSvg.append(\"g\")\n\n  const biasDots  = sampleEstimates.append(\"g\")\n  \n  pop.selectAll(\"circle\")\n      .data(popData)\n      .enter()\n      .append(\"circle\")\n        .attr(\"class\", \"pop\")\n        .attr(\"cx\", d =&gt; d.cx)\n        .attr(\"cy\", d =&gt; yScalePopulation(d.cy))\n        .attr(\"r\", radius)\n        .attr(\"fill\", d =&gt; d.fill)\n        \n    // estimates axis\n    \n  const estimatesAxis = sampleEstimates.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScaleEstimates(21)})`)\n  \n  estimatesAxis.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight - yScaleEstimates(21))\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n  estimatesAxis.call(xAxisEstimates)\n  estimatesAxis.select(\".domain\").remove()\n  \n\n\n  \n  formatAxes(estimatesAxis.selectAll(\"line\"));\n  \n    \n  var legendStatus = [{param: \"mean\",       hide: true},\n                      {param: \"population\", hide: false},\n                      {param: \"sample\",     hide: false}]\n                      \n  \n  function updateLegendStatus(param) {\n    var index;\n    if (param===\"mean\") {index = 0;}\n    if (param===\"population\") {index = 1;}\n    if (param===\"sample\") {index = 2;}\n    legendStatus[index].hide = !legendStatus[index].hide\n\n    var classes = \"#\" + param + \"-estimate\"\n    \n    populationAndSampleSvg.selectAll(classes).classed(\"hide\", legendStatus[index].hide)\n    timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[index].hide)\n    legend.classed(\"unselected\", d =&gt; d.hide)\n  }\n  \n    const legend = d3.selectAll(\".selector\")\n    legend\n      .data(legendStatus)\n      .classed(\"unselected\", d =&gt; d.hide)\n      .on(\"click\", function(event, d){updateLegendStatus(d.param);})\n  \n\n\n  \n  // buttons\n  const controls = d3.select(\"#controls-container\")\n  \n  const reset_button = controls.append(\"button\")\n    // .attr(\"class\", \"button invertable\")\n    // .attr(\"type\", \"button\")\n    .text(\"Reset\")\n    .on(\"click\", clearData)\n  \n  const button = controls.append(\"button\")\n    .text(\"Take one sample\")\n    .on(\"click\", newSample)\n    \n  const play_button = controls.append(\"button\")\n    .attr(\"id\", \"play-button\")\n    // .attr(\"class\", \"button invertable\")\n    .attr(\"x\", 50)\n    .attr(\"y\", h - 50)\n    .html(\"‚ñ∫\")\n    .on(\"click\", playButtonClicked)\n    \n\n\n// make timeseries chart\nconst timeChart = {\n    width: timeSeriesPanelWidth,\n    height: maxHeight,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\nconst timeChartHorizontal = {\n    width: populationPanelWidth,\n    height: 300,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\n  const timeseriesContainer = d3.select(\"#timeline-container\");\n  timeseriesContainer.style(\"position\", \"relative\")\n\n  updateTimeseriesDimensions(window.innerWidth);\n\n  // Re-render the chart whenever the window size changes\n  window.addEventListener(\"resize\", () =&gt; updateTimeseriesDimensions(window.innerWidth)); \n\n\n\n  function updateTimeseriesDimensions(winWidth) {\n\n    const largeScreen = winWidth &gt; 600;\n    if (largeScreen === isLargeScreen) return;\n    // Update the screen state\n    isLargeScreen = largeScreen;\n    \n  var params;\n  var orientation = (winWidth &gt; 600) ? \"vertical\" : \"horizontal;\"\n\n  console.log(orientation);\n\n  // first, set up chart dimensions and axes\n  if (winWidth &gt; 600) {\n\n    params = timeChart;\n\n    timeScaleBias = d3.scaleLinear()\n      .domain([-0.5, 0.5])\n      .range([params.margin.left, params.width - params.margin.right])\n    timeScaleId = d3.scaleLinear()\n      .domain([0, 200])\n      .range([params.margin.top, params.height - params.margin.bottom])\n    biasLine = function(x, y){\n        return d3.line()\n        .x(function(d,i) { return timeScaleBias(x[i]); })\n        .y(function(d,i) { return timeScaleId(y[i]); })\n        (Array(x.length));\n    }\n    timeBiasAxis = d3.axisTop(timeScaleBias)\n      .ticks(5)\n      .tickSize(-(params.height - params.margin.top - params.margin.bottom)) // 440\n    timeIdAxis = d3.axisRight(timeScaleId).tickSize(0)\n  } else {\n\n      params = timeChartHorizontal;\n\n      timeScaleBias = d3.scaleLinear()\n        .domain([-0.5, 0.5])\n        .range([params.height - params.margin.bottom, params.margin.top])\n        \n      timeScaleId = d3.scaleLinear()\n        .domain([0, 200])\n        .range([params.margin.left, params.width - params.margin.right])\n      biasLine = function(x, y){\n          return d3.line()\n          .x(function(d,i) { return timeScaleId(y[i]); })\n          .y(function(d,i) { return timeScaleBias(x[i]); })\n          (Array(x.length));\n      }\n    timeIdAxis = d3.axisBottom(timeScaleId)\n      .tickSize(0)\n    timeBiasAxis = d3.axisLeft(timeScaleBias)\n      .ticks(5).tickSize(-params.width - params.margin.left - params.margin.right)\n  }\n\n  // then instantiate the chart svg itself\n  d3.select(\"#timeline-container\").select(\"svg\").remove();\n  d3.select(\"#timeline-container\").selectAll(\"text\").remove();\n  timeSvg = makeTimeseriesChart(params);\n  timeseriesDataLayer = timeSvg.append(\"g\");\n  timeseriesBiasAxisLayer = timeSvg.append(\"g\");\n  timeseriesIdAxisLayer = timeSvg.append(\"g\");\n\n  // then place the axes\n  positionTimeAxes(orientation, params);\n\n  // then draw the current data\n  updatePath();\n}\n\n  \n\n  \n  function makeTimeseriesChart(params) {\n    \n    // text labels\n    timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .text(\"Average under/over-estimation\")\n  \n  timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"line-height\", \"1em\")\n    .style(\"bottom\", 0)\n    .style(\"right\", 0)\n    .style(\"text-align\", \"right\")\n    .html(\"Total&lt;br&gt;samples\")\n    \n    const svg = d3.select(\"#timeline-container\")\n    .append(\"svg\").attr(\"id\", \"timeline-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + params.width + \" \" + params.height)\n    \n    // background panel\n  svg.append(\"rect\")\n    .attr(\"width\", params.width)\n    .attr(\"height\", params.height)\n    .attr(\"rx\", 5)\n    .attr(\"fill\", \"var(--timeseries-panel-background)\")\n    \n    return svg;\n    \n  }\n  \n  \n  function positionTimeAxes(orientation, params) {\n    if (orientation === \"vertical\") {\n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(0, ${params.margin.top})`)\n\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"width\", params.width)\n        .attr(\"y\", -params.margin.top)\n        .attr(\"height\", params.margin.top)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n\n        timeseriesIdAxisLayer.attr(\"transform\", `translate(${params.width - params.margin.right}, 0)`)\n  \n    } else {\n      timeseriesIdAxisLayer.attr(\"transform\", `translate(0, ${params.height - params.margin.bottom})`)\n\n      // todo: this isn't positioned correctly\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"x\", -params.margin.left)\n        .attr(\"width\", params.margin.left)\n        .attr(\"height\", params.height)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n      \n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(${params.margin.left}, 0)`)\n        \n      \n    }\n    timeseriesIdAxisLayer.call(timeIdAxis)\n    timeseriesBiasAxisLayer.call(timeBiasAxis);\n    timeseriesBiasAxisLayer.select(\".domain\").remove();\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    formatAxes(timeSvg.selectAll(\"line\"));\n    \n    timeSvg.selectAll(\"line\").classed(\"dark\", true)\n  }\n  \n  \n  function updatePath() {\n      timeseriesDataLayer.selectAll(\"g\").remove()\n      \n      if (nSamplesDrawn &gt; 201) {\n        timeScaleId.domain([nSamplesDrawn - 200, nSamplesDrawn]);\n        // timeIdAxis = d3.axisRight(timeScaleId).tickSize(0);\n        timeseriesIdAxisLayer.call(timeIdAxis);\n        timeseriesIdAxisLayer.select(\".domain\").remove();\n      }\n      \n      timeseriesDataLayer.selectAll(\"g\")\n        .data(running_averages)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"bias-paths\")\n        .append(\"path\")\n          .attr(\"d\", d =&gt; biasLine(d.value.slice(1), d.id.slice(1)))\n          .attr(\"id\", d =&gt; d.param + \"-path\")\n\n  }\n  \n\n\nfunction clearData() {\n    sample = [];\n    sample_estimates = [];\n    running_averages = [{param: \"population\",   value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n    nSamplesDrawn = 0;\n    \n    timeScaleId.domain([0, 200]);\n    timeseriesIdAxisLayer.call(timeIdAxis);\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    sampleCircles.selectAll('circle').remove()\n    sampleEstimates.selectAll(\"path\").remove()\n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    timeseriesDataLayer.selectAll(\"path\").remove()\n  }\n  \n  function updateRunningAverages(estimates) {\n  \n      var cur_n = nSamplesDrawn\n      var prev_n = cur_n - 1\n      \n      var old = running_averages[0].value[prev_n]\n      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n\n      running_averages[0].value.push(new_pop)\n      \n      var old = running_averages[1].value[prev_n]\n      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n\n      running_averages[1].value.push(new_sam)\n      \n      var old = running_averages[2].value[prev_n]\n      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n\n      running_averages[2].value.push(new_mea)\n    \n      running_averages[0].id.push(cur_n)\n      running_averages[1].id.push(cur_n)\n      running_averages[2].id.push(cur_n)\n\n}\n\n  function updateVisibility() {\n  \n    var params = [\"mean\", \"population\", \"sample\"]\n    \n    for (var i = 0; i &lt; 3; i++) {\n      var param = params[i]\n      var elementIds = \"#\" + param + \"-estimate, #\" + param + \"-line\"\n      \n      populationAndSampleSvg.selectAll(elementIds).classed(\"hide\", legendStatus[i].hide)\n      &lt;!-- populationAndSampleSvg.selectAll(\"#\" + param + \"-estimate\").classed(\"hide\", legendStatus[i].hide) --&gt;\n      timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[i].hide)\n    }\n  }\n  \n}\n\n\n\n\n\n\n\ndodger = radius =&gt; {\n  const radius2 = radius ** 1.9;\n  const bisect = d3.bisector(d =&gt; d.x);\n  const circles = [];\n  return x =&gt; {\n    const l = bisect.left(circles, x - radius);\n    const r = bisect.right(circles, x + radius, l);\n    let y = 0;\n    for (let i = l; i &lt; r; ++i) {\n      const { x: xi, y: yi } = circles[i];\n      const x2 = (xi - x) ** 2;\n      const y2 = (yi - y) ** 2;\n      if (radius2 &gt; x2 + y2) {\n        y = yi + Math.sqrt(radius2 - x2) + 1e-6;\n        i = l - 1;\n        continue;\n      }\n    }\n    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });\n    &lt;!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) --&gt;\n    return y;\n  };\n}\n\ndodge = dodger(radius * 2 + 0.75);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mean(array) {\n    return array.reduce((a, b) =&gt; a + b) / array.length;\n}\n\nfunction sample_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / (n - 1);\n}\n\nfunction population_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x =&gt; Math.pow(x - m, 2)).reduce((a, b) =&gt; a + b) / n;\n}\n\nfunction get_descriptives (array) {\n    return {mean: mean(array),\n            sample_variance: sample_variance(array) - 1, \n            population_variance: population_variance(array) - 1}\n}\n\nfunction getNewData (array) {\n    \n    return {sample_estimates: getSampleEstimates(array)\n            &lt;!-- running_averages: getRunningAverages(array) --&gt;\n            }\n}\n\nfunction getSampleEstimates(array) {\n    return [{param: \"population\", value: population_variance(array) - 1},\n            {param: \"sample\",     value: sample_variance(array) - 1},\n            {param: \"mean\",       value: mean(array)}]\n}\n\n\nfunction formatAxes(elements) {\n  elements._groups[0].forEach((l) =&gt; {\n    if (l.__data__ === 0) {\n      l.classList = \"axis-major\";\n    } else {\n      l.classList = \"axis-minor\";\n    }\n  })\n}"
  },
  {
    "objectID": "visualizations/sampling/sampling.html",
    "href": "visualizations/sampling/sampling.html",
    "title": "Sampling",
    "section": "",
    "text": "Distribution:  Normal Positive skew Negative skew Uniform Custom  Sample size:  Reset\n\n\n\n\n\n\nTake a sample\n\n\nStart\n\n\nStop\n\n\n1,000\n\n\n10,000\n\n\n100,000\n\n\nclear\n\n\n\n\n\n\nimport {sampling} from \"./sampling-backend.qmd\""
  },
  {
    "objectID": "index.html#visualizations",
    "href": "index.html#visualizations",
    "title": "PSYCH STATS",
    "section": "",
    "text": "Interactive visualization of fundamental statistical concepts.\nSampling\n(Un)Biased Estimates\nQuincunx"
  },
  {
    "objectID": "visualizations/sampling/sampling-backend.html",
    "href": "visualizations/sampling/sampling-backend.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsampling = {\n    // https://codesandbox.io/s/github/rjoxford/MatterJSGaltonBoard\n// https://www.tylermw.com/plinko-statistics-insights-from-the-bean-machine/\n// https://onlinestatbook.com/stat_sim/sampling_dist/\n\nlet width = 700;\nlet height = 700;\nlet x0 = width / 2;\n\nlet populationHeight = height * 0.4;\nlet sampleHeight = 50;\nlet samplingDistributionHeight = height - (populationHeight + sampleHeight);\n\n// ball properties\nconst ballRadius = 5;\nlet generationSpeed = 1;\nlet nBalls = 500;\n\nlet sampleSize = d3.select(\"#sampleSize\").property(\"value\");\nlet distributionFunction = d3.select(\"#dist\").value\n\nlet balls = [], means = [], currentMean;\n\n\n\nlet showSleeping = false;\n\nvar { Engine, Render, Runner,\n    Composite, Composites, Common,\n    MouseConstraint, Mouse, Events,\n    World, Bodies, Body } = Matter;\n\nlet engine, render, runner, world;\n\nvar pos, mouseX, mouseY;\n\nlet populationMean = x0;\nlet populationSd = width * 0.12;\nlet updatePopulationInterval;\nlet creationIntervalId;\n\nlet y = d3.scaleLinear()\n    .domain([0, jStat.normal.pdf(x0, x0, 80 / Math.sqrt(sampleSize))])\n    .range([samplingDistributionHeight, 0])\n\n\n\n    \n// ========================================================================== //\n// Buttons and listeners\n// ========================================================================== //\n\nd3.select( \"#singleSampleBtn\").on(\"click\", logBalls)\nd3.select(\"#startSamplingBtn\").on(\"click\", takeSamples)\nd3.select( \"#stopSamplingBtn\").on(\"click\", stopSamples)\nd3.select(  \"#samples1000Btn\").on(\"click\", e =&gt; takeNSamples(1000))\nd3.select( \"#samples10000Btn\").on(\"click\", e =&gt; takeNSamples(10000))\nd3.select( \"#samples100000Btn\").on(\"click\", e =&gt; takeNSamples(100000))\nd3.select( \"#clearSamplesBtn\").on(\"click\", resetMeans)\n\nconst sampleSizeInput = d3.select(\"#sampleSize\")\n    .on(\"change\", function () {\n        resetMeans();\n        sampleSize = d3.select(\"#sampleSize\").property(\"value\");\n        updateSamplingDistributionParams();\n        updateSamplingDistributionDescriptives(true);\n        updateSampleDescriptives();\n        drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    });\n\nconst distributionInput = d3.select(\"#dist\")\n    .on(\"change\", function () {\n        reset();\n    });\n\nfunction scaleCanvas() {\n    console.log(document.getElementById(\"quarto-document-content\").offsetWidth)\n    // var availableWidth = window.visualViewport.width;\n    // var availableWidth = d3.select(\"#container\").attr(\"width\")\n\n    var availableWidth = document.getElementById(\"quarto-document-content\").offsetWidth\n\n    var scaleFactor = Math.min(1, availableWidth / (width * 1));\n    d3.select(\"#container\")\n        .style(\"transform\", `scale(${scaleFactor})`)\n        .style(\"width\", `${width * scaleFactor}px`)\n        .style(\"height\", `${height * scaleFactor}px`);\n\n    d3.select(\"#flex-container\")\n        .style(\"width\", `${Math.ceil(width * scaleFactor)}px`)\n\n    d3.select(\"#container\")\n        .style(\"font-size\", `${1/scaleFactor}em`)\n}\n\n// Update the canvas position when the window is resized\nwindow.addEventListener('resize', function () {\n    scaleCanvas();\n});\n\n\n\n// ========================================================================== //\n// Physics\n// ========================================================================== //\n\n// physics properties\nconst populationDotParams = {\n    label: \"circle\",\n    restitution: 0,\n    friction: 0.1,\n    frictionAir: 0.045,\n    frictionStatic: 1,\n    slop: 0,\n    mass: 0.1,\n    density: 100,\n    sleepThreshold: 15,\n    collisionFilter: { group: 1 }\n}\n\nfunction populationDotColor() {\n    return d3.schemeCategory10[Math.floor(Math.random() * 10)]\n}\n\n// let restitution = 0; // bounciness\nlet friction = Infinity;\n// let frictionAir = 0.05;\nlet frictionStatic = Infinity;\n// let slop = 0;\n// let mass = 0.1;\n// let density = 100;\n\n\n\n\nfunction initialize() {\n\n    // create engine\n    engine = Engine.create({\n        enableSleeping: true\n    }),\n        world = engine.world;\n\n    // create renderer\n    render = Render.create({\n        element: document.getElementById(\"container\"),\n        engine: engine,\n        options: {\n            width: width,\n            height: height,\n            background: \"transparent\",\n            wireframes: false,\n            showSleeping: showSleeping\n        }\n    });\n    Render.run(render);\n\n    // engine.gravity.y = 1;\n    // engine.timing.timeScale = 1;\n    engine.positionIterations = 6;\n    engine.velocityIterations = 8;\n\n    // create runner\n    runner = Runner.create();\n    Runner.run(runner, engine);\n    render.canvas.position = \"absolute\";\n\n    drawDots();\n}\n\nfunction drawDots() {\n    var isDrawing = false;\n    function startDrawing(x, y) {\n        isDrawing = true;\n        resetMeans();\n        Composite.add(world, makePopulationDot(x, y, ballRadius));\n        creationIntervalId = setInterval(function () {\n            if (pos.y &gt; (populationHeight - 5)) {\n                stopDrawing;\n                return null;\n            }\n            Composite.add(world, makePopulationDot(pos.x, pos.y, ballRadius));\n        }, generationSpeed);\n        updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n    }\n    function stopDrawing() {\n        isDrawing = false;\n        clearInterval(creationIntervalId);\n    }\n\n    // Add an event listener to the canvas to detect mouse clicks\n    render.canvas.addEventListener('mousedown', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    render.canvas.addEventListener('touchstart', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n        if (pos.y &lt; (populationHeight - 5)) startDrawing(pos.x, pos.y);\n    });\n    // Update the mouse position if it's moved\n    render.canvas.addEventListener('mousemove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n    render.canvas.addEventListener('touchmove', function (event) {\n        pos = getRelativeMousePosition(event, render.canvas);\n    });\n\n\n    // Stop generating balls when the mouse button is released\n    render.canvas.addEventListener('mouseup', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('mouseout', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n    render.canvas.addEventListener('touchend', function (event) {\n        if (isDrawing) {\n            stopDrawing();\n        }\n    });\n}\n\nconst getRelativeMousePosition = (event, target) =&gt; {\n    const bounds = target.getBoundingClientRect();\n    const scaleX = target.width / bounds.width;\n    const scaleY = target.height / bounds.height;\n    const clientX = event.clientX || event.touches[0].clientX;\n    const clientY = event.clientY || event.touches[0].clientY;\n    return {\n        x: (clientX - bounds.left) * scaleX,\n        y: (clientY - bounds.top) * scaleY,\n    };\n};\n\n// ========================================================================== //\n//      Make the world\nvar panelRadius = [10, 10, 10, 10];\nfunction makeGround() {\n    // background of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight * 0.5, width, populationHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"dodgerblue\", opacity: 0.3 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of population\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + 4, width * 2, 10, {\n            isStatic: true,\n            density: Infinity,\n            collisionFilter: { group: 1, category: 1, mask: 0 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight * 0.5, width, sampleHeight - 10, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d3d8a9\" },\n            chamfer: { radius: panelRadius }\n        })\n    );\n    // floor of sample\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, populationHeight + sampleHeight, width, 10, {\n            friction, frictionStatic,\n            density: Infinity, mass: Infinity,\n            isStatic: true,\n            collisionFilter: { group: 2, category: 4, mask: 2 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n\n    // background of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height - samplingDistributionHeight * 0.5, width, samplingDistributionHeight, {\n            isStatic: true,\n            isSensor: true,\n            render: { fillStyle: \"#d49fd4\", opacity: 0.7 },\n            chamfer: { radius: panelRadius }\n        })\n    );\n\n    // floor of sampling distribution\n    Matter.Composite.add(\n        world,\n        Bodies.rectangle(x0, height + 9, width, 20, {\n            friction, frictionStatic,\n            isStatic: true,\n            collisionFilter: { group: 3, category: 8, mask: 6 },\n            render: {\n                fillStyle: \"#000000\",\n                visible: false\n            }\n        })\n    );\n}\n\n\n\n// ========================================================================== //\n//      Generate population\n\nlet intervalId;\n\nfunction makePopulation(distributionFunction) {\n\n    clearInterval(intervalId);\n    let total = nBalls;\n\n    if (distributionFunction == \"custom\") { total = 0 };\n\n    intervalId = setInterval(() =&gt; {\n\n        if (total-- &gt; 0) {\n\n            let x = distributionFunction();\n            let y = -500 + Math.random() * 500;\n\n            let circle = makePopulationDot(x, y, ballRadius);\n            Matter.Composite.add(world, circle);\n\n        }\n    }, generationSpeed);\n}\n\n\nfunction makePopulationDot(x, y, radius) {\n    \n    let dot = Matter.Bodies.circle(x, y, radius, populationDotParams);\n    dot.render.fillStyle = populationDotColor();\n    \n    Events.on(dot, \"sleepStart\", function () {\n        dot.isStatic = true;\n        balls.push(dot);\n        updateDescriptives();\n    });\n\n    return dot;\n}\n\n\n// ========================================================================== //\n//      Update population\nlet existingBalls = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"circle\" && !body.isStatic));\n};\n\nlet populationInterval;\n\nfunction checkStatic(body) {\n    return body.isStatic;\n}\n\nlet popChecks = 0;\nfunction updatePopulation() {\n    console.log(\"checking pop\");\n    popChecks++;\n    let allBalls = world.bodies.filter((body) =&gt; (body.label === \"circle\"));\n\n    // compute the population mean\n    let total = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        total += allBalls[i].position.x;\n    }\n    populationMean = total / allBalls.length;\n\n    let ss = 0;\n    for (let i = 0; i &lt; allBalls.length; i++) {\n        ss += Math.pow(allBalls[i].position.x - populationMean, 2);\n    }\n    populationSd = Math.sqrt(ss / allBalls.length);\n    // console.log(populationSd);\n    drawNormalDistribution(populationMean, populationSd / Math.sqrt(sampleSize));\n    updateSamplingDistributionParams();\n    if (allBalls.every(checkStatic) || popChecks &gt; 1000) {\n        popChecks = 0;\n        clearInterval(updatePopulationInterval);\n    }\n}\n\nlet existingMeans = () =&gt; {\n    return world.bodies.filter((body) =&gt; (body.label === \"mean\"));\n};\n\nconst makeStaticMeanInterval = setInterval(() =&gt; {\n    existingMeans().forEach(function (mean) {\n        let meanHeight = mean.position.y;\n        let meanSpeed = mean.speed;\n        // let minHeight = 10; // height - (floorHeight + wallHeight);\n        let minHeight = populationHeight + sampleHeight + 50;\n        if (meanHeight &gt; minHeight && meanSpeed &lt; 0.5) {\n            // mean.render.fillStyle = \"black\";\n            mean.isStatic = true;\n            // mean.density = Infinity;\n            //balls.push({ position: ball.position, fill: ball.render.fillStyle });\n            //Body.setStatic(mean, true);\n        }\n    });\n}, 10);\n\n\n// ========================================================================== //\n// Sampling\nfunction logBalls() {\n    let s = sample(sampleSize);\n    // console.log(balls);\n    // console.log(s);\n\n    d3.select(\"#mean\").html(currentMean);\n}\n\n\n// ========================================================================== //\n//      Single sample\n\nfunction sample(sampleSize, fast = false) {\n    let arr = [];\n    let sampleCircles = [];\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"sample\")));\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"meanGhost\")));\n\n    for (let i = 0; i &lt; sampleSize; i++) {\n        let index = Math.floor(Math.random() * balls.length);\n        let pos = balls[index].position;\n        arr.push(pos.x);\n\n        let yPos = pos.y;\n\n        if (fast) yPos = populationHeight + sampleHeight - ballRadius;\n\n\n        sampleCircles.push(Bodies.circle(pos.x, yPos, ballRadius, {\n            label: \"sample\",\n            restitution: 0.4, friction, frictionStatic,\n            density: 1, mass: 1, slop: 0.05,\n            sleepThreshold: Infinity,\n            collisionFilter: { group: -1, category: 2, mask: 4 },\n            render: { fillStyle: balls[index].render.fillStyle }\n        }));\n    };\n\n    currentMean = mean(arr);\n    means.push(currentMean);\n\n\n    let binnedMean = Math.round(currentMean / (ballRadius * 2)) * (ballRadius * 2);\n\n    const meanSquareBack = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2, ballRadius * 2, ballRadius * 2, {\n        label: \"meanGhost\",\n        isStatic: true,\n        isSensor: true,\n        render: { fillStyle: \"white\" }\n    });\n    Composite.add(world, meanSquareBack);\n\n    const meanSquare = Bodies.rectangle(binnedMean, populationHeight + sampleHeight - ballRadius * 2 - 1, ballRadius * 2, ballRadius * 2, {\n        label: \"mean\",\n        restitution: 0,\n        friction,\n        frictionStatic,\n        frictionAir: 0.03,\n        density: Infinity,\n        mass: 0.000000000000001,\n        slop: 0,\n        collisionFilter: { group: 4, category: 6, mask: 8 },\n        render: { fillStyle: \"#d3d8a9\", strokeStyle: \"black\", lineWidth: 1 }\n    });\n    Composite.add(world, meanSquare);\n\n    Composite.add(world, sampleCircles);\n\n    updateSampleDescriptives(sampleSize, f(currentMean), f(sd(arr, false)), false);\n    updateSamplingDistributionDescriptives();\n}\n\nlet sampleInterval;\n\nfunction takeSamples() {\n    sampleInterval = setInterval(() =&gt; {\n        sample(sampleSize, true);\n    }, 100);\n}\n\n\nfunction stopSamples() {\n    clearInterval(sampleInterval);\n}\n\n\n// ========================================================================== //\n//      Multiple samples\nlet meanCounts = {};\nfunction takeNSamples(nSamples) {\n\n\n    for (let i = 0; i &lt; nSamples; i++) {\n\n        let thisSample = [];\n\n        for (let j = 0; j &lt; sampleSize; j++) {\n            let index = Math.floor(Math.random() * balls.length);\n            thisSample.push(balls[index].position.x);\n        }\n\n        let thisSampleMean = mean(thisSample);\n        means.push(thisSampleMean);\n\n        let thisSampleMeanBinned = bin(thisSampleMean, ballRadius);\n\n        if (meanCounts.hasOwnProperty(thisSampleMeanBinned)) {\n            meanCounts[thisSampleMeanBinned]++;\n        } else {\n            meanCounts[thisSampleMeanBinned] = 1;\n        }\n    }\n\n    updateSamplingDistributionDescriptives();\n    let meanProportions = transformCountsToProportions(meanCounts, means.length);\n    drawProportions(meanProportions);\n}\n\n\n// ========================================================================== //\n//      Reset\nfunction reset() {\n\n    balls = [];\n    means = [];\n\n    clearInterval(updatePopulationInterval);\n    clearInterval(intervalId);\n    histogram.selectAll(\"rect\").remove();\n    curve.selectAll(\"path\").remove();\n\n    Composite.clear(world);\n    Engine.clear(engine);\n    Render.stop(render);\n    Runner.stop(runner);\n    render.canvas.remove();\n    render.canvas = null;\n    render.context = null;\n    render.textures = {};\n    // console.log('reset clicked');\n\n    initialize();\n    makeGround();\n    makePopulation(eval(d3.select(\"#dist\").node().value));\n    updatePopulationInterval = setInterval(updatePopulation, 1000 / 60);\n\n    updateSampleDescriptives(0, 0, 0, true);\n    updateSamplingDistributionDescriptives(true);\n}\n\n\nfunction resetMeans() {\n    means = [];\n    meanCounts = {};\n    histogram.selectAll(\"rect\").remove();\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\" || body.label === \"sample\" || body.label === \"meanGhost\")));\n    d3.select(\"#samplingDistStats\").classed(\"hide\", true);\n    d3.select(\"#sampleStats\").classed(\"hide\", true);\n}\n\n\n\n\n// ========================================================================== //\n// Overlay and panel labels\n// ========================================================================== //\n\n// ==================\n//      Labels\nvar labels = [{ label: \"Population\", top: 0 },\n{ label: \"Sample\", top: populationHeight + 5 },\n{ label: \"Distribution of sample means\", top: populationHeight + sampleHeight }];\n\nd3.select(\"#container\").selectAll(\"span\")\n    .data(labels).enter().append(\"span\")\n    .classed(\"panel-label\", true)\n    .classed(\"labels\", true)\n    .style(\"position\", \"absolute\").style(\"left\", \"0.1em\")\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .text(d =&gt; d.label)\n\nvar labels2 = [{\n    label: `&lt;i&gt;N&lt;/i&gt; = &lt;span id=\"n\"&gt;0&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;Œº&lt;/i&gt; = &lt;span id=\"mu\"&gt;&lt;/span&gt;&lt;br&gt;\n                         &lt;i&gt;œÉ&lt;/i&gt; = &lt;span id=\"sigma\"&gt;&lt;/span&gt;`,\n    top: 0\n},\n{\n    label: `&lt;div id=\"sampleStats\"&gt;&lt;i&gt;n&lt;/i&gt; = &lt;span id=\"sampleN\"&gt;&lt;/span&gt;;\n              &lt;i&gt;M&lt;/i&gt; = &lt;span id=\"sampleM\"&gt;&lt;/span&gt;;\n              &lt;i&gt;SD&lt;/i&gt; = &lt;span id=\"sampleSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + 5\n},\n{\n    label: `&lt;div id=\"samplingDistParams\"&gt;Predicted:&lt;br&gt;\n              &lt;i&gt;Œº&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;Œº&lt;/i&gt; = &lt;span id=\"muM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;œÉ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;i&gt;œÉ&lt;/i&gt;/‚àö&lt;i&gt;n&lt;/i&gt;  = &lt;span id=\"sigmaM\"&gt;&lt;/span&gt;&lt;/div&gt;\n              &lt;div id=\"samplingDistStats\"&gt;Observed:&lt;br&gt;&lt;i&gt;N&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distN\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;Œº&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distM\"&gt;&lt;/span&gt;&lt;br&gt;\n              &lt;i&gt;œÉ&lt;sub&gt;m&lt;/sub&gt;&lt;/i&gt; = &lt;span id=\"distSd\"&gt;&lt;/span&gt;&lt;/div&gt;`, top: populationHeight + sampleHeight\n}];\n\nconst overlay2 = d3.select(\"#container\").append(\"div\")\n    .style(\"position\", \"absolute\")\n    .style(\"z-index\", 13)\n    .style(\"text-align\", \"right\")\n\noverlay2.selectAll(\"span\")\n    .data(labels2).enter().append(\"span\")\n    .style(\"width\", width - 5 + \"px\")\n    .style(\"z-index\", 0)\n    // .style(\"margin-right\", \"1em\")\n    .classed(\"panel-label\", true)\n    .classed(\"numbers\", true)\n    .style(\"top\", d =&gt; d.top + \"px\")\n    .html(d =&gt; d.label)\n\nconst f = d3.format(\".1f\");\nconst fComma = d3.format(\",\");\n\nfunction updateDescriptives() {\n    d3.select(\"#n\").text(fComma(balls.length))\n    d3.select(\"#mu\").text(f(populationMean))\n    d3.select(\"#sigma\").text(f(populationSd))\n}\n\nfunction updateSampleDescriptives(n, m, sd, hidden = true) {\n    d3.select(\"#sampleStats\").classed(\"hide\", hidden)\n    d3.select(\"#sampleN\").text(n)\n    d3.select(\"#sampleM\").text(f(m))\n    d3.select(\"#sampleSd\").text(f(sd));\n}\nfunction updateSamplingDistributionParams() {\n    d3.select(\"#muM\").text(f(populationMean))\n    d3.select(\"#sigmaM\").text(f(populationSd / Math.sqrt(sampleSize)));\n}\n\nfunction updateSamplingDistributionDescriptives(hidden = false) {\n    d3.select(\"#samplingDistStats\").classed(\"hide\", hidden)\n    d3.select(\"#distN\").text(fComma(means.length));\n    d3.select(\"#distM\").text(f(mean(means)));\n    d3.select(\"#distSd\").text(f(sd(means)));\n}\n\n\n\n// ========================================================================== //\n//      Normal distribution\n\n// create svg overlay\nconst svg = d3.select(\"#container\")\n    .append(\"svg\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .style(\"transform\", `translateY(${height - samplingDistributionHeight}px)`)\n    // .append(\"div\")\n    .style(\"z-index\", 0)\n    .attr(\"id\", \"samplingDistCanvas\")\n    // .style(\"left\", 0)\n    .attr(\"height\", samplingDistributionHeight)\n    .attr(\"width\", width);\n\nconst histogram = svg.append(\"g\");\nconst curve = svg.append(\"g\");\n\n\nfunction drawNormalDistribution(mean, sd) {\n\n    // remove the old path\n    curve.selectAll(\"path\").remove();\n\n    // reset the y-axis according to new population parameters\n    y.domain([0, 1.1 * jStat.normal.pdf(populationMean, populationMean, populationSd / Math.sqrt(sampleSize))]);\n\n    var values = jStat(0, width, 210)[0];\n\n    let data = [];\n    for (var i in values) {\n        let value = values[i];\n        let density = jStat.normal.pdf(value, mean, sd);\n        data.push({ value: value, density: density });\n    }\n\n    const line = d3.line()\n        .x(d =&gt; d.value)\n        .y(d =&gt; y(d.density));\n\n    // draw the new path\n    curve.append(\"path\")\n        .attr(\"d\", line(data))\n        .attr(\"stroke\", \"grey\")\n        .attr(\"stroke-dasharray\", [5, 5])\n        .attr(\"stroke-width\", 2)\n        .attr(\"fill\", \"none\");\n}\n\n// ========================================================================== //\n//      Histogram\nfunction drawProportions(proportions) {\n\n    Composite.remove(world, world.bodies.filter((body) =&gt; (body.label === \"mean\")));\n    histogram.selectAll(\"rect\").remove();\n\n    Object.entries(proportions).forEach(([key, value]) =&gt; {\n        histogram.append(\"rect\")\n            .attr(\"fill\", \"#d3d8a9\")\n            .attr(\"stroke\", \"black\")\n            .attr(\"stroke-width\", 0.5)\n            .attr(\"x\", key - ballRadius * 0.5)\n            // .attr(\"y\", 0)\n            .attr(\"y\", y(value * 0.2))\n            .attr(\"width\", 5)\n            // .attr(\"height\", samplingDistributionHeight * 2)\n            .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n        // .transition().duration(value * 15000)\n        //     .attr(\"y\", y(value * 0.2))\n        //     .attr(\"height\", samplingDistributionHeight - y(value * 0.2))\n    });\n}\n\n\n\n\n// ========================================================================== //\n// Helper functions\n// ========================================================================== //\n\n\n// ========================================================================== //\n//      Distribution functions\n\n// functions to make skewed distribution\n// see https://spin.atomicobject.com/2019/09/30/skew-normal-prng-javascript/\nconst randomNormals = (rng) =&gt; {\n    let u1 = 0, u2 = 0;\n    //Convert [0,1) to (0,1)\n    while (u1 === 0) u1 = rng();\n    while (u2 === 0) u2 = rng();\n    const R = Math.sqrt(-2.0 * Math.log(u1));\n    const Œò = 2.0 * Math.PI * u2;\n    return [R * Math.cos(Œò), R * Math.sin(Œò)];\n};\n\n\nconst randomSkewNormal = (rng, Œæ = 0, œâ = 1, Œ± = 0) =&gt; {\n    const [u0, v] = randomNormals(rng);\n    if (Œ± === 0) {\n        return Œæ + œâ * u0;\n    }\n    const ùõø = Œ± / Math.sqrt(1 + Œ± * Œ±);\n    const u1 = ùõø * u0 + Math.sqrt(1 - ùõø * ùõø) * v;\n    const z = u0 &gt;= 0 ? u1 : -u1;\n    return Œæ + œâ * z;\n};\n\n// functions to generate single observations from those distributions\nfunction normal() {\n    return randomSkewNormal(Math.random, x0, width * 0.12, 0);\n}\nfunction negative() {\n    return randomSkewNormal(Math.random, width * 0.9, width * 0.25, -10);\n}\nfunction positive() {\n    return randomSkewNormal(Math.random, width * 0.1, width * 0.25, 10);\n}\nfunction uniform() {\n    return ((width * 0.05) + width * 0.9 * Math.random());\n}\n\n// ============================================================\n//      Other low-level helper functions\n\nfunction sleep(milliseconds) {\n    const date = Date.now();\n    let currentDate = null;\n    do {\n        currentDate = Date.now();\n    } while (currentDate - date &lt; milliseconds);\n}\n\n\nfunction bin(x, binWidth) {\n    return Math.round(x / binWidth) * binWidth;\n}\n\n\nArray.prototype.max = function () {\n    return Math.max.apply(null, this);\n};\n\n\nfunction transformCountsToProportions(counts, totalCount) {\n    // let totalCount = Object.values(counts).reduce((a, b) =&gt; a + b, 0);\n    let proportions = {};\n\n    for (let mean in counts) {\n        if (counts.hasOwnProperty(mean)) {\n            proportions[mean] = counts[mean] / totalCount;\n        }\n    }\n\n    return proportions;\n}\n\nfunction mean(arr) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    return total / n;\n}\n\nfunction sd(arr, population = true) {\n    let total = 0;\n    let n = arr.length;\n    for (let i = 0; i &lt; n; i++) {\n        total += arr[i];\n    }\n    let mean = total / n;\n\n    let ss = 0;\n\n    for (let i = 0; i &lt; arr.length; i++) {\n        ss += Math.pow(arr[i] - mean, 2);\n    }\n\n    let denominator = arr.length;\n\n    if (!population) { denominator--; }\n\n    return Math.sqrt(ss / denominator);\n}\n\n\nscaleCanvas();\ninitialize();\nreset();\n}"
  },
  {
    "objectID": "games/jellybeans2.html",
    "href": "games/jellybeans2.html",
    "title": "Psych Stats",
    "section": "",
    "text": "Matter = require(\"https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js\")\n\n\n\njar = {\nconst renderVertices = body =&gt; {\n  ctx.beginPath();\n  body.vertices.forEach(({x, y}) =&gt; ctx.lineTo(x, y));\n  ctx.closePath();\n  ctx.fill();\n  ctx.stroke();\n};\n\n\nconst container = d3.select(\"#container\");\n\nconst canvas = document.querySelector(\"canvas\");\nconst ctx = canvas.getContext(\"2d\");\nconst gradient = ctx.createLinearGradient(\n  0, 0, canvas.width, canvas.height\n);\ngradient.addColorStop(0, \"red\");\ngradient.addColorStop(1, \"blue\");\nctx.fillStyle = gradient;\nctx.strokeStyle = \"var(--bs-body-color)\";\nctx.lineWidth = 2;\n\nconst engine = Matter.Engine.create();  \nconst box = Matter.Bodies.circle(300, 0, 10, 10);\nconst ground = Matter.Bodies.rectangle(\n  200, 200, 400, 120, {isStatic: true}\n);\nconst mouseConstraint = Matter.MouseConstraint.create(\n  engine, {element: canvas}\n);\nMatter.Composite.add(\n  engine.world, [box, ground, mouseConstraint]\n);\n\n(function rerender() {\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  renderVertices(box);\n  renderVertices(ground);\n  Matter.Engine.update(engine);\n  requestAnimationFrame(rerender);\n})();\n\n}"
  }
]