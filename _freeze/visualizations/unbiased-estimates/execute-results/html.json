{
  "hash": "0cdc874e75726d6a39be93e88fe59cc1",
  "result": {
    "markdown": "---\ntitle: \"(Un)Biased estimates\"\npage-layout: full\n---\n\n\n\n::: {#controls}\n\n::: {#controls-container}\n:::\n\n::: {#select-estimate}\nShow: [$M$]{.select-mean .selector .unselected} [$SD_{n}$]{.select-population .selector} [$SD_{n - 1}$]{.select-sample .selector}\n:::\n\n:::\n\n:::: {#viz style=\"margin-bottom: 1em; overflow: hidden;\"}\n\n::: {#population-container}\n:::\n\n::: {#timeline-container}\n:::\n\n::::\n\n:::: {.about}\n## About\n\nTo say a statistic is *unbiased* is to say that, *on average*, its value is equal to the parameter it is estimating. Sampling error, the inherent randomness which determines which observations appear in the sample, ensures that each individual sample will produce a different estimate; any given sample's statistic won't be exactly equal to the parameter. But if many samples are taken, the average of all those statistics will converge on the true population parameter's value.\n\nThe arithmetic average is an unbiased statistic. Each sample's mean will be different, some above the true population mean and some below. Because the discrepancy is random, however, with many samples the overestimates and underestimates balance out. The average of all the differences between each sample average and the true population average will be close to zero. That's what makes the mean unbiased.\n\nStandard deviation is more complicated. There are two different equations for standard deviation. In both cases, you first calculate the mean, then the sum of squared deviations from the mean. If the data represents a complete population, you then divide the sum of squared deviations by *N*, the total number of observations in the entire population. With data from a sample, however, you divide by *n - 1*, the number of scores in the sample minus 1. This is because if you use the first approach with data from a sample, dividing by *N*, the statistic will be *biased*.\n\nMore specifically, using the population standard deviation equation with sample data has the effect of systematically *underestimating* the population parameter. As with the mean, each sample produces a slightly different estimate, but unlike the mean, the difference between estimate and parameter is not completely random. More samples will underestimate the population variability than overestimate it. As a result, the average of all sample estimates of standard deviation would be lower than the true population value.\n\nDividing by *n - 1* when calculating a sample's standard deviation corrects for that bias, producing an unbiased estimate. Why? It has to do with the fact that the standard deviation is a measure of variability, a measure of how spread out the data is. When you estimate the population standard deviation from a sample, you're trying to use a small subset of the population to estimate the variability in the entire population.\n\nBut, there's an inherent problem here. When we calculate the standard deviation of a sample, we're using the sample mean, not the population mean, because the population mean is usually unknown. The sample mean, being calculated from the data in the sample, is more likely to be closer to the individual data points in the sample than the population mean would be. This means the squared deviations from the sample mean are likely to be smaller, on average, than the squared deviations from the population mean. This is what leads to the underestimate of the variance, and hence the standard deviation, when we divide by *N*' instead of *n - 1*.\n\nNow, why *n - 1* instead of, say, *n - 2* or *n - 3*? This has to do with something in statistics known as 'degrees of freedom'. Degrees of freedom are, in a way, the number of values that are free to vary given the constraints in the problem.\n\nIn the case of variance and standard deviation, the constraint is the sample mean. Once we've calculated the sample mean, the sum of the deviations from the mean must equal zero. This means that once we know the deviations of *n - 1* values, the deviation of the nth value is completely determined. So, we say we have *n - 1* degrees of freedom.\n\nWhen you divide by *n - 1* instead of 'n', you are effectively adjusting the sample variance and sample standard deviation upwards to account for the fact that you've underestimated the squared deviations because you used the sample mean instead of the population mean. This adjustment gives a larger value for the sample variance and sample standard deviation, which on average gives a better (i.e., unbiased) estimate of the population variance and population standard deviation.\n\nThis visualization can demonstrate this effect: if you take many samples and calculate the sample standard deviation using *n* and *n - 1* in the denominator, you'll see that the average of the sample standard deviations calculated with *n - 1* in the denominator will be closer to the true population standard deviation, while those calculated with 'n' in the denominator will tend to underestimate it. This shows how the *n - 1* adjustment corrects for the bias in estimating the population standard deviation from a sample.\n::::\n\n\n\n```{ojs}\njStat = require(\"https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js\")\n```\n\n::: {.cell}\n\n:::\n\n```{ojs}\nw = 800\nh = 400\n\nmaxWidth = 900;\nmaxHeight = 550;\n\ntimeseriesVertical = false;\n\npanelSpacing = 5;\n\npopulationPanelWidth = maxWidth * 0.6;\npopulationPanelHeight = maxHeight;\n\npopulationSubPanelProportion = 0.4;\nsampleSubPanelProportion = 0.05;\n\nestimatesSubPanelProportion = 0.55;\n\nestimatesPanelWidth = maxWidth - populationPanelWidth;\nestimatesPanelHeight = populationPanelHeight;\n\ntimeSeriesPanelWidth = maxWidth - populationPanelWidth;\n\n\n\nradius = 4; //1.4\nsampleSize = 5;\n\n    \nxScalePopulation = d3.scaleLinear()\n    .domain([-4, 4])\n    .range([0 + radius, (populationPanelWidth) - radius])\nyScalePopulation = d3.scaleLinear()\n    .domain([0, 300])\n    .range([populationPanelHeight * populationSubPanelProportion, 0])\n\nxScaleEstimates = d3.scaleLinear()\n    .domain([-1.25, 1.25])\n    .range([0, estimatesPanelWidth])\n    \nyScaleEstimates = d3.scaleLinear()\n    .domain([20, 0])\n    .range([maxHeight - 30, maxHeight * (1 - estimatesSubPanelProportion) + 30])\n\nxAxisEstimatesValues = [-2, -1, 0, 1, 2];\nxAxisEstimates = d3.axisBottom(xScalePopulation)\n  .tickValues(xAxisEstimatesValues)\n  .tickFormat(d => d)\n  .tickSize(-maxHeight * (1 - estimatesSubPanelProportion) - 10)\n  \n```\n\n```{ojs}\nupdate_svg = {\n\n  var sample = [];\n  var sampleData = [];\n  var sample_estimates = [];\n  var running_averages = [{param: \"population\", value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n  \n  var nSamplesDrawn = 0;\n  \n  var legendSelected = [\"sample\", \"population\"]\n  \n  var timeX, timeY, biasLine, timeXAxis, timeYAxis;\n  var timeSvg, \n  timeScaleBias, \n  timeScaleId, \n  timeBiasAxis, \n  timeIdAxis, \n  timeseriesDataLayer,\n  timeseriesBiasAxisLayer,\n  timeseriesIdAxisLayer;\n\n  let isLargeScreen;\n\n  function newSample() {\n    \n    nSamplesDrawn++\n    \n    // pick random observations from the population by their index\n    for (var i = 0; i < sampleSize; i++) {\n      let randomIndex = Math.floor(Math.random() * popData.length);\n      sample[i] = xScalePopulation.invert(popData[randomIndex].cx);\n      sampleData[i] = popData[randomIndex];\n    }\n    \n    var estimates = getSampleEstimates(sample)\n    estimates.map(d => d.id = nSamplesDrawn);\n    sample_estimates.push(estimates)\n    \n    updateRunningAverages(estimates);\n    updateBiasChart();\n    updateSampleCircles();\n    animateEstimates(sampleData, estimates);\n    updatePath();\n    updateVisibility();\n  }\n  \n  function updateBiasChart() {\n      yScaleEstimates.domain([nSamplesDrawn-20, nSamplesDrawn])\n      \n      biasDots.selectAll(\"path\").remove()\n      biasDots.selectAll(\"path\")\n          .data(sample_estimates.flat())\n          .enter()\n          .append(\"path\")\n            .attr(\"id\", d => d.param + \"-estimate\")\n            .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n            .attr(\"transform\", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id + 1)}) rotate(45)`)\n            .attr(\"opacity\", d => (d.id === nSamplesDrawn ? 0 : 1))\n            .transition()\n            .attr(\"transform\", d => `translate(${xScalePopulation(d.value)}, ${yScaleEstimates(d.id)}) rotate(45)`)\n            \n  }\n  \n\n  \n  function updateSampleCircles() {\n  \n  let durationMultiplier = 5;\n  if (playing) durationMultiplier = 1;\n  \n    sampleCircles.selectAll('circle').remove()\n    sampleCircles.selectAll('circle')\n      .data(sampleData)\n      .enter().append(\"circle\")\n      .attr(\"class\", \"sample\")\n      .attr(\"r\", radius)\n      .attr(\"cx\", d => d.cx)\n      .attr(\"cy\", d => yScalePopulation(d.cy))\n      .attr(\"fill\", d => d.fill)\n      .transition()\n      .duration(d => d.cy * durationMultiplier)\n      .ease(d3.easeBounceOut)\n      .attr(\"cy\", populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius)\n  }\n  \n  \n  \n  function animateEstimates(sampleData, estimates) {\n  \n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    \n    var wait = Math.max(...sampleData.map(z => z.cy));\n    \n    for (let i = 0; i < estimates.length; i++) {\n\n    var p = estimates[i].param;\n    var endPosition = estimates[i].value;\n    var dur = (playing ? 0 : 1000);\n    var convergeWait = (playing ? 0 : wait * 5);\n    var moveDownWait = (playing ? 250 : 0);\n    \n    sampleData.forEach((s) => {\n    \n    // first, place estimate symbols where each sample dot lands\n      sampleEstimatesTemp\n      .append(\"path\")\n      .attr(\"id\", p + \"-estimate\")\n      .attr(\"d\", d3.symbol().type(d3.symbolSquare).size(radius * radius * 2))\n        .attr(\"transform\", d => `translate(${s.cx}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        .attr(\"opacity\", 0)\n        \n    // then move them all to the estimate\n        .transition().duration(dur * 0.67).delay(convergeWait)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", d => `translate(${xScalePopulation(endPosition)}, ${populationPanelHeight * (populationSubPanelProportion + sampleSubPanelProportion) - radius}) rotate(45)`)\n        \n    // then move them down to the estimates tracker\n    .transition().duration((playing ? 250 : (dur * 0.33))).delay(0)\n      .ease(d3.easeCubicOut)\n        .attr(\"opacity\", 1)\n        .attr(\"transform\", `translate(${xScalePopulation(endPosition)}, ${yScaleEstimates(nSamplesDrawn)}) rotate(45)`)\n    })\n\n    }\n  }\n  \n  const sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }\n  var playing = false;\n  function playButtonClicked() {\n    \n    playing = !playing; \n  \n  play_button.text(function(){\n    if(playing) {\n      play_button.attr(\"class\", \"btn btn-danger\")\n      return \"◼\"\n  } else {\n    play_button.attr(\"class\", \"btn btn-outline-success\")\n    return \"▶\"\n  }\n  })\n  \n  if (playing) {\n    continuouslyDrawSamples();\n  }\n  }\n  \n  function continuouslyDrawSamples() {\n    if (playing) {\n      newSample();\n      sleep(200).then(continuouslyDrawSamples);\n    }\n  }\n  \n    \n  var popData = [];\n  const color = d3.scaleOrdinal(d3.schemeCategory10);\n  for (let i = 0; i < population.length; ++i) {\n    const cx = xScalePopulation(population[i]);\n    const cy = 10 + (dodge(cx) - radius - 1);\n    <!-- const cy = yScalePopulation(dodge(cx)); -->\n    const fill = color(i % 10);\n    popData.push({cx, cy, fill})\n  }\n  \n  \n  \n  const populationLabels = [{label: \"Population\", top: 0},\n                            {label: \"Sample\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion) * 100},\n                            {label: \"Under/over-</br>estimation of</br>parameter\",     top: (panelSpacing /  maxHeight + populationSubPanelProportion + sampleSubPanelProportion) * 100}]\n  \n  const populationContainer = d3.select(\"#population-container\")\n    .style(\"position\", \"relative\")\n    <!-- .style(\"height\", maxHeight) -->\n    \n    // panel labels\n  populationContainer.selectAll(\"text\").data(populationLabels).enter()\n    .append(\"text\")\n    .style(\"position\", \"absolute\")\n    .html(d => d.label)\n    .attr(\"class\", \"panel-label\")\n    .style(\"top\", d => d.top + \"%\")\n    .style(\"line-height\", \"1em\")\n\n  const populationAndSampleSvg = d3.select(\"#population-container\")\n    .append(\"svg\").attr(\"id\", \"populationAndSample-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + (populationPanelWidth) + \" \" + populationPanelHeight)\n    \n    // panel backgrounds\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight * populationSubPanelProportion)\n    .attr(\"fill\", \"var(--population-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * populationSubPanelProportion)\n    .attr(\"height\", populationPanelHeight * sampleSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--sample-panel-background)\")\n    .attr(\"rx\", 5)\n  populationAndSampleSvg.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"y\", panelSpacing + populationPanelHeight * (1 - estimatesSubPanelProportion))\n    .attr(\"height\", populationPanelHeight * estimatesSubPanelProportion - panelSpacing)\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n    \n\n    \n  const pop = populationAndSampleSvg.append(\"g\")\n  const parameters = populationAndSampleSvg.append(\"g\")\n  const sampleEstimates = populationAndSampleSvg.append(\"g\")\n  const sampleEstimatesTemp = populationAndSampleSvg.append(\"g\")\n  const sampleCircles = populationAndSampleSvg.append(\"g\")\n\n  const biasDots  = sampleEstimates.append(\"g\")\n  \n  pop.selectAll(\"circle\")\n      .data(popData)\n      .enter()\n      .append(\"circle\")\n        .attr(\"class\", \"pop\")\n        .attr(\"cx\", d => d.cx)\n        .attr(\"cy\", d => yScalePopulation(d.cy))\n        .attr(\"r\", radius)\n        .attr(\"fill\", d => d.fill)\n        \n    // estimates axis\n    \n  const estimatesAxis = sampleEstimates.append(\"g\")\n    .attr(\"transform\", `translate(0, ${yScaleEstimates(21)})`)\n  \n  estimatesAxis.append(\"rect\")\n    .attr(\"width\", populationPanelWidth)\n    .attr(\"height\", populationPanelHeight - yScaleEstimates(21))\n    .attr(\"fill\", \"var(--estimates-panel-background)\")\n    .attr(\"rx\", 5)\n  estimatesAxis.call(xAxisEstimates)\n  estimatesAxis.select(\".domain\").remove()\n  \n\n\n  \n  formatAxes(estimatesAxis.selectAll(\"line\"));\n  \n    \n  var legendStatus = [{param: \"mean\",       hide: true},\n                      {param: \"population\", hide: false},\n                      {param: \"sample\",     hide: false}]\n                      \n  \n  function updateLegendStatus(param) {\n    var index;\n    if (param===\"mean\") {index = 0;}\n    if (param===\"population\") {index = 1;}\n    if (param===\"sample\") {index = 2;}\n    legendStatus[index].hide = !legendStatus[index].hide\n\n    var classes = \"#\" + param + \"-estimate\"\n    \n    populationAndSampleSvg.selectAll(classes).classed(\"hide\", legendStatus[index].hide)\n    timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[index].hide)\n    legend.classed(\"unselected\", d => d.hide)\n  }\n  \n    const legend = d3.selectAll(\".selector\")\n    legend\n      .data(legendStatus)\n      .classed(\"unselected\", d => d.hide)\n      .on(\"click\", function(event, d){updateLegendStatus(d.param);})\n  \n\n\n  \n  // buttons\n  const controls = d3.select(\"#controls-container\")\n  \n  const reset_button = controls.append(\"button\")\n    .attr(\"class\", \"btn btn-outline-primary\")\n    // .attr(\"type\", \"button\")\n    .text(\"Reset\")\n    .on(\"click\", clearData)\n  \n  const button = controls.append(\"button\")\n    .attr(\"class\", \"btn btn-outline-primary\")\n    .text(\"Take one sample\")\n    .on(\"click\", newSample)\n    \n  const play_button = controls.append(\"button\")\n    .attr(\"id\", \"play-button\")\n    .attr(\"class\", \"btn btn-outline-success\")\n    // .attr(\"class\", \"button invertable\")\n    .attr(\"x\", 50)\n    .attr(\"y\", h - 50)\n    .text(\"▶\")\n    .on(\"click\", playButtonClicked)\n    \n\n\n// make timeseries chart\nconst timeChart = {\n    width: timeSeriesPanelWidth,\n    height: maxHeight,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\nconst timeChartHorizontal = {\n    width: populationPanelWidth,\n    height: 300,\n    margin: {left: 30, right: 30, top: 50, bottom: 60}\n}\n\n  const timeseriesContainer = d3.select(\"#timeline-container\");\n  timeseriesContainer.style(\"position\", \"relative\")\n\n  updateTimeseriesDimensions(window.innerWidth);\n\n  // Re-render the chart whenever the window size changes\n  window.addEventListener(\"resize\", () => updateTimeseriesDimensions(window.innerWidth));\n\n\n\n  function updateTimeseriesDimensions(winWidth) {\n\n    const largeScreen = winWidth > 600;\n    if (largeScreen === isLargeScreen) return;\n    // Update the screen state\n    isLargeScreen = largeScreen;\n    \n  var params;\n  var orientation = (winWidth > 600) ? \"vertical\" : \"horizontal;\"\n\n  console.log(orientation);\n\n  // first, set up chart dimensions and axes\n  if (winWidth > 600) {\n\n    params = timeChart;\n\n    timeScaleBias = d3.scaleLinear()\n      .domain([-0.5, 0.5])\n      .range([params.margin.left, params.width - params.margin.right])\n    timeScaleId = d3.scaleLinear()\n      .domain([0, 200])\n      .range([params.margin.top, params.height - params.margin.bottom])\n    biasLine = function(x, y){\n        return d3.line()\n        .x(function(d,i) { return timeScaleBias(x[i]); })\n        .y(function(d,i) { return timeScaleId(y[i]); })\n        (Array(x.length));\n    }\n    timeBiasAxis = d3.axisTop(timeScaleBias)\n      .ticks(5)\n      .tickSize(-(params.height - params.margin.top - params.margin.bottom)) // 440\n    timeIdAxis = d3.axisRight(timeScaleId).tickSize(0)\n  } else {\n\n      params = timeChartHorizontal;\n\n      timeScaleBias = d3.scaleLinear()\n        .domain([-0.5, 0.5])\n        .range([params.height - params.margin.bottom, params.margin.top])\n        \n      timeScaleId = d3.scaleLinear()\n        .domain([0, 200])\n        .range([params.margin.left, params.width - params.margin.right])\n      biasLine = function(x, y){\n          return d3.line()\n          .x(function(d,i) { return timeScaleId(y[i]); })\n          .y(function(d,i) { return timeScaleBias(x[i]); })\n          (Array(x.length));\n      }\n    timeIdAxis = d3.axisBottom(timeScaleId)\n      .tickSize(0)\n    timeBiasAxis = d3.axisLeft(timeScaleBias)\n      .ticks(5).tickSize(-params.width - params.margin.left - params.margin.right)\n  }\n\n  // then instantiate the chart svg itself\n  d3.select(\"#timeline-container\").select(\"svg\").remove();\n  d3.select(\"#timeline-container\").selectAll(\"text\").remove();\n  timeSvg = makeTimeseriesChart(params);\n  timeseriesDataLayer = timeSvg.append(\"g\");\n  timeseriesBiasAxisLayer = timeSvg.append(\"g\").attr(\"class\", \"timeseries\");\n  timeseriesIdAxisLayer = timeSvg.append(\"g\").attr(\"class\", \"timeseries\");\n\n  // then place the axes\n  positionTimeAxes(orientation, params);\n\n  // then draw the current data\n  updatePath();\n}\n  \n\n  \n  function makeTimeseriesChart(params) {\n    \n    // text labels\n    timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"left\", 0)\n    .attr(\"class\", \"panel-label timeseries\")\n    .text(\"Average under/over-estimation\")\n  \n  timeseriesContainer.append(\"text\")\n    .style(\"position\", \"absolute\")\n    .style(\"line-height\", \"1em\")\n    .style(\"bottom\", 0)\n    .style(\"right\", 0)\n    .style(\"text-align\", \"right\")\n    .attr(\"class\", \"timeseries\")\n    .html(\"Total<br>samples\")\n    \n    const svg = d3.select(\"#timeline-container\")\n    .append(\"svg\").attr(\"id\", \"timeline-svg\")\n    .attr(\"preserveAspectRatio\", \"xMinYMin meet\")\n    .attr(\"viewBox\", \"0 0 \" + params.width + \" \" + params.height)\n    \n    // background panel\n  svg.append(\"rect\")\n    .attr(\"width\", params.width)\n    .attr(\"height\", params.height)\n    .attr(\"rx\", 5)\n    .attr(\"fill\", \"var(--timeseries-panel-background)\")\n    \n    return svg;\n    \n  }\n  \n  \n  function positionTimeAxes(orientation, params) {\n    if (orientation === \"vertical\") {\n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(0, ${params.margin.top})`)\n\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"width\", params.width)\n        .attr(\"y\", -params.margin.top)\n        .attr(\"height\", params.margin.top)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n\n        timeseriesIdAxisLayer.attr(\"transform\", `translate(${params.width - params.margin.right}, 0)`)\n  \n    } else {\n      timeseriesIdAxisLayer.attr(\"transform\", `translate(0, ${params.height - params.margin.bottom})`)\n\n      // todo: this isn't positioned correctly\n      timeseriesBiasAxisLayer.append(\"rect\")\n        .attr(\"x\", -params.margin.left)\n        .attr(\"width\", params.margin.left)\n        .attr(\"height\", params.height)\n        .attr(\"rx\", 5)\n        .attr(\"fill\", \"var(--timeseries-panel-background)\")\n      \n      timeseriesBiasAxisLayer.attr(\"transform\", `translate(${params.margin.left}, 0)`)\n        \n      \n    }\n    timeseriesIdAxisLayer.call(timeIdAxis)\n    timeseriesBiasAxisLayer.call(timeBiasAxis);\n    timeseriesBiasAxisLayer.select(\".domain\").remove();\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    formatAxes(timeSvg.selectAll(\"line\"));\n    \n    timeSvg.selectAll(\"line\").classed(\"dark\", true)\n  }\n  \n  \n  function updatePath() {\n      timeseriesDataLayer.selectAll(\"g\").remove()\n      \n      if (nSamplesDrawn > 201) {\n        timeScaleId.domain([nSamplesDrawn - 200, nSamplesDrawn]);\n        // timeIdAxis = d3.axisRight(timeScaleId).tickSize(0);\n        timeseriesIdAxisLayer.call(timeIdAxis);\n        timeseriesIdAxisLayer.select(\".domain\").remove();\n      }\n      \n      timeseriesDataLayer.selectAll(\"g\")\n        .data(running_averages)\n        .enter()\n        .append(\"g\")\n        .attr(\"class\", \"bias-paths\")\n        .append(\"path\")\n          .attr(\"d\", d => biasLine(d.value.slice(1), d.id.slice(1)))\n          .attr(\"id\", d => d.param + \"-path\")\n\n  }\n  \n\n\nfunction clearData() {\n    sample = [];\n    sample_estimates = [];\n    running_averages = [{param: \"population\",   value: [0], id: [0]},\n                          {param: \"sample\",     value: [0], id: [0]},\n                          {param: \"mean\",       value: [0], id: [0]}];\n    nSamplesDrawn = 0;\n    \n    timeScaleId.domain([0, 200]);\n    timeseriesIdAxisLayer.call(timeIdAxis);\n    timeseriesIdAxisLayer.select(\".domain\").remove();\n    \n    sampleCircles.selectAll('circle').remove()\n    sampleEstimates.selectAll(\"path\").remove()\n    sampleEstimatesTemp.selectAll(\"path\").remove()\n    timeseriesDataLayer.selectAll(\"path\").remove()\n  }\n  \n  function updateRunningAverages(estimates) {\n  \n      var cur_n = nSamplesDrawn\n      var prev_n = cur_n - 1\n      \n      var old = running_averages[0].value[prev_n]\n      var new_pop = ((old * prev_n) + estimates[0].value)/cur_n\n      running_averages[0].value.push(new_pop)\n      \n      var old = running_averages[1].value[prev_n]\n      var new_sam = ((old * prev_n) + estimates[1].value)/cur_n\n      running_averages[1].value.push(new_sam)\n      \n      var old = running_averages[2].value[prev_n]\n      var new_mea = ((old * prev_n) + estimates[2].value)/cur_n\n      running_averages[2].value.push(new_mea)\n    \n      running_averages[0].id.push(cur_n)\n      running_averages[1].id.push(cur_n)\n      running_averages[2].id.push(cur_n)\n\n}\n\n  function updateVisibility() {\n  \n    var params = [\"mean\", \"population\", \"sample\"]\n    \n    for (var i = 0; i < 3; i++) {\n      var param = params[i]\n      var elementIds = \"#\" + param + \"-estimate, #\" + param + \"-line\"\n      \n      populationAndSampleSvg.selectAll(elementIds).classed(\"hide\", legendStatus[i].hide)\n      <!-- populationAndSampleSvg.selectAll(\"#\" + param + \"-estimate\").classed(\"hide\", legendStatus[i].hide) -->\n      timeSvg.selectAll(\"#\" + param + \"-path\").classed(\"hide\", legendStatus[i].hide)\n    }\n  }\n  \n}\n\n```\n\n\n::: content-hidden\n# Helper functions\n:::\n\n\n```{ojs}\n\ndodger = radius => {\n  const radius2 = radius ** 1.9;\n  const bisect = d3.bisector(d => d.x);\n  const circles = [];\n  return x => {\n    const l = bisect.left(circles, x - radius);\n    const r = bisect.right(circles, x + radius, l);\n    let y = 0;\n    for (let i = l; i < r; ++i) {\n      const { x: xi, y: yi } = circles[i];\n      const x2 = (xi - x) ** 2;\n      const y2 = (yi - y) ** 2;\n      if (radius2 > x2 + y2) {\n        y = yi + Math.sqrt(radius2 - x2) + 1e-6;\n        i = l - 1;\n        continue;\n      }\n    }\n    circles.splice(bisect.left(circles, x, l, r), 0, { x, y });\n    <!-- populationPanelHeight * 0.7 - d.cy + (radius * 2) -->\n    return y;\n  };\n}\n\ndodge = dodger(radius * 2 + 0.75);\n```\n\n```{ojs}\n\nfunction mean(array) {\n    return array.reduce((a, b) => a + b) / array.length;\n}\n\nfunction sample_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / (n - 1);\n}\n\nfunction population_variance(array) {\n    const n = array.length\n    const m = mean(array)\n    return array.map(x => Math.pow(x - m, 2)).reduce((a, b) => a + b) / n;\n}\n\nfunction get_descriptives (array) {\n    return {mean: mean(array),\n            sample_variance: sample_variance(array) - 1, \n            population_variance: population_variance(array) - 1}\n}\n\nfunction getNewData (array) {\n    \n    return {sample_estimates: getSampleEstimates(array)\n            <!-- running_averages: getRunningAverages(array) -->\n            }\n}\n\nfunction getSampleEstimates(array) {\n    return [{param: \"population\", value: population_variance(array) - 1},\n            {param: \"sample\",     value: sample_variance(array) - 1},\n            {param: \"mean\",       value: mean(array)}]\n}\n\n\nfunction formatAxes(elements) {\n  elements._groups[0].forEach((l) => {\n    if (l.__data__ === 0) {\n      l.classList = \"axis-major\";\n    } else {\n      l.classList = \"axis-minor\";\n    }\n  })\n}\n\n```\n\n\n::: content-hidden\n# CSS\n:::\n\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n\n:root {\n  --population-color: #eb8471;\n  --sample-color: #41a1ff;\n  --mean-color: #a495cf;\n  --population-panel-background: #c3ddff;\n  --sample-panel-background: #d3d8a8;\n  --estimates-panel-background: #eee;\n  --timeseries-panel-background: #333;\n  --timeseries-panel-color: white;\n}\n\n.g-row {\n  width: 100%;\n}\n\n.panel-label {\n  text-transform: uppercase;\n  justify: left;\n  color: black;\n}\n\n.timeseries {\n  color: var(--timeseries-panel-color);)\n}\n\n/* for desktop */\n#population-container {\n  float: left; \n  width: 59.7%;\n}\n\n#viz {\n  margin: 1em auto 1em auto;\n}\n\n#timeline-container {\n  color: var(--text-color-dark);\n  float: right;\n  width: 39.8%;\n}\n\n#controls {\n  align-items: baseline;\n  width: fit-content;\n  display: flex;\n  margin: auto;\n}\n\n#controls-container {\n  color: var(--text-color);\n  font-size: 0.8em;\n  display: flex;\n  align-items: center;\n  width: fit-content;\n  margin-right: 1em;\n}\n\n#select-estimates {\n  width: fit-content;\n  font-size: 0.7em;\n}\n\n@media screen and (max-width: 600px) {\n  #population-container {\n    width: 100%;\n  }\n\n  #timeline-container {\n    width: 100%;\n    margin-top: 1vw;\n  }\n\n  #controls {\n    width: 100%;\n    display: block;\n  }\n  #controls-container {\n    width: fit-content;\n    margin: auto;\n  }\n\n  #select-estimate {\n    width: fit-content;\n    margin: auto;\n  }\n}\n\n.axis {\n  font-size: 0.75em;\n}\n.bias-chart-title {\n  font-size: 1.2em;\n}\n.axis-major {\n  stroke: #aaa;\n  stroke-width: 1;\n}\n.axis-minor {\n  stroke: #ddd;\n  stroke-width: 1;\n}\n\n.axis-major.dark {\n  stroke: #ccc;\n  stroke-width: 1;\n}\n.axis-minor.dark {\n  stroke: #777;\n  stroke-width: 1;\n}\n\n\n.sample {\n  stroke: white;\n}\n\n#sample-estimate, #sample-line, #sample-legend {\n  fill: var(--sample-color);\n  stroke: var(--sample-color);\n}\n\n#mean-estimate, #mean-line, #mean-legend {\n  fill:   var(--mean-color);\n  stroke: var(--mean-color);\n}\n\n#population-estimate, #population-line, #population-legend {\n  fill:   var(--population-color);\n  stroke: var(--population-color);\n}\n\n.legend-unselected {\n  fill-opacity: 0.1 !important;\n}\n\n\n.bias-paths {\n  fill: none;\n  stroke-width: 2;\n}\n\n#mean-path {\n  stroke: var(--mean-color);\n}\n#sample-path {\n  stroke: var(--sample-color);\n}\n#population-path {\n  stroke: var(--population-color);\n}\n\n.hide {\n  fill: none !important;\n  stroke: none !important;\n}\n\n\n.button {\n   font-family: Times;\n}\n.button:hover {\n  fill: red;\n  cursor: pointer;\n}\n\n\n.legend-dots:hover {\n  cursor: pointer;\n}\n\n\n.selector {\n  margin-right: 1em;\n  cursor: pointer;\n}\n.selector::after {\n  content: \"\";\n  display: inline-block;\n  width: 10px;\n  height: 10px;\n  transform: translate(50%, -10%) rotate(45deg);\n}\n\n.select-mean::after {\n  background-color: var(--mean-color);\n  border: 1px solid var(--mean-color);\n}\n.select-mean::after .unselected {\n  background-color: \"black\";\n  border: 1px solid var(--mean-color);\n}\n.select-population::after {\n  background-color: var(--population-color);\n  border: 1px solid var(--population-color);\n}\n.select-sample::after {\n  background-color: var(--sample-color);\n  border: 1px solid var(--sample-color);\n}\n\n.unselected::after {\n  opacity: 0.2;\n}\n\n.unselected:hover::after {\n  opacity: 0.5;\n}\n\n</style>\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script type=\"ojs-define\">\r\n{\"contents\":[{\"name\":\"data\",\"value\":[{\"value\":-4,\"density\":0.0001},{\"value\":-3.96,\"density\":0.0002},{\"value\":-3.92,\"density\":0.0002},{\"value\":-3.88,\"density\":0.0002},{\"value\":-3.84,\"density\":0.0003},{\"value\":-3.8,\"density\":0.0003},{\"value\":-3.76,\"density\":0.0003},{\"value\":-3.72,\"density\":0.0004},{\"value\":-3.68,\"density\":0.0005},{\"value\":-3.64,\"density\":0.0005},{\"value\":-3.6,\"density\":0.0006},{\"value\":-3.56,\"density\":0.0007},{\"value\":-3.52,\"density\":0.0008},{\"value\":-3.48,\"density\":0.0009},{\"value\":-3.44,\"density\":0.0011},{\"value\":-3.4,\"density\":0.0012},{\"value\":-3.36,\"density\":0.0014},{\"value\":-3.32,\"density\":0.0016},{\"value\":-3.28,\"density\":0.0018},{\"value\":-3.24,\"density\":0.0021},{\"value\":-3.2,\"density\":0.0024},{\"value\":-3.16,\"density\":0.0027},{\"value\":-3.12,\"density\":0.0031},{\"value\":-3.08,\"density\":0.0035},{\"value\":-3.04,\"density\":0.0039},{\"value\":-3,\"density\":0.0044},{\"value\":-2.96,\"density\":0.005},{\"value\":-2.92,\"density\":0.0056},{\"value\":-2.88,\"density\":0.0063},{\"value\":-2.84,\"density\":0.0071},{\"value\":-2.8,\"density\":0.0079},{\"value\":-2.76,\"density\":0.0088},{\"value\":-2.72,\"density\":0.0099},{\"value\":-2.68,\"density\":0.011},{\"value\":-2.64,\"density\":0.0122},{\"value\":-2.6,\"density\":0.0136},{\"value\":-2.56,\"density\":0.0151},{\"value\":-2.52,\"density\":0.0167},{\"value\":-2.48,\"density\":0.0184},{\"value\":-2.44,\"density\":0.0203},{\"value\":-2.4,\"density\":0.0224},{\"value\":-2.36,\"density\":0.0246},{\"value\":-2.32,\"density\":0.027},{\"value\":-2.28,\"density\":0.0297},{\"value\":-2.24,\"density\":0.0325},{\"value\":-2.2,\"density\":0.0355},{\"value\":-2.16,\"density\":0.0387},{\"value\":-2.12,\"density\":0.0422},{\"value\":-2.08,\"density\":0.0459},{\"value\":-2.04,\"density\":0.0498},{\"value\":-2,\"density\":0.054},{\"value\":-1.96,\"density\":0.0584},{\"value\":-1.92,\"density\":0.0632},{\"value\":-1.88,\"density\":0.0681},{\"value\":-1.84,\"density\":0.0734},{\"value\":-1.8,\"density\":0.079},{\"value\":-1.76,\"density\":0.0848},{\"value\":-1.72,\"density\":0.0909},{\"value\":-1.68,\"density\":0.0973},{\"value\":-1.64,\"density\":0.104},{\"value\":-1.6,\"density\":0.1109},{\"value\":-1.56,\"density\":0.1182},{\"value\":-1.52,\"density\":0.1257},{\"value\":-1.48,\"density\":0.1334},{\"value\":-1.44,\"density\":0.1415},{\"value\":-1.4,\"density\":0.1497},{\"value\":-1.36,\"density\":0.1582},{\"value\":-1.32,\"density\":0.1669},{\"value\":-1.28,\"density\":0.1758},{\"value\":-1.24,\"density\":0.1849},{\"value\":-1.2,\"density\":0.1942},{\"value\":-1.16,\"density\":0.2036},{\"value\":-1.12,\"density\":0.2131},{\"value\":-1.08,\"density\":0.2227},{\"value\":-1.04,\"density\":0.2323},{\"value\":-1,\"density\":0.242},{\"value\":-0.96,\"density\":0.2516},{\"value\":-0.92,\"density\":0.2613},{\"value\":-0.88,\"density\":0.2709},{\"value\":-0.84,\"density\":0.2803},{\"value\":-0.8,\"density\":0.2897},{\"value\":-0.76,\"density\":0.2989},{\"value\":-0.72,\"density\":0.3079},{\"value\":-0.68,\"density\":0.3166},{\"value\":-0.64,\"density\":0.3251},{\"value\":-0.6,\"density\":0.3332},{\"value\":-0.56,\"density\":0.341},{\"value\":-0.52,\"density\":0.3485},{\"value\":-0.48,\"density\":0.3555},{\"value\":-0.44,\"density\":0.3621},{\"value\":-0.4,\"density\":0.3683},{\"value\":-0.36,\"density\":0.3739},{\"value\":-0.32,\"density\":0.379},{\"value\":-0.28,\"density\":0.3836},{\"value\":-0.24,\"density\":0.3876},{\"value\":-0.2,\"density\":0.391},{\"value\":-0.16,\"density\":0.3939},{\"value\":-0.12,\"density\":0.3961},{\"value\":-0.08,\"density\":0.3977},{\"value\":-0.04,\"density\":0.3986},{\"value\":0,\"density\":0.3989},{\"value\":0.04,\"density\":0.3986},{\"value\":0.08,\"density\":0.3977},{\"value\":0.12,\"density\":0.3961},{\"value\":0.16,\"density\":0.3939},{\"value\":0.2,\"density\":0.391},{\"value\":0.24,\"density\":0.3876},{\"value\":0.28,\"density\":0.3836},{\"value\":0.32,\"density\":0.379},{\"value\":0.36,\"density\":0.3739},{\"value\":0.4,\"density\":0.3683},{\"value\":0.44,\"density\":0.3621},{\"value\":0.48,\"density\":0.3555},{\"value\":0.52,\"density\":0.3485},{\"value\":0.56,\"density\":0.341},{\"value\":0.6,\"density\":0.3332},{\"value\":0.64,\"density\":0.3251},{\"value\":0.68,\"density\":0.3166},{\"value\":0.72,\"density\":0.3079},{\"value\":0.76,\"density\":0.2989},{\"value\":0.8,\"density\":0.2897},{\"value\":0.84,\"density\":0.2803},{\"value\":0.88,\"density\":0.2709},{\"value\":0.92,\"density\":0.2613},{\"value\":0.96,\"density\":0.2516},{\"value\":1,\"density\":0.242},{\"value\":1.04,\"density\":0.2323},{\"value\":1.08,\"density\":0.2227},{\"value\":1.12,\"density\":0.2131},{\"value\":1.16,\"density\":0.2036},{\"value\":1.2,\"density\":0.1942},{\"value\":1.24,\"density\":0.1849},{\"value\":1.28,\"density\":0.1758},{\"value\":1.32,\"density\":0.1669},{\"value\":1.36,\"density\":0.1582},{\"value\":1.4,\"density\":0.1497},{\"value\":1.44,\"density\":0.1415},{\"value\":1.48,\"density\":0.1334},{\"value\":1.52,\"density\":0.1257},{\"value\":1.56,\"density\":0.1182},{\"value\":1.6,\"density\":0.1109},{\"value\":1.64,\"density\":0.104},{\"value\":1.68,\"density\":0.0973},{\"value\":1.72,\"density\":0.0909},{\"value\":1.76,\"density\":0.0848},{\"value\":1.8,\"density\":0.079},{\"value\":1.84,\"density\":0.0734},{\"value\":1.88,\"density\":0.0681},{\"value\":1.92,\"density\":0.0632},{\"value\":1.96,\"density\":0.0584},{\"value\":2,\"density\":0.054},{\"value\":2.04,\"density\":0.0498},{\"value\":2.08,\"density\":0.0459},{\"value\":2.12,\"density\":0.0422},{\"value\":2.16,\"density\":0.0387},{\"value\":2.2,\"density\":0.0355},{\"value\":2.24,\"density\":0.0325},{\"value\":2.28,\"density\":0.0297},{\"value\":2.32,\"density\":0.027},{\"value\":2.36,\"density\":0.0246},{\"value\":2.4,\"density\":0.0224},{\"value\":2.44,\"density\":0.0203},{\"value\":2.48,\"density\":0.0184},{\"value\":2.52,\"density\":0.0167},{\"value\":2.56,\"density\":0.0151},{\"value\":2.6,\"density\":0.0136},{\"value\":2.64,\"density\":0.0122},{\"value\":2.68,\"density\":0.011},{\"value\":2.72,\"density\":0.0099},{\"value\":2.76,\"density\":0.0088},{\"value\":2.8,\"density\":0.0079},{\"value\":2.84,\"density\":0.0071},{\"value\":2.88,\"density\":0.0063},{\"value\":2.92,\"density\":0.0056},{\"value\":2.96,\"density\":0.005},{\"value\":3,\"density\":0.0044},{\"value\":3.04,\"density\":0.0039},{\"value\":3.08,\"density\":0.0035},{\"value\":3.12,\"density\":0.0031},{\"value\":3.16,\"density\":0.0027},{\"value\":3.2,\"density\":0.0024},{\"value\":3.24,\"density\":0.0021},{\"value\":3.28,\"density\":0.0018},{\"value\":3.32,\"density\":0.0016},{\"value\":3.36,\"density\":0.0014},{\"value\":3.4,\"density\":0.0012},{\"value\":3.44,\"density\":0.0011},{\"value\":3.48,\"density\":0.0009},{\"value\":3.52,\"density\":0.0008},{\"value\":3.56,\"density\":0.0007},{\"value\":3.6,\"density\":0.0006},{\"value\":3.64,\"density\":0.0005},{\"value\":3.68,\"density\":0.0005},{\"value\":3.72,\"density\":0.0004},{\"value\":3.76,\"density\":0.0003},{\"value\":3.8,\"density\":0.0003},{\"value\":3.84,\"density\":0.0003},{\"value\":3.88,\"density\":0.0002},{\"value\":3.92,\"density\":0.0002},{\"value\":3.96,\"density\":0.0002},{\"value\":4,\"density\":0.0001}]}]}\r\n</script>\r\n<script type=\"ojs-define\">\r\n{\"contents\":[{\"name\":\"population\",\"value\":[[0.2601],[-0.5257],[0.9582],[0.6527],[1.7287],[0.7492],[-1.2904],[-0.1848],[1.9988],[1.8749],[0.6222],[0.052],[0.4323],[-0.0109],[0.0713],[0.2107],[1.2416],[-0.01],[-0.0681],[-0.2576],[1.6306],[0.2067],[1.3892],[1.3692],[0.6495],[-0.2571],[1.3357],[0.9775],[-0.9248],[1.3194],[0.1946],[1.1246],[-0.7449],[-1.4984],[0.9271],[-0.3829],[-0.1996],[1.0026],[-0.4465],[-0.6241],[1.4266],[0.2237],[1.3736],[-1.7115],[-0.814],[-0.8566],[0.1381],[-0.353],[0.7851],[-1.8246],[-0.6512],[-0.6098],[-0.0466],[0.4867],[2.0758],[-0.5819],[-0.5361],[0.7561],[-0.1253],[1.432],[-1.0702],[1.1375],[-1.323],[2.1718],[0.1718],[-0.204],[-0.3755],[0.9564],[0.5804],[-0.1415],[0.2],[-0.4669],[-0.9567],[0.2226],[0.7828],[-0.3467],[0.2816],[-0.6535],[-0.789],[-0.0177],[1.3678],[-0.1859],[-0.5591],[-1.4865],[-1.0332],[-1.3166],[-0.8319],[-1.1345],[0.4175],[-0.1731],[-1.2867],[-0.7902],[0.2004],[0.6721],[0.7478],[-0.0129],[2.4478],[-0.562],[1.0382],[-0.2515],[0.7446],[-0.0834],[-0.3332],[-0.0737],[0.0822],[-1.7509],[1.6461],[0.8394],[-1.1012],[-1.7528],[0.4784],[0.8064],[0.9313],[0.3518],[-0.0822],[0.4743],[-0.7899],[-0.5896],[1.8109],[-0.7053],[-0.1021],[-0.999],[1.9752],[-0.3134],[1.0432],[1.0582],[-0.9385],[0.3972],[-0.5795],[-2.43],[1.1516],[0.7274],[-0.9627],[-2.0087],[-0.5695],[1.039],[0.6074],[-0.0493],[-1.6997],[1.2909],[1.0714],[0.7803],[-0.8382],[0.6796],[-0.7122],[-0.4295],[-1.2016],[0.4399],[-0.4987],[0.9775],[0.9435],[-0.809],[1.629],[1.4585],[-0.4644],[0.6054],[-0.8516],[-0.696],[-2.1348],[1.1738],[0.3898],[0.5438],[-0.9289],[-1.4422],[1.0457],[-1.5648],[0.0541],[-0.7661],[-0.2016],[-0.2482],[1.8948],[-0.4591],[-0.5798],[-2.3013],[1.7774],[0.1106],[-0.4197],[0.6843],[-0.7921],[-1.1318],[-1.0252],[0.1093],[0.4309],[-1.6437],[2.0029],[-0.7055],[0.4296],[0.4921],[0.3021],[-0.15],[-0.6785],[0.0353],[0.6212],[-1.2153],[-0.3225],[-0.6372],[-0.885],[1.5646],[-1.2016],[1.8476],[1.2931],[-1.5663],[-0.2771],[1.1114],[-0.759],[1.6139],[-2.4712],[0.6116],[1.1801],[0.208],[-0.1976],[-0.2006],[-0.2263],[2.1766],[1.6745],[-1.0434],[0.0271],[-1.3451],[0.1874],[-0.7797],[-0.2634],[0.726],[-0.1056],[0.2677],[1.1921],[-1.4531],[0.6924],[-0.4809],[1.2015],[-0.0679],[-1.113],[0.7168],[-0.009],[0.6862],[-0.9339],[-0.3341],[-0.0109],[-0.3245],[-0.3358],[0.4453],[-0.9827],[0.0123],[-0.8798],[0.5378],[-0.8249],[1.2501],[0.0989],[0.198],[0.5211],[0.6],[0.4452],[-0.9179],[-0.6645],[-1.9763],[0.16],[1.3462],[-1.1007],[0.489],[0.6738],[0.0543],[-1.2469],[-0.4861],[1.3987],[0.8581],[0.5378],[2.4899],[-0.2558],[0.2417],[0.8744],[-0.0908],[1.0788],[0.5715],[-0.2023],[-0.1377],[-2.5271],[-0.5865],[0.0684],[1.3049],[-0.688],[-1.5211],[-0.1973],[0.0265],[-1.4944],[-1.8768],[-0.8399],[1.3355],[-1.3621],[0.3709],[0.1587],[0.7082],[0.7413],[2.6416],[0.3489],[-0.6513],[0.1009],[-1.1935],[-0.3995],[-0.7381],[-0.095],[-1.0186],[-2.9034],[1.6002],[1.5287],[0.5589],[-0.7481],[0.2938],[-0.2922],[0.1423],[-0.1833],[0.3158],[-0.282],[0.9568],[0.4374],[-2.3183],[-0.5335],[0.3777],[-0.5833],[-1.2705],[0.8258],[0.9062],[0.1995],[1.119],[-0.64],[-0.9586],[-0.1724],[0.7537],[-0.9972],[-0.9989],[-0.3403],[1.1305],[1.1526],[1.3172],[0.9198],[-0.8063],[-0.345],[1.1926],[0.1535],[-0.4244],[-1.4606],[-0.3621],[0.6497],[0.2894],[-1.7712],[0.1004],[-1.0883],[-0.0755],[0.5028],[1.1685],[0.9735],[-0.9967],[-0.7052],[0.4732],[0.4839],[0.1233],[0.6072],[-0.5208],[0.1659],[1.0749],[1.1452],[-0.4304],[1.0278],[0.9718],[-1.2387],[-0.2649],[-1.6743],[0.0745],[-2.0785],[0.1509],[0.3579],[-0.6255],[1.0012],[-0.2465],[1.3212],[-1.0621],[1.9901],[-1.1733],[0.4695],[-1.6746],[0.2189],[-0.1132],[2.4813],[1.2954],[0.4532],[0.6958],[-0.8845],[-1.3255],[0.2202],[-1.4379],[-1.5206],[-1.0773],[0.1825],[0.3072],[1.2715],[-1.7103],[0.2842],[-1.1282],[-0.8442],[-0.3148],[-0.026],[-0.1235],[-1.1878],[0.508],[-0.2109],[0.8764],[-0.7205],[-2.2354],[1.0724],[1.2441],[0.8324],[1.6794],[0.3994],[-0.5173],[-0.2591],[-0.0188],[0.1025],[-0.5632],[0.0227],[0.9732],[-0.4929],[0.259],[-0.5685],[-1.2239],[0.212],[0.1715],[-0.2122],[-0.5506],[0.0762],[-1.9423],[0.0098],[0.7242],[1.4051],[3.3212],[-1.8983],[-1.3596],[2.4202],[0.3002],[0.9345],[0.4041],[-1.1499],[0.342],[-0.6846],[1.2623],[1.6144],[0.4714],[1.6496],[1.7213],[0.215],[-0.3153],[-1.2862],[0.0983],[-1.1383],[-0.0298],[-0.7225],[1.1475],[1.5665],[-2.586],[-0.8127],[0.3658],[-0.9683],[-0.3639],[-0.0018],[0.8507],[0.48],[0.7153],[-0.739],[0.0481],[-0.5923],[1.4911],[-0.6164],[-0.8696],[-1.1991],[0.4163],[-0.6888],[-0.4046],[1.085],[0.471],[1.4076],[1.1168],[-0.64],[-1.6822],[-1.5271],[0.3596],[-1.9284],[-0.5907],[-0.3276],[-1.01],[-0.4284],[0.9342],[0.1177],[-0.6542],[-0.0754],[0.5276],[-0.8304],[0.4789],[-0.6328],[0.6326],[-0.0582],[-0.1431],[-0.4396],[-0.5663],[-1.6666],[-0.8129],[-1.7013],[0.4748],[-0.3252],[-0.0184],[-0.2485],[0.5691],[-1.3155],[1.7944],[-0.4844],[-0.2798],[-0.642],[0.3189],[-1.7488],[-0.471],[-0.1051],[-0.3854],[1.6426],[0.9315],[0.3966],[-1.2668],[0.5283],[0.9393],[-0.5269],[0.237],[0.4486],[0.1709],[-0.5797],[0.7621],[-0.1236],[0.6423],[1.2445],[-2.3475],[0.8847],[0.7832],[0.1368],[1.7309],[-0.5225],[-0.4328],[-1.25],[0.0816],[0.043],[-0.9926],[0.7761],[0.6571],[-0.0211],[0.758],[0.8788],[-2.3662]]}]}\r\n</script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}